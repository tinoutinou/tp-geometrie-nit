/* This C file is generated by NIT to compile program main. */
#include "factory._sep.h"
#include "polygone._sep.h"
#include "figure._sep.h"
#include "utils._sep.h"
#include "standard._sep.h"
#include "environ._sep.h"
#include "symbol._sep.h"
#include "string._sep.h"
#include "collection._sep.h"
#include "range._sep.h"
#include "abstract_collection._sep.h"
#include "kernel._sep.h"
#include "list._sep.h"
#include "sorter._sep.h"
#include "array._sep.h"
#include "hash_collection._sep.h"
#include "hash._sep.h"
#include "time._sep.h"
#include "file._sep.h"
#include "stream._sep.h"
#include "string_search._sep.h"
#include "exec._sep.h"
#include "math._sep.h"
#include "main._sep.h"
#include <nit_common.h>
static const char * const LOCATE_INIT_ATTRIBUTES__Sys = "init var of Sys";
void INIT_ATTRIBUTES__Sys(val_t p0);
typedef void (*INIT_ATTRIBUTES__Sys_t)(val_t p0);
val_t NEW_Sys(void);
static const char * const LOCATE_CHECKNEW_Sys = "check new Sys";
void CHECKNEW_Sys(val_t p0);
typedef void (*CHECKNEW_Sys_t)(val_t p0);
static const char * const LOCATE_NEW_Sys_kernel___Sys___init = "new Sys kernel::Sys::init";
val_t NEW_Sys_kernel___Sys___init(void);
typedef val_t (*NEW_Sys_kernel___Sys___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__Container = "init var of Container";
void INIT_ATTRIBUTES__Container(val_t p0);
typedef void (*INIT_ATTRIBUTES__Container_t)(val_t p0);
val_t NEW_Container(void);
static const char * const LOCATE_CHECKNEW_Container = "check new Container";
void CHECKNEW_Container(val_t p0);
typedef void (*CHECKNEW_Container_t)(val_t p0);
static const char * const LOCATE_NEW_Container_abstract_collection___Container___init = "new Container abstract_collection::Container::init";
val_t NEW_Container_abstract_collection___Container___init(val_t p0);
typedef val_t (*NEW_Container_abstract_collection___Container___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__ContainerIterator = "init var of ContainerIterator";
void INIT_ATTRIBUTES__ContainerIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__ContainerIterator_t)(val_t p0);
val_t NEW_ContainerIterator(void);
static const char * const LOCATE_CHECKNEW_ContainerIterator = "check new ContainerIterator";
void CHECKNEW_ContainerIterator(val_t p0);
typedef void (*CHECKNEW_ContainerIterator_t)(val_t p0);
static const char * const LOCATE_NEW_ContainerIterator_abstract_collection___ContainerIterator___init = "new ContainerIterator abstract_collection::ContainerIterator::init";
val_t NEW_ContainerIterator_abstract_collection___ContainerIterator___init(val_t p0);
typedef val_t (*NEW_ContainerIterator_abstract_collection___ContainerIterator___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__CoupleMapIterator = "init var of CoupleMapIterator";
void INIT_ATTRIBUTES__CoupleMapIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__CoupleMapIterator_t)(val_t p0);
val_t NEW_CoupleMapIterator(void);
static const char * const LOCATE_CHECKNEW_CoupleMapIterator = "check new CoupleMapIterator";
void CHECKNEW_CoupleMapIterator(val_t p0);
typedef void (*CHECKNEW_CoupleMapIterator_t)(val_t p0);
static const char * const LOCATE_NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init = "new CoupleMapIterator abstract_collection::CoupleMapIterator::init";
val_t NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init(val_t p0);
typedef val_t (*NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Couple = "init var of Couple";
void INIT_ATTRIBUTES__Couple(val_t p0);
typedef void (*INIT_ATTRIBUTES__Couple_t)(val_t p0);
val_t NEW_Couple(void);
static const char * const LOCATE_CHECKNEW_Couple = "check new Couple";
void CHECKNEW_Couple(val_t p0);
typedef void (*CHECKNEW_Couple_t)(val_t p0);
static const char * const LOCATE_NEW_Couple_abstract_collection___Couple___init = "new Couple abstract_collection::Couple::init";
val_t NEW_Couple_abstract_collection___Couple___init(val_t p0, val_t p1);
typedef val_t (*NEW_Couple_abstract_collection___Couple___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_INIT_ATTRIBUTES__Range = "init var of Range";
void INIT_ATTRIBUTES__Range(val_t p0);
typedef void (*INIT_ATTRIBUTES__Range_t)(val_t p0);
val_t NEW_Range(void);
static const char * const LOCATE_CHECKNEW_Range = "check new Range";
void CHECKNEW_Range(val_t p0);
typedef void (*CHECKNEW_Range_t)(val_t p0);
static const char * const LOCATE_NEW_Range_range___Range___init = "new Range range::Range::init";
val_t NEW_Range_range___Range___init(val_t p0, val_t p1);
typedef val_t (*NEW_Range_range___Range___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_NEW_Range_range___Range___without_last = "new Range range::Range::without_last";
val_t NEW_Range_range___Range___without_last(val_t p0, val_t p1);
typedef val_t (*NEW_Range_range___Range___without_last_t)(val_t p0, val_t p1);
static const char * const LOCATE_INIT_ATTRIBUTES__IteratorRange = "init var of IteratorRange";
void INIT_ATTRIBUTES__IteratorRange(val_t p0);
typedef void (*INIT_ATTRIBUTES__IteratorRange_t)(val_t p0);
val_t NEW_IteratorRange(void);
static const char * const LOCATE_CHECKNEW_IteratorRange = "check new IteratorRange";
void CHECKNEW_IteratorRange(val_t p0);
typedef void (*CHECKNEW_IteratorRange_t)(val_t p0);
static const char * const LOCATE_NEW_IteratorRange_range___IteratorRange___init = "new IteratorRange range::IteratorRange::init";
val_t NEW_IteratorRange_range___IteratorRange___init(val_t p0);
typedef val_t (*NEW_IteratorRange_range___IteratorRange___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__List = "init var of List";
void INIT_ATTRIBUTES__List(val_t p0);
typedef void (*INIT_ATTRIBUTES__List_t)(val_t p0);
val_t NEW_List(void);
static const char * const LOCATE_CHECKNEW_List = "check new List";
void CHECKNEW_List(val_t p0);
typedef void (*CHECKNEW_List_t)(val_t p0);
static const char * const LOCATE_NEW_List_list___List___init = "new List list::List::init";
val_t NEW_List_list___List___init(void);
typedef val_t (*NEW_List_list___List___init_t)(void);
static const char * const LOCATE_NEW_List_list___List___from = "new List list::List::from";
val_t NEW_List_list___List___from(val_t p0);
typedef val_t (*NEW_List_list___List___from_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__ListIterator = "init var of ListIterator";
void INIT_ATTRIBUTES__ListIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__ListIterator_t)(val_t p0);
val_t NEW_ListIterator(void);
static const char * const LOCATE_CHECKNEW_ListIterator = "check new ListIterator";
void CHECKNEW_ListIterator(val_t p0);
typedef void (*CHECKNEW_ListIterator_t)(val_t p0);
static const char * const LOCATE_NEW_ListIterator_list___ListIterator___init = "new ListIterator list::ListIterator::init";
val_t NEW_ListIterator_list___ListIterator___init(val_t p0);
typedef val_t (*NEW_ListIterator_list___ListIterator___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__ListNode = "init var of ListNode";
void INIT_ATTRIBUTES__ListNode(val_t p0);
typedef void (*INIT_ATTRIBUTES__ListNode_t)(val_t p0);
val_t NEW_ListNode(void);
static const char * const LOCATE_CHECKNEW_ListNode = "check new ListNode";
void CHECKNEW_ListNode(val_t p0);
typedef void (*CHECKNEW_ListNode_t)(val_t p0);
static const char * const LOCATE_NEW_ListNode_list___ListNode___init = "new ListNode list::ListNode::init";
val_t NEW_ListNode_list___ListNode___init(val_t p0);
typedef val_t (*NEW_ListNode_list___ListNode___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__AbstractArrayRead = "init var of AbstractArrayRead";
void INIT_ATTRIBUTES__AbstractArrayRead(val_t p0);
typedef void (*INIT_ATTRIBUTES__AbstractArrayRead_t)(val_t p0);
val_t NEW_AbstractArrayRead(void);
static const char * const LOCATE_CHECKNEW_AbstractArrayRead = "check new AbstractArrayRead";
void CHECKNEW_AbstractArrayRead(val_t p0);
typedef void (*CHECKNEW_AbstractArrayRead_t)(val_t p0);
static const char * const LOCATE_NEW_AbstractArrayRead_array___AbstractArrayRead___init = "new AbstractArrayRead array::AbstractArrayRead::init";
val_t NEW_AbstractArrayRead_array___AbstractArrayRead___init(void);
typedef val_t (*NEW_AbstractArrayRead_array___AbstractArrayRead___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__AbstractArray = "init var of AbstractArray";
void INIT_ATTRIBUTES__AbstractArray(val_t p0);
typedef void (*INIT_ATTRIBUTES__AbstractArray_t)(val_t p0);
val_t NEW_AbstractArray(void);
static const char * const LOCATE_CHECKNEW_AbstractArray = "check new AbstractArray";
void CHECKNEW_AbstractArray(val_t p0);
typedef void (*CHECKNEW_AbstractArray_t)(val_t p0);
static const char * const LOCATE_NEW_AbstractArray_array___AbstractArrayRead___init = "new AbstractArray array::AbstractArrayRead::init";
val_t NEW_AbstractArray_array___AbstractArrayRead___init(void);
typedef val_t (*NEW_AbstractArray_array___AbstractArrayRead___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__Array = "init var of Array";
void INIT_ATTRIBUTES__Array(val_t p0);
typedef void (*INIT_ATTRIBUTES__Array_t)(val_t p0);
val_t NEW_Array(void);
static const char * const LOCATE_CHECKNEW_Array = "check new Array";
void CHECKNEW_Array(val_t p0);
typedef void (*CHECKNEW_Array_t)(val_t p0);
static const char * const LOCATE_NEW_Array_array___Array___with_capacity = "new Array array::Array::with_capacity";
val_t NEW_Array_array___Array___with_capacity(val_t p0);
typedef val_t (*NEW_Array_array___Array___with_capacity_t)(val_t p0);
static const char * const LOCATE_NEW_Array_array___Array___init = "new Array array::Array::init";
val_t NEW_Array_array___Array___init(void);
typedef val_t (*NEW_Array_array___Array___init_t)(void);
static const char * const LOCATE_NEW_Array_array___Array___filled_with = "new Array array::Array::filled_with";
val_t NEW_Array_array___Array___filled_with(val_t p0, val_t p1);
typedef val_t (*NEW_Array_array___Array___filled_with_t)(val_t p0, val_t p1);
static const char * const LOCATE_NEW_Array_array___Array___with_items = "new Array array::Array::with_items";
val_t NEW_Array_array___Array___with_items(val_t p0);
typedef val_t (*NEW_Array_array___Array___with_items_t)(val_t p0);
static const char * const LOCATE_NEW_Array_array___Array___with_native = "new Array array::Array::with_native";
val_t NEW_Array_array___Array___with_native(val_t p0, val_t p1);
typedef val_t (*NEW_Array_array___Array___with_native_t)(val_t p0, val_t p1);
static const char * const LOCATE_INIT_ATTRIBUTES__ArrayIterator = "init var of ArrayIterator";
void INIT_ATTRIBUTES__ArrayIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__ArrayIterator_t)(val_t p0);
val_t NEW_ArrayIterator(void);
static const char * const LOCATE_CHECKNEW_ArrayIterator = "check new ArrayIterator";
void CHECKNEW_ArrayIterator(val_t p0);
typedef void (*CHECKNEW_ArrayIterator_t)(val_t p0);
static const char * const LOCATE_NEW_ArrayIterator_array___ArrayIterator___init = "new ArrayIterator array::ArrayIterator::init";
val_t NEW_ArrayIterator_array___ArrayIterator___init(val_t p0);
typedef val_t (*NEW_ArrayIterator_array___ArrayIterator___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__ArraySet = "init var of ArraySet";
void INIT_ATTRIBUTES__ArraySet(val_t p0);
typedef void (*INIT_ATTRIBUTES__ArraySet_t)(val_t p0);
val_t NEW_ArraySet(void);
static const char * const LOCATE_CHECKNEW_ArraySet = "check new ArraySet";
void CHECKNEW_ArraySet(val_t p0);
typedef void (*CHECKNEW_ArraySet_t)(val_t p0);
static const char * const LOCATE_NEW_ArraySet_array___ArraySet___init = "new ArraySet array::ArraySet::init";
val_t NEW_ArraySet_array___ArraySet___init(void);
typedef val_t (*NEW_ArraySet_array___ArraySet___init_t)(void);
static const char * const LOCATE_NEW_ArraySet_array___ArraySet___with_capacity = "new ArraySet array::ArraySet::with_capacity";
val_t NEW_ArraySet_array___ArraySet___with_capacity(val_t p0);
typedef val_t (*NEW_ArraySet_array___ArraySet___with_capacity_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__ArraySetIterator = "init var of ArraySetIterator";
void INIT_ATTRIBUTES__ArraySetIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__ArraySetIterator_t)(val_t p0);
val_t NEW_ArraySetIterator(void);
static const char * const LOCATE_CHECKNEW_ArraySetIterator = "check new ArraySetIterator";
void CHECKNEW_ArraySetIterator(val_t p0);
typedef void (*CHECKNEW_ArraySetIterator_t)(val_t p0);
static const char * const LOCATE_NEW_ArraySetIterator_array___ArraySetIterator___init = "new ArraySetIterator array::ArraySetIterator::init";
val_t NEW_ArraySetIterator_array___ArraySetIterator___init(val_t p0);
typedef val_t (*NEW_ArraySetIterator_array___ArraySetIterator___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__ArrayMap = "init var of ArrayMap";
void INIT_ATTRIBUTES__ArrayMap(val_t p0);
typedef void (*INIT_ATTRIBUTES__ArrayMap_t)(val_t p0);
val_t NEW_ArrayMap(void);
static const char * const LOCATE_CHECKNEW_ArrayMap = "check new ArrayMap";
void CHECKNEW_ArrayMap(val_t p0);
typedef void (*CHECKNEW_ArrayMap_t)(val_t p0);
static const char * const LOCATE_NEW_ArrayMap_array___ArrayMap___init = "new ArrayMap array::ArrayMap::init";
val_t NEW_ArrayMap_array___ArrayMap___init(void);
typedef val_t (*NEW_ArrayMap_array___ArrayMap___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__AbstractSorter = "init var of AbstractSorter";
void INIT_ATTRIBUTES__AbstractSorter(val_t p0);
typedef void (*INIT_ATTRIBUTES__AbstractSorter_t)(val_t p0);
val_t NEW_AbstractSorter(void);
static const char * const LOCATE_CHECKNEW_AbstractSorter = "check new AbstractSorter";
void CHECKNEW_AbstractSorter(val_t p0);
typedef void (*CHECKNEW_AbstractSorter_t)(val_t p0);
static const char * const LOCATE_NEW_AbstractSorter_sorter___AbstractSorter___init = "new AbstractSorter sorter::AbstractSorter::init";
val_t NEW_AbstractSorter_sorter___AbstractSorter___init(void);
typedef val_t (*NEW_AbstractSorter_sorter___AbstractSorter___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__ComparableSorter = "init var of ComparableSorter";
void INIT_ATTRIBUTES__ComparableSorter(val_t p0);
typedef void (*INIT_ATTRIBUTES__ComparableSorter_t)(val_t p0);
val_t NEW_ComparableSorter(void);
static const char * const LOCATE_CHECKNEW_ComparableSorter = "check new ComparableSorter";
void CHECKNEW_ComparableSorter(val_t p0);
typedef void (*CHECKNEW_ComparableSorter_t)(val_t p0);
static const char * const LOCATE_NEW_ComparableSorter_sorter___ComparableSorter___init = "new ComparableSorter sorter::ComparableSorter::init";
val_t NEW_ComparableSorter_sorter___ComparableSorter___init(void);
typedef val_t (*NEW_ComparableSorter_sorter___ComparableSorter___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__HashCollection = "init var of HashCollection";
void INIT_ATTRIBUTES__HashCollection(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashCollection_t)(val_t p0);
val_t NEW_HashCollection(void);
static const char * const LOCATE_CHECKNEW_HashCollection = "check new HashCollection";
void CHECKNEW_HashCollection(val_t p0);
typedef void (*CHECKNEW_HashCollection_t)(val_t p0);
static const char * const LOCATE_NEW_HashCollection_hash_collection___HashCollection___init = "new HashCollection hash_collection::HashCollection::init";
val_t NEW_HashCollection_hash_collection___HashCollection___init(void);
typedef val_t (*NEW_HashCollection_hash_collection___HashCollection___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__HashNode = "init var of HashNode";
void INIT_ATTRIBUTES__HashNode(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashNode_t)(val_t p0);
val_t NEW_HashNode(void);
static const char * const LOCATE_CHECKNEW_HashNode = "check new HashNode";
void CHECKNEW_HashNode(val_t p0);
typedef void (*CHECKNEW_HashNode_t)(val_t p0);
static const char * const LOCATE_NEW_HashNode_hash_collection___HashNode___init = "new HashNode hash_collection::HashNode::init";
val_t NEW_HashNode_hash_collection___HashNode___init(val_t p0);
typedef val_t (*NEW_HashNode_hash_collection___HashNode___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__HashMap = "init var of HashMap";
void INIT_ATTRIBUTES__HashMap(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashMap_t)(val_t p0);
val_t NEW_HashMap(void);
static const char * const LOCATE_CHECKNEW_HashMap = "check new HashMap";
void CHECKNEW_HashMap(val_t p0);
typedef void (*CHECKNEW_HashMap_t)(val_t p0);
static const char * const LOCATE_NEW_HashMap_hash_collection___HashMap___init = "new HashMap hash_collection::HashMap::init";
val_t NEW_HashMap_hash_collection___HashMap___init(void);
typedef val_t (*NEW_HashMap_hash_collection___HashMap___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__HashMapNode = "init var of HashMapNode";
void INIT_ATTRIBUTES__HashMapNode(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashMapNode_t)(val_t p0);
val_t NEW_HashMapNode(void);
static const char * const LOCATE_CHECKNEW_HashMapNode = "check new HashMapNode";
void CHECKNEW_HashMapNode(val_t p0);
typedef void (*CHECKNEW_HashMapNode_t)(val_t p0);
static const char * const LOCATE_NEW_HashMapNode_hash_collection___HashMapNode___init = "new HashMapNode hash_collection::HashMapNode::init";
val_t NEW_HashMapNode_hash_collection___HashMapNode___init(val_t p0, val_t p1);
typedef val_t (*NEW_HashMapNode_hash_collection___HashMapNode___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_INIT_ATTRIBUTES__HashMapIterator = "init var of HashMapIterator";
void INIT_ATTRIBUTES__HashMapIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashMapIterator_t)(val_t p0);
val_t NEW_HashMapIterator(void);
static const char * const LOCATE_CHECKNEW_HashMapIterator = "check new HashMapIterator";
void CHECKNEW_HashMapIterator(val_t p0);
typedef void (*CHECKNEW_HashMapIterator_t)(val_t p0);
static const char * const LOCATE_NEW_HashMapIterator_hash_collection___HashMapIterator___init = "new HashMapIterator hash_collection::HashMapIterator::init";
val_t NEW_HashMapIterator_hash_collection___HashMapIterator___init(val_t p0);
typedef val_t (*NEW_HashMapIterator_hash_collection___HashMapIterator___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__HashSet = "init var of HashSet";
void INIT_ATTRIBUTES__HashSet(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashSet_t)(val_t p0);
val_t NEW_HashSet(void);
static const char * const LOCATE_CHECKNEW_HashSet = "check new HashSet";
void CHECKNEW_HashSet(val_t p0);
typedef void (*CHECKNEW_HashSet_t)(val_t p0);
static const char * const LOCATE_NEW_HashSet_hash_collection___HashSet___init = "new HashSet hash_collection::HashSet::init";
val_t NEW_HashSet_hash_collection___HashSet___init(void);
typedef val_t (*NEW_HashSet_hash_collection___HashSet___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__HashSetNode = "init var of HashSetNode";
void INIT_ATTRIBUTES__HashSetNode(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashSetNode_t)(val_t p0);
val_t NEW_HashSetNode(void);
static const char * const LOCATE_CHECKNEW_HashSetNode = "check new HashSetNode";
void CHECKNEW_HashSetNode(val_t p0);
typedef void (*CHECKNEW_HashSetNode_t)(val_t p0);
static const char * const LOCATE_NEW_HashSetNode_hash_collection___HashSetNode___init = "new HashSetNode hash_collection::HashSetNode::init";
val_t NEW_HashSetNode_hash_collection___HashSetNode___init(val_t p0);
typedef val_t (*NEW_HashSetNode_hash_collection___HashSetNode___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__HashSetIterator = "init var of HashSetIterator";
void INIT_ATTRIBUTES__HashSetIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__HashSetIterator_t)(val_t p0);
val_t NEW_HashSetIterator(void);
static const char * const LOCATE_CHECKNEW_HashSetIterator = "check new HashSetIterator";
void CHECKNEW_HashSetIterator(val_t p0);
typedef void (*CHECKNEW_HashSetIterator_t)(val_t p0);
static const char * const LOCATE_NEW_HashSetIterator_hash_collection___HashSetIterator___init = "new HashSetIterator hash_collection::HashSetIterator::init";
val_t NEW_HashSetIterator_hash_collection___HashSetIterator___init(val_t p0);
typedef val_t (*NEW_HashSetIterator_hash_collection___HashSetIterator___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__String = "init var of String";
void INIT_ATTRIBUTES__String(val_t p0);
typedef void (*INIT_ATTRIBUTES__String_t)(val_t p0);
val_t NEW_String(void);
static const char * const LOCATE_CHECKNEW_String = "check new String";
void CHECKNEW_String(val_t p0);
typedef void (*CHECKNEW_String_t)(val_t p0);
static const char * const LOCATE_NEW_String_string___String___with_native = "new String string::String::with_native";
val_t NEW_String_string___String___with_native(val_t p0, val_t p1);
typedef val_t (*NEW_String_string___String___with_native_t)(val_t p0, val_t p1);
static const char * const LOCATE_NEW_String_string___String___from_cstring = "new String string::String::from_cstring";
val_t NEW_String_string___String___from_cstring(val_t p0);
typedef val_t (*NEW_String_string___String___from_cstring_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Buffer = "init var of Buffer";
void INIT_ATTRIBUTES__Buffer(val_t p0);
typedef void (*INIT_ATTRIBUTES__Buffer_t)(val_t p0);
val_t NEW_Buffer(void);
static const char * const LOCATE_CHECKNEW_Buffer = "check new Buffer";
void CHECKNEW_Buffer(val_t p0);
typedef void (*CHECKNEW_Buffer_t)(val_t p0);
static const char * const LOCATE_NEW_Buffer_string___Buffer___init = "new Buffer string::Buffer::init";
val_t NEW_Buffer_string___Buffer___init(void);
typedef val_t (*NEW_Buffer_string___Buffer___init_t)(void);
static const char * const LOCATE_NEW_Buffer_string___Buffer___from = "new Buffer string::Buffer::from";
val_t NEW_Buffer_string___Buffer___from(val_t p0);
typedef val_t (*NEW_Buffer_string___Buffer___from_t)(val_t p0);
static const char * const LOCATE_NEW_Buffer_string___Buffer___with_capacity = "new Buffer string::Buffer::with_capacity";
val_t NEW_Buffer_string___Buffer___with_capacity(val_t p0);
typedef val_t (*NEW_Buffer_string___Buffer___with_capacity_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__StringCapable = "init var of StringCapable";
void INIT_ATTRIBUTES__StringCapable(val_t p0);
typedef void (*INIT_ATTRIBUTES__StringCapable_t)(val_t p0);
val_t NEW_StringCapable(void);
static const char * const LOCATE_CHECKNEW_StringCapable = "check new StringCapable";
void CHECKNEW_StringCapable(val_t p0);
typedef void (*CHECKNEW_StringCapable_t)(val_t p0);
static const char * const LOCATE_NEW_StringCapable_string___StringCapable___init = "new StringCapable string::StringCapable::init";
val_t NEW_StringCapable_string___StringCapable___init(void);
typedef val_t (*NEW_StringCapable_string___StringCapable___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__Symbol = "init var of Symbol";
void INIT_ATTRIBUTES__Symbol(val_t p0);
typedef void (*INIT_ATTRIBUTES__Symbol_t)(val_t p0);
val_t NEW_Symbol(void);
static const char * const LOCATE_CHECKNEW_Symbol = "check new Symbol";
void CHECKNEW_Symbol(val_t p0);
typedef void (*CHECKNEW_Symbol_t)(val_t p0);
static const char * const LOCATE_NEW_Symbol_symbol___Symbol___init = "new Symbol symbol::Symbol::init";
val_t NEW_Symbol_symbol___Symbol___init(val_t p0);
typedef val_t (*NEW_Symbol_symbol___Symbol___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__IOS = "init var of IOS";
void INIT_ATTRIBUTES__IOS(val_t p0);
typedef void (*INIT_ATTRIBUTES__IOS_t)(val_t p0);
val_t NEW_IOS(void);
static const char * const LOCATE_CHECKNEW_IOS = "check new IOS";
void CHECKNEW_IOS(val_t p0);
typedef void (*CHECKNEW_IOS_t)(val_t p0);
static const char * const LOCATE_NEW_IOS_stream___IOS___init = "new IOS stream::IOS::init";
val_t NEW_IOS_stream___IOS___init(void);
typedef val_t (*NEW_IOS_stream___IOS___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__IStream = "init var of IStream";
void INIT_ATTRIBUTES__IStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__IStream_t)(val_t p0);
val_t NEW_IStream(void);
static const char * const LOCATE_CHECKNEW_IStream = "check new IStream";
void CHECKNEW_IStream(val_t p0);
typedef void (*CHECKNEW_IStream_t)(val_t p0);
static const char * const LOCATE_NEW_IStream_stream___IOS___init = "new IStream stream::IOS::init";
val_t NEW_IStream_stream___IOS___init(void);
typedef val_t (*NEW_IStream_stream___IOS___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__OStream = "init var of OStream";
void INIT_ATTRIBUTES__OStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__OStream_t)(val_t p0);
val_t NEW_OStream(void);
static const char * const LOCATE_CHECKNEW_OStream = "check new OStream";
void CHECKNEW_OStream(val_t p0);
typedef void (*CHECKNEW_OStream_t)(val_t p0);
static const char * const LOCATE_NEW_OStream_stream___IOS___init = "new OStream stream::IOS::init";
val_t NEW_OStream_stream___IOS___init(void);
typedef val_t (*NEW_OStream_stream___IOS___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__BufferedIStream = "init var of BufferedIStream";
void INIT_ATTRIBUTES__BufferedIStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__BufferedIStream_t)(val_t p0);
val_t NEW_BufferedIStream(void);
static const char * const LOCATE_CHECKNEW_BufferedIStream = "check new BufferedIStream";
void CHECKNEW_BufferedIStream(val_t p0);
typedef void (*CHECKNEW_BufferedIStream_t)(val_t p0);
static const char * const LOCATE_NEW_BufferedIStream_stream___IOS___init = "new BufferedIStream stream::IOS::init";
val_t NEW_BufferedIStream_stream___IOS___init(void);
typedef val_t (*NEW_BufferedIStream_stream___IOS___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__IOStream = "init var of IOStream";
void INIT_ATTRIBUTES__IOStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__IOStream_t)(val_t p0);
val_t NEW_IOStream(void);
static const char * const LOCATE_CHECKNEW_IOStream = "check new IOStream";
void CHECKNEW_IOStream(val_t p0);
typedef void (*CHECKNEW_IOStream_t)(val_t p0);
static const char * const LOCATE_NEW_IOStream_stream___IOS___init = "new IOStream stream::IOS::init";
val_t NEW_IOStream_stream___IOS___init(void);
typedef val_t (*NEW_IOStream_stream___IOS___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__FDStream = "init var of FDStream";
void INIT_ATTRIBUTES__FDStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__FDStream_t)(val_t p0);
val_t NEW_FDStream(void);
static const char * const LOCATE_CHECKNEW_FDStream = "check new FDStream";
void CHECKNEW_FDStream(val_t p0);
typedef void (*CHECKNEW_FDStream_t)(val_t p0);
static const char * const LOCATE_NEW_FDStream_stream___FDStream___init = "new FDStream stream::FDStream::init";
val_t NEW_FDStream_stream___FDStream___init(val_t p0);
typedef val_t (*NEW_FDStream_stream___FDStream___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__FDIStream = "init var of FDIStream";
void INIT_ATTRIBUTES__FDIStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__FDIStream_t)(val_t p0);
val_t NEW_FDIStream(void);
static const char * const LOCATE_CHECKNEW_FDIStream = "check new FDIStream";
void CHECKNEW_FDIStream(val_t p0);
typedef void (*CHECKNEW_FDIStream_t)(val_t p0);
static const char * const LOCATE_NEW_FDIStream_stream___FDIStream___init = "new FDIStream stream::FDIStream::init";
val_t NEW_FDIStream_stream___FDIStream___init(val_t p0);
typedef val_t (*NEW_FDIStream_stream___FDIStream___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__FDOStream = "init var of FDOStream";
void INIT_ATTRIBUTES__FDOStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__FDOStream_t)(val_t p0);
val_t NEW_FDOStream(void);
static const char * const LOCATE_CHECKNEW_FDOStream = "check new FDOStream";
void CHECKNEW_FDOStream(val_t p0);
typedef void (*CHECKNEW_FDOStream_t)(val_t p0);
static const char * const LOCATE_NEW_FDOStream_stream___FDOStream___init = "new FDOStream stream::FDOStream::init";
val_t NEW_FDOStream_stream___FDOStream___init(val_t p0);
typedef val_t (*NEW_FDOStream_stream___FDOStream___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__FDIOStream = "init var of FDIOStream";
void INIT_ATTRIBUTES__FDIOStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__FDIOStream_t)(val_t p0);
val_t NEW_FDIOStream(void);
static const char * const LOCATE_CHECKNEW_FDIOStream = "check new FDIOStream";
void CHECKNEW_FDIOStream(val_t p0);
typedef void (*CHECKNEW_FDIOStream_t)(val_t p0);
static const char * const LOCATE_NEW_FDIOStream_stream___FDIOStream___init = "new FDIOStream stream::FDIOStream::init";
val_t NEW_FDIOStream_stream___FDIOStream___init(val_t p0);
typedef val_t (*NEW_FDIOStream_stream___FDIOStream___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Pattern = "init var of Pattern";
void INIT_ATTRIBUTES__Pattern(val_t p0);
typedef void (*INIT_ATTRIBUTES__Pattern_t)(val_t p0);
val_t NEW_Pattern(void);
static const char * const LOCATE_CHECKNEW_Pattern = "check new Pattern";
void CHECKNEW_Pattern(val_t p0);
typedef void (*CHECKNEW_Pattern_t)(val_t p0);
static const char * const LOCATE_NEW_Pattern_string_search___Pattern___init = "new Pattern string_search::Pattern::init";
val_t NEW_Pattern_string_search___Pattern___init(void);
typedef val_t (*NEW_Pattern_string_search___Pattern___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__BM_Pattern = "init var of BM_Pattern";
void INIT_ATTRIBUTES__BM_Pattern(val_t p0);
typedef void (*INIT_ATTRIBUTES__BM_Pattern_t)(val_t p0);
val_t NEW_BM_Pattern(void);
static const char * const LOCATE_CHECKNEW_BM_Pattern = "check new BM_Pattern";
void CHECKNEW_BM_Pattern(val_t p0);
typedef void (*CHECKNEW_BM_Pattern_t)(val_t p0);
static const char * const LOCATE_NEW_BM_Pattern_string_search___BM_Pattern___init = "new BM_Pattern string_search::BM_Pattern::init";
val_t NEW_BM_Pattern_string_search___BM_Pattern___init(val_t p0);
typedef val_t (*NEW_BM_Pattern_string_search___BM_Pattern___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Match = "init var of Match";
void INIT_ATTRIBUTES__Match(val_t p0);
typedef void (*INIT_ATTRIBUTES__Match_t)(val_t p0);
val_t NEW_Match(void);
static const char * const LOCATE_CHECKNEW_Match = "check new Match";
void CHECKNEW_Match(val_t p0);
typedef void (*CHECKNEW_Match_t)(val_t p0);
static const char * const LOCATE_NEW_Match_string_search___Match___init = "new Match string_search::Match::init";
val_t NEW_Match_string_search___Match___init(val_t p0, val_t p1, val_t p2);
typedef val_t (*NEW_Match_string_search___Match___init_t)(val_t p0, val_t p1, val_t p2);
static const char * const LOCATE_INIT_ATTRIBUTES__FStream = "init var of FStream";
void INIT_ATTRIBUTES__FStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__FStream_t)(val_t p0);
val_t NEW_FStream(void);
static const char * const LOCATE_CHECKNEW_FStream = "check new FStream";
void CHECKNEW_FStream(val_t p0);
typedef void (*CHECKNEW_FStream_t)(val_t p0);
static const char * const LOCATE_NEW_FStream_stream___IOS___init = "new FStream stream::IOS::init";
val_t NEW_FStream_stream___IOS___init(void);
typedef val_t (*NEW_FStream_stream___IOS___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__IFStream = "init var of IFStream";
void INIT_ATTRIBUTES__IFStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__IFStream_t)(val_t p0);
val_t NEW_IFStream(void);
static const char * const LOCATE_CHECKNEW_IFStream = "check new IFStream";
void CHECKNEW_IFStream(val_t p0);
typedef void (*CHECKNEW_IFStream_t)(val_t p0);
static const char * const LOCATE_NEW_IFStream_file___IFStream___open = "new IFStream file::IFStream::open";
val_t NEW_IFStream_file___IFStream___open(val_t p0);
typedef val_t (*NEW_IFStream_file___IFStream___open_t)(val_t p0);
static const char * const LOCATE_NEW_IFStream_file___IFStream___init = "new IFStream file::IFStream::init";
val_t NEW_IFStream_file___IFStream___init(void);
typedef val_t (*NEW_IFStream_file___IFStream___init_t)(void);
static const char * const LOCATE_NEW_IFStream_file___IFStream___without_file = "new IFStream file::IFStream::without_file";
val_t NEW_IFStream_file___IFStream___without_file(void);
typedef val_t (*NEW_IFStream_file___IFStream___without_file_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__OFStream = "init var of OFStream";
void INIT_ATTRIBUTES__OFStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__OFStream_t)(val_t p0);
val_t NEW_OFStream(void);
static const char * const LOCATE_CHECKNEW_OFStream = "check new OFStream";
void CHECKNEW_OFStream(val_t p0);
typedef void (*CHECKNEW_OFStream_t)(val_t p0);
static const char * const LOCATE_NEW_OFStream_file___OFStream___open = "new OFStream file::OFStream::open";
val_t NEW_OFStream_file___OFStream___open(val_t p0);
typedef val_t (*NEW_OFStream_file___OFStream___open_t)(val_t p0);
static const char * const LOCATE_NEW_OFStream_file___OFStream___init = "new OFStream file::OFStream::init";
val_t NEW_OFStream_file___OFStream___init(void);
typedef val_t (*NEW_OFStream_file___OFStream___init_t)(void);
static const char * const LOCATE_NEW_OFStream_file___OFStream___without_file = "new OFStream file::OFStream::without_file";
val_t NEW_OFStream_file___OFStream___without_file(void);
typedef val_t (*NEW_OFStream_file___OFStream___without_file_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__Stdin = "init var of Stdin";
void INIT_ATTRIBUTES__Stdin(val_t p0);
typedef void (*INIT_ATTRIBUTES__Stdin_t)(val_t p0);
val_t NEW_Stdin(void);
static const char * const LOCATE_CHECKNEW_Stdin = "check new Stdin";
void CHECKNEW_Stdin(val_t p0);
typedef void (*CHECKNEW_Stdin_t)(val_t p0);
static const char * const LOCATE_NEW_Stdin_file___Stdin___init = "new Stdin file::Stdin::init";
val_t NEW_Stdin_file___Stdin___init(void);
typedef val_t (*NEW_Stdin_file___Stdin___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__Stdout = "init var of Stdout";
void INIT_ATTRIBUTES__Stdout(val_t p0);
typedef void (*INIT_ATTRIBUTES__Stdout_t)(val_t p0);
val_t NEW_Stdout(void);
static const char * const LOCATE_CHECKNEW_Stdout = "check new Stdout";
void CHECKNEW_Stdout(val_t p0);
typedef void (*CHECKNEW_Stdout_t)(val_t p0);
static const char * const LOCATE_NEW_Stdout_file___Stdout___init = "new Stdout file::Stdout::init";
val_t NEW_Stdout_file___Stdout___init(void);
typedef val_t (*NEW_Stdout_file___Stdout___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__Stderr = "init var of Stderr";
void INIT_ATTRIBUTES__Stderr(val_t p0);
typedef void (*INIT_ATTRIBUTES__Stderr_t)(val_t p0);
val_t NEW_Stderr(void);
static const char * const LOCATE_CHECKNEW_Stderr = "check new Stderr";
void CHECKNEW_Stderr(val_t p0);
typedef void (*CHECKNEW_Stderr_t)(val_t p0);
static const char * const LOCATE_NEW_Stderr_file___Stderr___init = "new Stderr file::Stderr::init";
val_t NEW_Stderr_file___Stderr___init(void);
typedef val_t (*NEW_Stderr_file___Stderr___init_t)(void);
static const char * const LOCATE_INIT_ATTRIBUTES__Process = "init var of Process";
void INIT_ATTRIBUTES__Process(val_t p0);
typedef void (*INIT_ATTRIBUTES__Process_t)(val_t p0);
val_t NEW_Process(void);
static const char * const LOCATE_CHECKNEW_Process = "check new Process";
void CHECKNEW_Process(val_t p0);
typedef void (*CHECKNEW_Process_t)(val_t p0);
static const char * const LOCATE_NEW_Process_exec___Process___init = "new Process exec::Process::init";
val_t NEW_Process_exec___Process___init(val_t p0, val_t p1);
typedef val_t (*NEW_Process_exec___Process___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_NEW_Process_exec___Process___init_ = "new Process exec::Process::init_";
val_t NEW_Process_exec___Process___init_(val_t p0);
typedef val_t (*NEW_Process_exec___Process___init__t)(val_t p0);
static const char * const LOCATE_NEW_Process_exec___Process___execute = "new Process exec::Process::execute";
val_t NEW_Process_exec___Process___execute(val_t p0, val_t p1, val_t p2);
typedef val_t (*NEW_Process_exec___Process___execute_t)(val_t p0, val_t p1, val_t p2);
static const char * const LOCATE_INIT_ATTRIBUTES__IProcess = "init var of IProcess";
void INIT_ATTRIBUTES__IProcess(val_t p0);
typedef void (*INIT_ATTRIBUTES__IProcess_t)(val_t p0);
val_t NEW_IProcess(void);
static const char * const LOCATE_CHECKNEW_IProcess = "check new IProcess";
void CHECKNEW_IProcess(val_t p0);
typedef void (*CHECKNEW_IProcess_t)(val_t p0);
static const char * const LOCATE_NEW_IProcess_exec___IProcess___init = "new IProcess exec::IProcess::init";
val_t NEW_IProcess_exec___IProcess___init(val_t p0, val_t p1);
typedef val_t (*NEW_IProcess_exec___IProcess___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_NEW_IProcess_exec___IProcess___init_ = "new IProcess exec::IProcess::init_";
val_t NEW_IProcess_exec___IProcess___init_(val_t p0);
typedef val_t (*NEW_IProcess_exec___IProcess___init__t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__OProcess = "init var of OProcess";
void INIT_ATTRIBUTES__OProcess(val_t p0);
typedef void (*INIT_ATTRIBUTES__OProcess_t)(val_t p0);
val_t NEW_OProcess(void);
static const char * const LOCATE_CHECKNEW_OProcess = "check new OProcess";
void CHECKNEW_OProcess(val_t p0);
typedef void (*CHECKNEW_OProcess_t)(val_t p0);
static const char * const LOCATE_NEW_OProcess_exec___OProcess___init = "new OProcess exec::OProcess::init";
val_t NEW_OProcess_exec___OProcess___init(val_t p0, val_t p1);
typedef val_t (*NEW_OProcess_exec___OProcess___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_NEW_OProcess_exec___OProcess___init_ = "new OProcess exec::OProcess::init_";
val_t NEW_OProcess_exec___OProcess___init_(val_t p0);
typedef val_t (*NEW_OProcess_exec___OProcess___init__t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__IOProcess = "init var of IOProcess";
void INIT_ATTRIBUTES__IOProcess(val_t p0);
typedef void (*INIT_ATTRIBUTES__IOProcess_t)(val_t p0);
val_t NEW_IOProcess(void);
static const char * const LOCATE_CHECKNEW_IOProcess = "check new IOProcess";
void CHECKNEW_IOProcess(val_t p0);
typedef void (*CHECKNEW_IOProcess_t)(val_t p0);
static const char * const LOCATE_NEW_IOProcess_exec___IOProcess___init = "new IOProcess exec::IOProcess::init";
val_t NEW_IOProcess_exec___IOProcess___init(val_t p0, val_t p1);
typedef val_t (*NEW_IOProcess_exec___IOProcess___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_NEW_IOProcess_exec___IOProcess___init_ = "new IOProcess exec::IOProcess::init_";
val_t NEW_IOProcess_exec___IOProcess___init_(val_t p0);
typedef val_t (*NEW_IOProcess_exec___IOProcess___init__t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Point = "init var of Point";
void INIT_ATTRIBUTES__Point(val_t p0);
typedef void (*INIT_ATTRIBUTES__Point_t)(val_t p0);
val_t NEW_Point(void);
static const char * const LOCATE_CHECKNEW_Point = "check new Point";
void CHECKNEW_Point(val_t p0);
typedef void (*CHECKNEW_Point_t)(val_t p0);
static const char * const LOCATE_NEW_Point_figure___Point___init = "new Point figure::Point::init";
val_t NEW_Point_figure___Point___init(val_t p0, val_t p1);
typedef val_t (*NEW_Point_figure___Point___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_INIT_ATTRIBUTES__Segment = "init var of Segment";
void INIT_ATTRIBUTES__Segment(val_t p0);
typedef void (*INIT_ATTRIBUTES__Segment_t)(val_t p0);
val_t NEW_Segment(void);
static const char * const LOCATE_CHECKNEW_Segment = "check new Segment";
void CHECKNEW_Segment(val_t p0);
typedef void (*CHECKNEW_Segment_t)(val_t p0);
static const char * const LOCATE_NEW_Segment_figure___Segment___init = "new Segment figure::Segment::init";
val_t NEW_Segment_figure___Segment___init(val_t p0);
typedef val_t (*NEW_Segment_figure___Segment___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Cercle = "init var of Cercle";
void INIT_ATTRIBUTES__Cercle(val_t p0);
typedef void (*INIT_ATTRIBUTES__Cercle_t)(val_t p0);
val_t NEW_Cercle(void);
static const char * const LOCATE_CHECKNEW_Cercle = "check new Cercle";
void CHECKNEW_Cercle(val_t p0);
typedef void (*CHECKNEW_Cercle_t)(val_t p0);
static const char * const LOCATE_NEW_Cercle_figure___Cercle___init = "new Cercle figure::Cercle::init";
val_t NEW_Cercle_figure___Cercle___init(val_t p0, val_t p1);
typedef val_t (*NEW_Cercle_figure___Cercle___init_t)(val_t p0, val_t p1);
static const char * const LOCATE_INIT_ATTRIBUTES__Polygone = "init var of Polygone";
void INIT_ATTRIBUTES__Polygone(val_t p0);
typedef void (*INIT_ATTRIBUTES__Polygone_t)(val_t p0);
val_t NEW_Polygone(void);
static const char * const LOCATE_CHECKNEW_Polygone = "check new Polygone";
void CHECKNEW_Polygone(val_t p0);
typedef void (*CHECKNEW_Polygone_t)(val_t p0);
static const char * const LOCATE_NEW_Polygone_polygone___Polygone___init = "new Polygone polygone::Polygone::init";
val_t NEW_Polygone_polygone___Polygone___init(val_t p0);
typedef val_t (*NEW_Polygone_polygone___Polygone___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Triangle = "init var of Triangle";
void INIT_ATTRIBUTES__Triangle(val_t p0);
typedef void (*INIT_ATTRIBUTES__Triangle_t)(val_t p0);
val_t NEW_Triangle(void);
static const char * const LOCATE_CHECKNEW_Triangle = "check new Triangle";
void CHECKNEW_Triangle(val_t p0);
typedef void (*CHECKNEW_Triangle_t)(val_t p0);
static const char * const LOCATE_NEW_Triangle_polygone___Triangle___init = "new Triangle polygone::Triangle::init";
val_t NEW_Triangle_polygone___Triangle___init(val_t p0);
typedef val_t (*NEW_Triangle_polygone___Triangle___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Quadrilatere = "init var of Quadrilatere";
void INIT_ATTRIBUTES__Quadrilatere(val_t p0);
typedef void (*INIT_ATTRIBUTES__Quadrilatere_t)(val_t p0);
val_t NEW_Quadrilatere(void);
static const char * const LOCATE_CHECKNEW_Quadrilatere = "check new Quadrilatere";
void CHECKNEW_Quadrilatere(val_t p0);
typedef void (*CHECKNEW_Quadrilatere_t)(val_t p0);
static const char * const LOCATE_NEW_Quadrilatere_polygone___Quadrilatere___init = "new Quadrilatere polygone::Quadrilatere::init";
val_t NEW_Quadrilatere_polygone___Quadrilatere___init(val_t p0);
typedef val_t (*NEW_Quadrilatere_polygone___Quadrilatere___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Parallelogramme = "init var of Parallelogramme";
void INIT_ATTRIBUTES__Parallelogramme(val_t p0);
typedef void (*INIT_ATTRIBUTES__Parallelogramme_t)(val_t p0);
val_t NEW_Parallelogramme(void);
static const char * const LOCATE_CHECKNEW_Parallelogramme = "check new Parallelogramme";
void CHECKNEW_Parallelogramme(val_t p0);
typedef void (*CHECKNEW_Parallelogramme_t)(val_t p0);
static const char * const LOCATE_NEW_Parallelogramme_polygone___Parallelogramme___init = "new Parallelogramme polygone::Parallelogramme::init";
val_t NEW_Parallelogramme_polygone___Parallelogramme___init(val_t p0);
typedef val_t (*NEW_Parallelogramme_polygone___Parallelogramme___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Losange = "init var of Losange";
void INIT_ATTRIBUTES__Losange(val_t p0);
typedef void (*INIT_ATTRIBUTES__Losange_t)(val_t p0);
val_t NEW_Losange(void);
static const char * const LOCATE_CHECKNEW_Losange = "check new Losange";
void CHECKNEW_Losange(val_t p0);
typedef void (*CHECKNEW_Losange_t)(val_t p0);
static const char * const LOCATE_NEW_Losange_polygone___Losange___init = "new Losange polygone::Losange::init";
val_t NEW_Losange_polygone___Losange___init(val_t p0);
typedef val_t (*NEW_Losange_polygone___Losange___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Rectangle = "init var of Rectangle";
void INIT_ATTRIBUTES__Rectangle(val_t p0);
typedef void (*INIT_ATTRIBUTES__Rectangle_t)(val_t p0);
val_t NEW_Rectangle(void);
static const char * const LOCATE_CHECKNEW_Rectangle = "check new Rectangle";
void CHECKNEW_Rectangle(val_t p0);
typedef void (*CHECKNEW_Rectangle_t)(val_t p0);
static const char * const LOCATE_NEW_Rectangle_polygone___Rectangle___init = "new Rectangle polygone::Rectangle::init";
val_t NEW_Rectangle_polygone___Rectangle___init(val_t p0);
typedef val_t (*NEW_Rectangle_polygone___Rectangle___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Carre = "init var of Carre";
void INIT_ATTRIBUTES__Carre(val_t p0);
typedef void (*INIT_ATTRIBUTES__Carre_t)(val_t p0);
val_t NEW_Carre(void);
static const char * const LOCATE_CHECKNEW_Carre = "check new Carre";
void CHECKNEW_Carre(val_t p0);
typedef void (*CHECKNEW_Carre_t)(val_t p0);
static const char * const LOCATE_NEW_Carre_polygone___Carre___init = "new Carre polygone::Carre::init";
val_t NEW_Carre_polygone___Carre___init(val_t p0);
typedef val_t (*NEW_Carre_polygone___Carre___init_t)(val_t p0);
static const char * const LOCATE_INIT_ATTRIBUTES__Fabrique = "init var of Fabrique";
void INIT_ATTRIBUTES__Fabrique(val_t p0);
typedef void (*INIT_ATTRIBUTES__Fabrique_t)(val_t p0);
val_t NEW_Fabrique(void);
static const char * const LOCATE_CHECKNEW_Fabrique = "check new Fabrique";
void CHECKNEW_Fabrique(val_t p0);
typedef void (*CHECKNEW_Fabrique_t)(val_t p0);
static const char * const LOCATE_NEW_Fabrique_factory___Fabrique___init = "new Fabrique factory::Fabrique::init";
val_t NEW_Fabrique_factory___Fabrique___init(void);
typedef val_t (*NEW_Fabrique_factory___Fabrique___init_t)(void);
const char *LOCATE_factory = "./factory.nit";
const int SFT_factory[3] = {
  55 /* Id of Fabrique */,
  3 /* Color of Fabrique */,
  42 /* Group of ? */,
};
const char *LOCATE_polygone = "./polygone.nit";
const int SFT_polygone[22] = {
  91 /* Id of Polygone */,
  4 /* Color of Polygone */,
  2 /* Group of ? */,
  45 /* Group of ? */,
  175 /* Id of Triangle */,
  5 /* Color of Triangle */,
  49 /* Group of ? */,
  187 /* Id of Quadrilatere */,
  5 /* Color of Quadrilatere */,
  49 /* Group of ? */,
  255 /* Id of Parallelogramme */,
  6 /* Color of Parallelogramme */,
  54 /* Group of ? */,
  299 /* Id of Losange */,
  8 /* Color of Losange */,
  64 /* Group of ? */,
  295 /* Id of Rectangle */,
  7 /* Color of Rectangle */,
  58 /* Group of ? */,
  331 /* Id of Carre */,
  9 /* Color of Carre */,
  70 /* Group of ? */,
};
const char *LOCATE_figure = "./figure.nit";
const int SFT_figure[15] = {
  51 /* Id of Figure */,
  3 /* Color of Figure */,
  42 /* Group of ? */,
  95 /* Id of Point */,
  4 /* Color of Point */,
  2 /* Group of ? */,
  45 /* Group of ? */,
  79 /* Id of Segment */,
  4 /* Color of Segment */,
  2 /* Group of ? */,
  45 /* Group of ? */,
  163 /* Id of Cercle */,
  4 /* Color of Cercle */,
  2 /* Group of ? */,
  45 /* Group of ? */,
};
const char *LOCATE_utils = "./utils.nit";
const int SFT_utils[1] = {
  42 /* Group of ? */,
};
const char *LOCATE_standard = "/Users/tony/Projects/nit/lib/standard//standard.nit";
const char *LOCATE_environ = "/Users/tony/Projects/nit/lib/standard//environ.nit";
const int SFT_environ[2] = {
  42 /* Group of ? */,
  42 /* Group of ? */,
};
const char *LOCATE_symbol = "/Users/tony/Projects/nit/lib/standard//symbol.nit";
const int SFT_symbol[5] = {
  113 /* Group of ? */,
  11 /* Id of Symbol */,
  3 /* Color of Symbol */,
  2 /* Group of ? */,
  43 /* Group of ? */,
};
const char *LOCATE_string = "/Users/tony/Projects/nit/lib/standard//string.nit";
const int SFT_string[24] = {
  319 /* Id of AbstractString */,
  13 /* Color of AbstractString */,
  3 /* Group of ? */,
  101 /* Group of ? */,
  327 /* Id of String */,
  6 /* Color of String */,
  114 /* Group of ? */,
  335 /* Id of Buffer */,
  15 /* Color of Buffer */,
  4 /* Group of ? */,
  113 /* Group of ? */,
  33 /* Group of ? */,
  63 /* Group of ? */,
  43 /* Group of ? */,
  57 /* Group of ? */,
  81 /* Group of ? */,
  -5 /* Id of NativeString */,
  3 /* Color of NativeString */,
  43 /* Group of ? */,
  15 /* Id of StringCapable */,
  3 /* Color of StringCapable */,
  42 /* Group of ? */,
  2 /* Group of ? */,
  43 /* Group of ? */,
};
const char *LOCATE_collection = "/Users/tony/Projects/nit/lib/standard//collection//collection.nit";
const char *LOCATE_range = "/Users/tony/Projects/nit/lib/standard//collection//range.nit";
const int SFT_range[8] = {
  87 /* Id of Range */,
  6 /* Color of Range */,
  2 /* Group of ? */,
  68 /* Group of ? */,
  115 /* Id of IteratorRange */,
  4 /* Color of IteratorRange */,
  2 /* Group of ? */,
  47 /* Group of ? */,
};
const char *LOCATE_abstract_collection = "/Users/tony/Projects/nit/lib/standard//collection//abstract_collection.nit";
const int SFT_abstract_collection[55] = {
  67 /* Id of Collection */,
  5 /* Color of Collection */,
  59 /* Group of ? */,
  103 /* Id of NaiveCollection */,
  6 /* Color of NaiveCollection */,
  68 /* Group of ? */,
  39 /* Id of Iterator */,
  3 /* Color of Iterator */,
  43 /* Group of ? */,
  155 /* Id of Container */,
  6 /* Color of Container */,
  2 /* Group of ? */,
  68 /* Group of ? */,
  151 /* Id of ContainerIterator */,
  4 /* Color of ContainerIterator */,
  2 /* Group of ? */,
  47 /* Group of ? */,
  83 /* Id of RemovableCollection */,
  6 /* Color of RemovableCollection */,
  68 /* Group of ? */,
  179 /* Id of SimpleCollection */,
  8 /* Color of SimpleCollection */,
  75 /* Group of ? */,
  247 /* Id of Set */,
  7 /* Color of Set */,
  54 /* Group of ? */,
  107 /* Id of MapRead */,
  7 /* Color of MapRead */,
  72 /* Group of ? */,
  199 /* Id of Map */,
  10 /* Color of Map */,
  82 /* Group of ? */,
  111 /* Id of MapIterator */,
  4 /* Color of MapIterator */,
  47 /* Group of ? */,
  183 /* Id of SequenceRead */,
  9 /* Color of SequenceRead */,
  78 /* Group of ? */,
  251 /* Id of Sequence */,
  11 /* Color of Sequence */,
  86 /* Group of ? */,
  207 /* Id of IndexedIterator */,
  5 /* Color of IndexedIterator */,
  49 /* Group of ? */,
  279 /* Id of CoupleMap */,
  11 /* Color of CoupleMap */,
  86 /* Group of ? */,
  231 /* Id of CoupleMapIterator */,
  5 /* Color of CoupleMapIterator */,
  2 /* Group of ? */,
  49 /* Group of ? */,
  59 /* Id of Couple */,
  3 /* Color of Couple */,
  2 /* Group of ? */,
  42 /* Group of ? */,
};
const char *LOCATE_kernel = "/Users/tony/Projects/nit/lib/standard//kernel.nit";
const int SFT_kernel[27] = {
  3 /* Id of Object */,
  2 /* Color of Object */,
  18 /* Group of ? */,
  7 /* Id of Sys */,
  3 /* Color of Sys */,
  47 /* Group of ? */,
  63 /* Id of Comparable */,
  4 /* Color of Comparable */,
  48 /* Group of ? */,
  147 /* Id of Discrete */,
  5 /* Color of Discrete */,
  57 /* Group of ? */,
  -13 /* Id of Bool */,
  3 /* Color of Bool */,
  42 /* Group of ? */,
  -9 /* Id of Float */,
  3 /* Color of Float */,
  44 /* Group of ? */,
  -29 /* Id of Int */,
  6 /* Color of Int */,
  66 /* Group of ? */,
  -33 /* Id of Char */,
  6 /* Color of Char */,
  63 /* Group of ? */,
  -1 /* Id of Pointer */,
  3 /* Color of Pointer */,
  42 /* Group of ? */,
};
const char *LOCATE_list = "/Users/tony/Projects/nit/lib/standard//collection//list.nit";
const int SFT_list[12] = {
  303 /* Id of List */,
  12 /* Color of List */,
  2 /* Group of ? */,
  94 /* Group of ? */,
  259 /* Id of ListIterator */,
  6 /* Color of ListIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  203 /* Id of ListNode */,
  7 /* Color of ListNode */,
  3 /* Group of ? */,
  72 /* Group of ? */,
};
const char *LOCATE_sorter = "/Users/tony/Projects/nit/lib/standard//collection//sorter.nit";
const int SFT_sorter[6] = {
  75 /* Id of AbstractSorter */,
  3 /* Color of AbstractSorter */,
  42 /* Group of ? */,
  159 /* Id of ComparableSorter */,
  4 /* Color of ComparableSorter */,
  49 /* Group of ? */,
};
const char *LOCATE_array = "/Users/tony/Projects/nit/lib/standard//collection//array.nit";
const int SFT_array[35] = {
  287 /* Id of AbstractArrayRead */,
  12 /* Color of AbstractArrayRead */,
  2 /* Group of ? */,
  94 /* Group of ? */,
  323 /* Id of AbstractArray */,
  14 /* Color of AbstractArray */,
  45 /* Group of ? */,
  339 /* Id of Array */,
  4 /* Color of Array */,
  3 /* Group of ? */,
  48 /* Group of ? */,
  283 /* Id of ArrayIterator */,
  6 /* Color of ArrayIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  311 /* Id of ArraySet */,
  9 /* Color of ArraySet */,
  2 /* Group of ? */,
  78 /* Group of ? */,
  171 /* Id of ArraySetIterator */,
  4 /* Color of ArraySetIterator */,
  2 /* Group of ? */,
  47 /* Group of ? */,
  315 /* Id of ArrayMap */,
  12 /* Color of ArrayMap */,
  2 /* Group of ? */,
  88 /* Group of ? */,
  42 /* Group of ? */,
  58 /* Group of ? */,
  71 /* Id of ArrayCapable */,
  3 /* Color of ArrayCapable */,
  42 /* Group of ? */,
  31 /* Id of NativeArray */,
  3 /* Color of NativeArray */,
  42 /* Group of ? */,
};
const char *LOCATE_hash_collection = "/Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit";
const int SFT_hash_collection[29] = {
  135 /* Id of HashCollection */,
  4 /* Color of HashCollection */,
  2 /* Group of ? */,
  44 /* Group of ? */,
  47 /* Id of HashNode */,
  3 /* Color of HashNode */,
  2 /* Group of ? */,
  42 /* Group of ? */,
  271 /* Id of HashMap */,
  8 /* Color of HashMap */,
  54 /* Group of ? */,
  131 /* Id of HashMapNode */,
  4 /* Color of HashMapNode */,
  7 /* Group of ? */,
  48 /* Group of ? */,
  219 /* Id of HashMapIterator */,
  5 /* Color of HashMapIterator */,
  2 /* Group of ? */,
  49 /* Group of ? */,
  307 /* Id of HashSet */,
  9 /* Color of HashSet */,
  55 /* Group of ? */,
  123 /* Id of HashSetNode */,
  4 /* Color of HashSetNode */,
  48 /* Group of ? */,
  127 /* Id of HashSetIterator */,
  4 /* Color of HashSetIterator */,
  2 /* Group of ? */,
  47 /* Group of ? */,
};
const char *LOCATE_hash = "/Users/tony/Projects/nit/lib/standard//hash.nit";
const int SFT_hash[1] = {
  37 /* Group of ? */,
};
const char *LOCATE_time = "/Users/tony/Projects/nit/lib/standard//time.nit";
const int SFT_time[1] = {
  17 /* Group of ? */,
};
const char *LOCATE_file = "/Users/tony/Projects/nit/lib/standard//file.nit";
const int SFT_file[33] = {
  26 /* Group of ? */,
  139 /* Id of FStream */,
  7 /* Color of FStream */,
  2 /* Group of ? */,
  48 /* Group of ? */,
  267 /* Id of IFStream */,
  8 /* Color of IFStream */,
  6 /* Group of ? */,
  68 /* Group of ? */,
  195 /* Id of OFStream */,
  6 /* Color of OFStream */,
  4 /* Group of ? */,
  57 /* Group of ? */,
  291 /* Id of Stdin */,
  9 /* Color of Stdin */,
  73 /* Group of ? */,
  239 /* Id of Stdout */,
  8 /* Color of Stdout */,
  62 /* Group of ? */,
  243 /* Id of Stderr */,
  8 /* Color of Stderr */,
  62 /* Group of ? */,
  120 /* Group of ? */,
  50 /* Group of ? */,
  -25 /* Id of FileStat */,
  4 /* Color of FileStat */,
  43 /* Group of ? */,
  -21 /* Id of NativeFile */,
  4 /* Color of NativeFile */,
  43 /* Group of ? */,
  27 /* Id of NativeFileCapable */,
  3 /* Color of NativeFileCapable */,
  42 /* Group of ? */,
};
const char *LOCATE_stream = "/Users/tony/Projects/nit/lib/standard//stream.nit";
const int SFT_stream[31] = {
  43 /* Id of IOS */,
  4 /* Color of IOS */,
  51 /* Group of ? */,
  119 /* Id of IStream */,
  6 /* Color of IStream */,
  57 /* Group of ? */,
  99 /* Id of OStream */,
  5 /* Color of OStream */,
  54 /* Group of ? */,
  235 /* Id of BufferedIStream */,
  5 /* Color of BufferedIStream */,
  4 /* Group of ? */,
  64 /* Group of ? */,
  215 /* Id of IOStream */,
  9 /* Color of IOStream */,
  70 /* Group of ? */,
  143 /* Id of FDStream */,
  3 /* Color of FDStream */,
  2 /* Group of ? */,
  42 /* Group of ? */,
  227 /* Id of FDIStream */,
  8 /* Color of FDIStream */,
  4 /* Group of ? */,
  64 /* Group of ? */,
  223 /* Id of FDOStream */,
  7 /* Color of FDOStream */,
  3 /* Group of ? */,
  48 /* Group of ? */,
  275 /* Id of FDIOStream */,
  10 /* Color of FDIOStream */,
  66 /* Group of ? */,
};
const char *LOCATE_string_search = "/Users/tony/Projects/nit/lib/standard//string_search.nit";
const int SFT_string_search[12] = {
  23 /* Id of Pattern */,
  3 /* Color of Pattern */,
  42 /* Group of ? */,
  167 /* Id of BM_Pattern */,
  4 /* Color of BM_Pattern */,
  2 /* Group of ? */,
  48 /* Group of ? */,
  35 /* Id of Match */,
  3 /* Color of Match */,
  2 /* Group of ? */,
  42 /* Group of ? */,
  128 /* Group of ? */,
};
const char *LOCATE_exec = "/Users/tony/Projects/nit/lib/standard//exec.nit";
const int SFT_exec[20] = {
  19 /* Id of Process */,
  3 /* Color of Process */,
  2 /* Group of ? */,
  42 /* Group of ? */,
  211 /* Id of IProcess */,
  8 /* Color of IProcess */,
  4 /* Group of ? */,
  67 /* Group of ? */,
  191 /* Id of OProcess */,
  7 /* Color of OProcess */,
  3 /* Group of ? */,
  64 /* Group of ? */,
  263 /* Id of IOProcess */,
  10 /* Color of IOProcess */,
  71 /* Group of ? */,
  42 /* Group of ? */,
  54 /* Group of ? */,
  -17 /* Id of NativeProcess */,
  4 /* Color of NativeProcess */,
  43 /* Group of ? */,
};
const char *LOCATE_math = "/Users/tony/Projects/nit/lib/standard//math.nit";
const int SFT_math[3] = {
  79 /* Group of ? */,
  55 /* Group of ? */,
  38 /* Group of ? */,
};
const char *LOCATE_main = "./main.nit";
const classtable_elt_t VFT_Sys[50] = {
  {(bigint) 7 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Sys < Object: superclass typecheck marker */},
  {(bigint) 7 /* 3: Sys < Sys: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Sys < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Sys___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) exec___Sys___system},
  {(bigint) string___Sys___program_name},
  {(bigint) string___Sys___init_args},
  {(bigint) string___Sys___native_argc},
  {(bigint) string___Sys___native_argv},
  {(bigint) 1 /* 47: Sys < Sys: superclass init_table position */},
  {(bigint) main___Sys___main},
  {(bigint) kernel___Sys___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Sys::_args_cache */
void INIT_ATTRIBUTES__Sys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Sys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Sys(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Sys;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Sys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Sys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Sys_kernel___Sys___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_Sys_kernel___Sys___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_Sys();
  INIT_ATTRIBUTES__Sys(fra.me.REG[0]);
  kernel___Sys___init(fra.me.REG[0], init_table);
  CHECKNEW_Sys(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_Bool[43] = {
  {(bigint) -13 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Bool < Object: superclass typecheck marker */},
  {(bigint) -13 /* 3: Bool < Bool: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Bool < Object: superclass init_table position */},
  {(bigint) kernel___Bool___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Bool_____eqeq},
  {(bigint) kernel___Bool_____neq},
  {(bigint) kernel___Bool___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Bool___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Bool___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: Bool < Bool: superclass init_table position */},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
const classtable_elt_t VFT_Float[66] = {
  {(bigint) -9 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Float < Object: superclass typecheck marker */},
  {(bigint) -9 /* 3: Float < Float: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Float < Object: superclass init_table position */},
  {(bigint) kernel___Float___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Float___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Float___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) utils___Float___absolue},
  {(bigint) string___Float___to_precision},
  {(bigint) 1 /* 44: Float < Float: superclass init_table position */},
  {(bigint) kernel___Float_____leq},
  {(bigint) kernel___Float_____l},
  {(bigint) kernel___Float_____geq},
  {(bigint) kernel___Float_____g},
  {(bigint) kernel___Float_____plus},
  {(bigint) kernel___Float___unary__minus},
  {(bigint) kernel___Float_____minus},
  {(bigint) kernel___Float_____star},
  {(bigint) kernel___Float_____slash},
  {(bigint) kernel___Float___to_i},
  {(bigint) math___Float___sqrt},
  {(bigint) math___Float___cos},
  {(bigint) math___Float___sin},
  {(bigint) math___Float___tan},
  {(bigint) math___Float___acos},
  {(bigint) math___Float___asin},
  {(bigint) math___Float___atan},
  {(bigint) math___Float___pow},
  {(bigint) math___Float___log},
  {(bigint) math___Float___exp},
  {(bigint) math___Float___rand},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_Float(float val) {
  struct TBOX_Float *box = (struct TBOX_Float*)alloc(sizeof(struct TBOX_Float));
  box->vft = VFT_Float;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_Int[80] = {
  {(bigint) -29 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Int < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 63 /* 4: Int < Comparable: superclass typecheck marker */},
  {(bigint) 147 /* 5: Int < Discrete: superclass typecheck marker */},
  {(bigint) -29 /* 6: Int < Int: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 2 /* 18: Int < Object: superclass init_table position */},
  {(bigint) kernel___Int___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Int_____eqeq},
  {(bigint) kernel___Int_____neq},
  {(bigint) kernel___Int___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Int___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Int___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 48: Int < Comparable: superclass init_table position */},
  {(bigint) kernel___Int_____l},
  {(bigint) kernel___Int_____leq},
  {(bigint) kernel___Int_____geq},
  {(bigint) kernel___Int_____g},
  {(bigint) kernel___Int_____leqg},
  {(bigint) kernel___Int___is_between},
  {(bigint) kernel___Int___max},
  {(bigint) kernel___Int___min},
  {(bigint) 0 /* 57: Int < Discrete: superclass init_table position */},
  {(bigint) kernel___Int___succ},
  {(bigint) kernel___Int___prec},
  {(bigint) kernel___Int_____plus},
  {(bigint) kernel___Int_____minus},
  {(bigint) kernel___Int___distance},
  {(bigint) string___Int___fill_buffer},
  {(bigint) string___Int___to_hex},
  {(bigint) string___Int___to_base},
  {(bigint) 3 /* 66: Int < Int: superclass init_table position */},
  {(bigint) kernel___Int___unary__minus},
  {(bigint) kernel___Int_____star},
  {(bigint) kernel___Int_____slash},
  {(bigint) kernel___Int_____percent},
  {(bigint) kernel___Int___lshift},
  {(bigint) kernel___Int___rshift},
  {(bigint) kernel___Int___to_f},
  {(bigint) kernel___Int___ascii},
  {(bigint) kernel___Int___digit_count},
  {(bigint) kernel___Int___to_c},
  {(bigint) kernel___Int___enumerate_to},
  {(bigint) kernel___Int___enumerate_before},
  {(bigint) math___Int___rand},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
const classtable_elt_t VFT_Char[72] = {
  {(bigint) -33 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Char < Object: superclass typecheck marker */},
  {(bigint) 23 /* 3: Char < Pattern: superclass typecheck marker */},
  {(bigint) 63 /* 4: Char < Comparable: superclass typecheck marker */},
  {(bigint) 147 /* 5: Char < Discrete: superclass typecheck marker */},
  {(bigint) -33 /* 6: Char < Char: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Char < Object: superclass init_table position */},
  {(bigint) kernel___Char___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Char_____eqeq},
  {(bigint) kernel___Char_____neq},
  {(bigint) kernel___Char___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Char___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Char___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Char < Pattern: superclass init_table position */},
  {(bigint) string_search___Char___search_index_in},
  {(bigint) string_search___Char___search_in},
  {(bigint) string_search___Pattern___search_all_in},
  {(bigint) string_search___Pattern___split_in},
  {(bigint) string_search___Pattern___init},
  {(bigint) 3 /* 48: Char < Comparable: superclass init_table position */},
  {(bigint) kernel___Char_____l},
  {(bigint) kernel___Char_____leq},
  {(bigint) kernel___Char_____geq},
  {(bigint) kernel___Char_____g},
  {(bigint) kernel___Comparable_____leqg},
  {(bigint) kernel___Comparable___is_between},
  {(bigint) kernel___Comparable___max},
  {(bigint) kernel___Comparable___min},
  {(bigint) 2 /* 57: Char < Discrete: superclass init_table position */},
  {(bigint) kernel___Char___succ},
  {(bigint) kernel___Char___prec},
  {(bigint) kernel___Char_____plus},
  {(bigint) kernel___Char_____minus},
  {(bigint) kernel___Char___distance},
  {(bigint) 4 /* 63: Char < Char: superclass init_table position */},
  {(bigint) kernel___Char___to_i},
  {(bigint) kernel___Char___ascii},
  {(bigint) kernel___Char___to_lower},
  {(bigint) kernel___Char___to_upper},
  {(bigint) kernel___Char___is_digit},
  {(bigint) kernel___Char___is_lower},
  {(bigint) kernel___Char___is_upper},
  {(bigint) kernel___Char___is_letter},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
const classtable_elt_t VFT_Pointer[43] = {
  {(bigint) -1 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Pointer < Object: superclass typecheck marker */},
  {(bigint) -1 /* 3: Pointer < Pointer: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Pointer < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: Pointer < Pointer: superclass init_table position */},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_Pointer(void * val) {
  struct TBOX_Pointer *box = (struct TBOX_Pointer*)alloc(sizeof(struct TBOX_Pointer));
  box->vft = VFT_Pointer;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_Container[72] = {
  {(bigint) 155 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Container < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: Container < Collection: superclass typecheck marker */},
  {(bigint) 155 /* 6: Container < Container: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Container < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 0 /* 59: Container < Collection: superclass init_table position */},
  {(bigint) abstract_collection___Container___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) abstract_collection___Container___is_empty},
  {(bigint) abstract_collection___Container___length},
  {(bigint) abstract_collection___Container___has},
  {(bigint) abstract_collection___Container___has_only},
  {(bigint) abstract_collection___Container___count},
  {(bigint) abstract_collection___Container___first},
  {(bigint) 2 /* 68: Container < Container: superclass init_table position */},
  {(bigint) abstract_collection___Container___init},
  {(bigint) abstract_collection___Container___item},
  {(bigint) abstract_collection___Container___item__eq},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Container::_item */
void INIT_ATTRIBUTES__Container(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Container;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Container(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Container;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Container(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Container;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Container_abstract_collection___Container___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 158;
  fra.me.meth = LOCATE_NEW_Container_abstract_collection___Container___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//abstract_collection.nit:158 */
  fra.me.REG[1] = NEW_Container();
  INIT_ATTRIBUTES__Container(fra.me.REG[1]);
  abstract_collection___Container___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Container(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_ContainerIterator[49] = {
  {(bigint) 151 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ContainerIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: ContainerIterator < Iterator: superclass typecheck marker */},
  {(bigint) 151 /* 4: ContainerIterator < ContainerIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: ContainerIterator < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 0 /* 43: ContainerIterator < Iterator: superclass init_table position */},
  {(bigint) abstract_collection___ContainerIterator___item},
  {(bigint) abstract_collection___ContainerIterator___next},
  {(bigint) abstract_collection___ContainerIterator___is_ok},
  {(bigint) 2 /* 47: ContainerIterator < ContainerIterator: superclass init_table position */},
  {(bigint) abstract_collection___ContainerIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ContainerIterator::_is_ok */
/* 3: Attribute ContainerIterator::_container */
void INIT_ATTRIBUTES__ContainerIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ContainerIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//abstract_collection.nit:174 */
  REGB0 = TAG_Bool(true);
  ATTR_abstract_collection___ContainerIterator____is_ok(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ContainerIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_ContainerIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ContainerIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ContainerIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_abstract_collection___ContainerIterator____is_ok(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_is_ok", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_abstract_collection___ContainerIterator____container(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_container", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_ContainerIterator_abstract_collection___ContainerIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 172;
  fra.me.meth = LOCATE_NEW_ContainerIterator_abstract_collection___ContainerIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//abstract_collection.nit:172 */
  fra.me.REG[1] = NEW_ContainerIterator();
  INIT_ATTRIBUTES__ContainerIterator(fra.me.REG[1]);
  abstract_collection___ContainerIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_ContainerIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_CoupleMapIterator[51] = {
  {(bigint) 231 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: CoupleMapIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: CoupleMapIterator < Iterator: superclass typecheck marker */},
  {(bigint) 111 /* 4: CoupleMapIterator < MapIterator: superclass typecheck marker */},
  {(bigint) 231 /* 5: CoupleMapIterator < CoupleMapIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 2 /* 18: CoupleMapIterator < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 1 /* 43: CoupleMapIterator < Iterator: superclass init_table position */},
  {(bigint) abstract_collection___CoupleMapIterator___item},
  {(bigint) abstract_collection___CoupleMapIterator___next},
  {(bigint) abstract_collection___CoupleMapIterator___is_ok},
  {(bigint) 0 /* 47: CoupleMapIterator < MapIterator: superclass init_table position */},
  {(bigint) abstract_collection___CoupleMapIterator___key},
  {(bigint) 3 /* 49: CoupleMapIterator < CoupleMapIterator: superclass init_table position */},
  {(bigint) abstract_collection___CoupleMapIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute CoupleMapIterator::_iter */
void INIT_ATTRIBUTES__CoupleMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__CoupleMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_CoupleMapIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_CoupleMapIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_CoupleMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_CoupleMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_abstract_collection___CoupleMapIterator____iter(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_iter", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 424;
  fra.me.meth = LOCATE_NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//abstract_collection.nit:424 */
  fra.me.REG[1] = NEW_CoupleMapIterator();
  INIT_ATTRIBUTES__CoupleMapIterator(fra.me.REG[1]);
  abstract_collection___CoupleMapIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_CoupleMapIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Couple[48] = {
  {(bigint) 59 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Couple < Object: superclass typecheck marker */},
  {(bigint) 59 /* 3: Couple < Couple: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Couple < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: Couple < Couple: superclass init_table position */},
  {(bigint) abstract_collection___Couple___first},
  {(bigint) abstract_collection___Couple___first__eq},
  {(bigint) abstract_collection___Couple___second},
  {(bigint) abstract_collection___Couple___second__eq},
  {(bigint) abstract_collection___Couple___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Couple::_first */
/* 3: Attribute Couple::_second */
void INIT_ATTRIBUTES__Couple(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Couple;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Couple(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_Couple;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Couple(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Couple;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Couple_abstract_collection___Couple___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 438;
  fra.me.meth = LOCATE_NEW_Couple_abstract_collection___Couple___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//collection//abstract_collection.nit:438 */
  fra.me.REG[2] = NEW_Couple();
  INIT_ATTRIBUTES__Couple(fra.me.REG[2]);
  abstract_collection___Couple___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_Couple(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_Range[73] = {
  {(bigint) 87 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Range < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: Range < Collection: superclass typecheck marker */},
  {(bigint) 87 /* 6: Range < Range: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Range < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 0 /* 59: Range < Collection: superclass init_table position */},
  {(bigint) range___Range___iterator},
  {(bigint) range___Range___iterate},
  {(bigint) range___Range___is_empty},
  {(bigint) range___Range___length},
  {(bigint) range___Range___has},
  {(bigint) range___Range___has_only},
  {(bigint) range___Range___count},
  {(bigint) range___Range___first},
  {(bigint) 2 /* 68: Range < Range: superclass init_table position */},
  {(bigint) range___Range___last},
  {(bigint) range___Range___after},
  {(bigint) range___Range___init},
  {(bigint) range___Range___without_last},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Range::_first */
/* 3: Attribute Range::_last */
/* 4: Attribute Range::_after */
void INIT_ATTRIBUTES__Range(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Range;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Range(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_Range;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Range(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Range;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_range___Range____first(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_first", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_range___Range____last(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_last", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_range___Range____after(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_after", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Range_range___Range___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 68;
  fra.me.meth = LOCATE_NEW_Range_range___Range___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//collection//range.nit:68 */
  fra.me.REG[2] = NEW_Range();
  INIT_ATTRIBUTES__Range(fra.me.REG[2]);
  range___Range___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_Range(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
val_t NEW_Range_range___Range___without_last(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 77;
  fra.me.meth = LOCATE_NEW_Range_range___Range___without_last;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//collection//range.nit:77 */
  fra.me.REG[2] = NEW_Range();
  INIT_ATTRIBUTES__Range(fra.me.REG[2]);
  range___Range___without_last(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_Range(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_IteratorRange[49] = {
  {(bigint) 115 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: IteratorRange < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: IteratorRange < Iterator: superclass typecheck marker */},
  {(bigint) 115 /* 4: IteratorRange < IteratorRange: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: IteratorRange < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 0 /* 43: IteratorRange < Iterator: superclass init_table position */},
  {(bigint) range___IteratorRange___item},
  {(bigint) range___IteratorRange___next},
  {(bigint) range___IteratorRange___is_ok},
  {(bigint) 2 /* 47: IteratorRange < IteratorRange: superclass init_table position */},
  {(bigint) range___IteratorRange___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IteratorRange::_range */
/* 3: Attribute IteratorRange::_item */
void INIT_ATTRIBUTES__IteratorRange(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__IteratorRange;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IteratorRange(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_IteratorRange;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_IteratorRange(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_IteratorRange;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_range___IteratorRange____range(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_range", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_range___IteratorRange____item(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_item", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_IteratorRange_range___IteratorRange___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 97;
  fra.me.meth = LOCATE_NEW_IteratorRange_range___IteratorRange___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//range.nit:97 */
  fra.me.REG[1] = NEW_IteratorRange();
  INIT_ATTRIBUTES__IteratorRange(fra.me.REG[1]);
  range___IteratorRange___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_IteratorRange(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_List[102] = {
  {(bigint) 303 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: List < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: List < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: List < RemovableCollection: superclass typecheck marker */},
  {(bigint) 107 /* 7: List < MapRead: superclass typecheck marker */},
  {(bigint) 179 /* 8: List < SimpleCollection: superclass typecheck marker */},
  {(bigint) 183 /* 9: List < SequenceRead: superclass typecheck marker */},
  {(bigint) 199 /* 10: List < Map: superclass typecheck marker */},
  {(bigint) 251 /* 11: List < Sequence: superclass typecheck marker */},
  {(bigint) 303 /* 12: List < List: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 7 /* 18: List < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 6 /* 59: List < Collection: superclass init_table position */},
  {(bigint) list___List___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) list___List___is_empty},
  {(bigint) list___List___length},
  {(bigint) list___List___has},
  {(bigint) list___List___has_only},
  {(bigint) list___List___count},
  {(bigint) list___List___first},
  {(bigint) 5 /* 68: List < RemovableCollection: superclass init_table position */},
  {(bigint) list___List___clear},
  {(bigint) list___List___remove},
  {(bigint) abstract_collection___RemovableCollection___remove_all},
  {(bigint) 3 /* 72: List < MapRead: superclass init_table position */},
  {(bigint) list___List_____bra},
  {(bigint) list___List___has_key},
  {(bigint) 4 /* 75: List < SimpleCollection: superclass init_table position */},
  {(bigint) abstract_collection___Sequence___add},
  {(bigint) abstract_collection___SimpleCollection___add_all},
  {(bigint) 1 /* 78: List < SequenceRead: superclass init_table position */},
  {(bigint) list___List___last},
  {(bigint) abstract_collection___SequenceRead___index_of},
  {(bigint) string___Map___map_join},
  {(bigint) 2 /* 82: List < Map: superclass init_table position */},
  {(bigint) list___List_____braeq},
  {(bigint) list___List___remove_at},
  {(bigint) abstract_collection___Map___recover_with},
  {(bigint) 0 /* 86: List < Sequence: superclass init_table position */},
  {(bigint) list___List___first__eq},
  {(bigint) list___List___last__eq},
  {(bigint) list___List___push},
  {(bigint) abstract_collection___Sequence___append},
  {(bigint) list___List___pop},
  {(bigint) list___List___unshift},
  {(bigint) list___List___shift},
  {(bigint) 8 /* 94: List < List: superclass init_table position */},
  {(bigint) list___List___link},
  {(bigint) list___List___init},
  {(bigint) list___List___from},
  {(bigint) list___List___get_node},
  {(bigint) list___List___search_node_after},
  {(bigint) list___List___remove_node},
  {(bigint) list___List___insert_before},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute List::_head */
/* 3: Attribute List::_tail */
void INIT_ATTRIBUTES__List(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__List;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_List(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_List;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_List(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_List;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_List_list___List___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 175;
  fra.me.meth = LOCATE_NEW_List_list___List___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//collection//list.nit:175 */
  fra.me.REG[0] = NEW_List();
  INIT_ATTRIBUTES__List(fra.me.REG[0]);
  list___List___init(fra.me.REG[0], init_table);
  CHECKNEW_List(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
val_t NEW_List_list___List___from(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 178;
  fra.me.meth = LOCATE_NEW_List_list___List___from;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//list.nit:178 */
  fra.me.REG[1] = NEW_List();
  INIT_ATTRIBUTES__List(fra.me.REG[1]);
  list___List___from(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_List(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_ListIterator[56] = {
  {(bigint) 259 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ListIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: ListIterator < Iterator: superclass typecheck marker */},
  {(bigint) 111 /* 4: ListIterator < MapIterator: superclass typecheck marker */},
  {(bigint) 207 /* 5: ListIterator < IndexedIterator: superclass typecheck marker */},
  {(bigint) 259 /* 6: ListIterator < ListIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 3 /* 18: ListIterator < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 2 /* 43: ListIterator < Iterator: superclass init_table position */},
  {(bigint) list___ListIterator___item},
  {(bigint) list___ListIterator___next},
  {(bigint) list___ListIterator___is_ok},
  {(bigint) 1 /* 47: ListIterator < MapIterator: superclass init_table position */},
  {(bigint) abstract_collection___IndexedIterator___key},
  {(bigint) 0 /* 49: ListIterator < IndexedIterator: superclass init_table position */},
  {(bigint) list___ListIterator___index},
  {(bigint) 4 /* 51: ListIterator < ListIterator: superclass init_table position */},
  {(bigint) list___ListIterator___item__eq},
  {(bigint) list___ListIterator___init},
  {(bigint) list___ListIterator___delete},
  {(bigint) list___ListIterator___insert_before},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ListIterator::_list */
/* 3: Attribute ListIterator::_node */
/* 4: Attribute ListIterator::_index */
void INIT_ATTRIBUTES__ListIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ListIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ListIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_ListIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ListIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ListIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_list___ListIterator____list(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_list", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_list___ListIterator____index(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_index", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_ListIterator_list___ListIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 258;
  fra.me.meth = LOCATE_NEW_ListIterator_list___ListIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//list.nit:258 */
  fra.me.REG[1] = NEW_ListIterator();
  INIT_ATTRIBUTES__ListIterator(fra.me.REG[1]);
  list___ListIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_ListIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_ListNode[78] = {
  {(bigint) 203 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ListNode < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: ListNode < Collection: superclass typecheck marker */},
  {(bigint) 155 /* 6: ListNode < Container: superclass typecheck marker */},
  {(bigint) 203 /* 7: ListNode < ListNode: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: ListNode < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 0 /* 59: ListNode < Collection: superclass init_table position */},
  {(bigint) abstract_collection___Container___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) abstract_collection___Container___is_empty},
  {(bigint) abstract_collection___Container___length},
  {(bigint) abstract_collection___Container___has},
  {(bigint) abstract_collection___Container___has_only},
  {(bigint) abstract_collection___Container___count},
  {(bigint) abstract_collection___Container___first},
  {(bigint) 2 /* 68: ListNode < Container: superclass init_table position */},
  {(bigint) abstract_collection___Container___init},
  {(bigint) abstract_collection___Container___item},
  {(bigint) abstract_collection___Container___item__eq},
  {(bigint) 3 /* 72: ListNode < ListNode: superclass init_table position */},
  {(bigint) list___ListNode___init},
  {(bigint) list___ListNode___next},
  {(bigint) list___ListNode___next__eq},
  {(bigint) list___ListNode___prev},
  {(bigint) list___ListNode___prev__eq},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ListNode::_item */
/* 3: Attribute ListNode::_next */
/* 4: Attribute ListNode::_prev */
void INIT_ATTRIBUTES__ListNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ListNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ListNode(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_ListNode;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ListNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ListNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ListNode_list___ListNode___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 291;
  fra.me.meth = LOCATE_NEW_ListNode_list___ListNode___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//list.nit:291 */
  fra.me.REG[1] = NEW_ListNode();
  INIT_ATTRIBUTES__ListNode(fra.me.REG[1]);
  list___ListNode___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_ListNode(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_AbstractArrayRead[101] = {
  {(bigint) 287 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: AbstractArrayRead < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: AbstractArrayRead < Collection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 107 /* 7: AbstractArrayRead < MapRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 183 /* 9: AbstractArrayRead < SequenceRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 287 /* 12: AbstractArrayRead < AbstractArrayRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 3 /* 18: AbstractArrayRead < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) array___AbstractArrayRead_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) array___AbstractArrayRead___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 2 /* 59: AbstractArrayRead < Collection: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) array___AbstractArrayRead___is_empty},
  {(bigint) array___AbstractArrayRead___length},
  {(bigint) array___AbstractArrayRead___has},
  {(bigint) array___AbstractArrayRead___has_only},
  {(bigint) array___AbstractArrayRead___count},
  {(bigint) abstract_collection___SequenceRead___first},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 72: AbstractArrayRead < MapRead: superclass init_table position */},
  {(bigint) abstract_collection___MapRead_____bra},
  {(bigint) array___AbstractArrayRead___has_key},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 78: AbstractArrayRead < SequenceRead: superclass init_table position */},
  {(bigint) abstract_collection___SequenceRead___last},
  {(bigint) array___AbstractArrayRead___index_of},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 94: AbstractArrayRead < AbstractArrayRead: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___last_index_of},
  {(bigint) array___AbstractArrayRead___index_of_from},
  {(bigint) array___AbstractArrayRead___last_index_of_from},
  {(bigint) array___AbstractArrayRead___reversed},
  {(bigint) array___AbstractArrayRead___copy_to},
  {(bigint) array___AbstractArrayRead___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute AbstractArrayRead::_length */
void INIT_ATTRIBUTES__AbstractArrayRead(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__AbstractArrayRead;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_AbstractArrayRead(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_AbstractArrayRead;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_AbstractArrayRead(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_AbstractArrayRead;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_AbstractArrayRead_array___AbstractArrayRead___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_AbstractArrayRead_array___AbstractArrayRead___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_AbstractArrayRead();
  INIT_ATTRIBUTES__AbstractArrayRead(fra.me.REG[0]);
  array___AbstractArrayRead___init(fra.me.REG[0], init_table);
  CHECKNEW_AbstractArrayRead(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_AbstractArray[101] = {
  {(bigint) 323 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: AbstractArray < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: AbstractArray < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: AbstractArray < RemovableCollection: superclass typecheck marker */},
  {(bigint) 107 /* 7: AbstractArray < MapRead: superclass typecheck marker */},
  {(bigint) 179 /* 8: AbstractArray < SimpleCollection: superclass typecheck marker */},
  {(bigint) 183 /* 9: AbstractArray < SequenceRead: superclass typecheck marker */},
  {(bigint) 199 /* 10: AbstractArray < Map: superclass typecheck marker */},
  {(bigint) 251 /* 11: AbstractArray < Sequence: superclass typecheck marker */},
  {(bigint) 287 /* 12: AbstractArray < AbstractArrayRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 323 /* 14: AbstractArray < AbstractArray: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 3 /* 18: AbstractArray < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) array___AbstractArrayRead_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) array___AbstractArrayRead___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 9 /* 45: AbstractArray < AbstractArray: superclass init_table position */},
  {(bigint) array___AbstractArray___enlarge},
  {(bigint) array___AbstractArray___insert},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 2 /* 59: AbstractArray < Collection: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) array___AbstractArrayRead___is_empty},
  {(bigint) array___AbstractArrayRead___length},
  {(bigint) array___AbstractArrayRead___has},
  {(bigint) array___AbstractArrayRead___has_only},
  {(bigint) array___AbstractArrayRead___count},
  {(bigint) abstract_collection___SequenceRead___first},
  {(bigint) 8 /* 68: AbstractArray < RemovableCollection: superclass init_table position */},
  {(bigint) array___AbstractArray___clear},
  {(bigint) array___AbstractArray___remove},
  {(bigint) array___AbstractArray___remove_all},
  {(bigint) 1 /* 72: AbstractArray < MapRead: superclass init_table position */},
  {(bigint) abstract_collection___MapRead_____bra},
  {(bigint) array___AbstractArrayRead___has_key},
  {(bigint) 7 /* 75: AbstractArray < SimpleCollection: superclass init_table position */},
  {(bigint) array___AbstractArray___add},
  {(bigint) abstract_collection___SimpleCollection___add_all},
  {(bigint) 0 /* 78: AbstractArray < SequenceRead: superclass init_table position */},
  {(bigint) abstract_collection___SequenceRead___last},
  {(bigint) array___AbstractArrayRead___index_of},
  {(bigint) string___Map___map_join},
  {(bigint) 6 /* 82: AbstractArray < Map: superclass init_table position */},
  {(bigint) abstract_collection___Map_____braeq},
  {(bigint) array___AbstractArray___remove_at},
  {(bigint) abstract_collection___Map___recover_with},
  {(bigint) 5 /* 86: AbstractArray < Sequence: superclass init_table position */},
  {(bigint) abstract_collection___Sequence___first__eq},
  {(bigint) abstract_collection___Sequence___last__eq},
  {(bigint) array___AbstractArray___push},
  {(bigint) abstract_collection___Sequence___append},
  {(bigint) array___AbstractArray___pop},
  {(bigint) array___AbstractArray___unshift},
  {(bigint) array___AbstractArray___shift},
  {(bigint) 4 /* 94: AbstractArray < AbstractArrayRead: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___last_index_of},
  {(bigint) array___AbstractArrayRead___index_of_from},
  {(bigint) array___AbstractArrayRead___last_index_of_from},
  {(bigint) array___AbstractArrayRead___reversed},
  {(bigint) array___AbstractArrayRead___copy_to},
  {(bigint) array___AbstractArrayRead___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute AbstractArray::_length */
void INIT_ATTRIBUTES__AbstractArray(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__AbstractArray;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_AbstractArray(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_AbstractArray;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_AbstractArray(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_AbstractArray;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_AbstractArray_array___AbstractArrayRead___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_AbstractArray_array___AbstractArrayRead___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_AbstractArray();
  INIT_ATTRIBUTES__AbstractArray(fra.me.REG[0]);
  array___AbstractArrayRead___init(fra.me.REG[0], init_table);
  CHECKNEW_AbstractArray(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_Array[101] = {
  {(bigint) 339 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Array < Object: superclass typecheck marker */},
  {(bigint) 71 /* 3: Array < ArrayCapable: superclass typecheck marker */},
  {(bigint) 339 /* 4: Array < Array: superclass typecheck marker */},
  {(bigint) 67 /* 5: Array < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: Array < RemovableCollection: superclass typecheck marker */},
  {(bigint) 107 /* 7: Array < MapRead: superclass typecheck marker */},
  {(bigint) 179 /* 8: Array < SimpleCollection: superclass typecheck marker */},
  {(bigint) 183 /* 9: Array < SequenceRead: superclass typecheck marker */},
  {(bigint) 199 /* 10: Array < Map: superclass typecheck marker */},
  {(bigint) 251 /* 11: Array < Sequence: superclass typecheck marker */},
  {(bigint) 287 /* 12: Array < AbstractArrayRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 323 /* 14: Array < AbstractArray: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 3 /* 18: Array < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) array___AbstractArrayRead_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) array___AbstractArrayRead___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Array___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 10 /* 42: Array < ArrayCapable: superclass init_table position */},
  {(bigint) array___ArrayCapable___calloc_array},
  {0} /* Class Hole :( */,
  {(bigint) 9 /* 45: Array < AbstractArray: superclass init_table position */},
  {(bigint) array___Array___enlarge},
  {(bigint) array___AbstractArray___insert},
  {(bigint) 11 /* 48: Array < Array: superclass init_table position */},
  {(bigint) array___Array___init},
  {(bigint) array___Array___with_items},
  {(bigint) array___Array___with_capacity},
  {(bigint) array___Array___filled_with},
  {(bigint) array___Array___with_native},
  {(bigint) array___Array___intern_items},
  {(bigint) array___Array___sort},
  {(bigint) array___Array___sub_sort},
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 2 /* 59: Array < Collection: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___iterator},
  {(bigint) array___Array___iterate},
  {(bigint) array___AbstractArrayRead___is_empty},
  {(bigint) array___AbstractArrayRead___length},
  {(bigint) array___AbstractArrayRead___has},
  {(bigint) array___AbstractArrayRead___has_only},
  {(bigint) array___AbstractArrayRead___count},
  {(bigint) abstract_collection___SequenceRead___first},
  {(bigint) 8 /* 68: Array < RemovableCollection: superclass init_table position */},
  {(bigint) array___AbstractArray___clear},
  {(bigint) array___AbstractArray___remove},
  {(bigint) array___AbstractArray___remove_all},
  {(bigint) 1 /* 72: Array < MapRead: superclass init_table position */},
  {(bigint) array___Array_____bra},
  {(bigint) array___AbstractArrayRead___has_key},
  {(bigint) 7 /* 75: Array < SimpleCollection: superclass init_table position */},
  {(bigint) array___Array___add},
  {(bigint) abstract_collection___SimpleCollection___add_all},
  {(bigint) 0 /* 78: Array < SequenceRead: superclass init_table position */},
  {(bigint) abstract_collection___SequenceRead___last},
  {(bigint) array___AbstractArrayRead___index_of},
  {(bigint) string___Map___map_join},
  {(bigint) 6 /* 82: Array < Map: superclass init_table position */},
  {(bigint) array___Array_____braeq},
  {(bigint) array___AbstractArray___remove_at},
  {(bigint) abstract_collection___Map___recover_with},
  {(bigint) 5 /* 86: Array < Sequence: superclass init_table position */},
  {(bigint) abstract_collection___Sequence___first__eq},
  {(bigint) abstract_collection___Sequence___last__eq},
  {(bigint) array___AbstractArray___push},
  {(bigint) abstract_collection___Sequence___append},
  {(bigint) array___AbstractArray___pop},
  {(bigint) array___AbstractArray___unshift},
  {(bigint) array___AbstractArray___shift},
  {(bigint) 4 /* 94: Array < AbstractArrayRead: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___last_index_of},
  {(bigint) array___AbstractArrayRead___index_of_from},
  {(bigint) array___AbstractArrayRead___last_index_of_from},
  {(bigint) array___AbstractArrayRead___reversed},
  {(bigint) array___AbstractArrayRead___copy_to},
  {(bigint) array___AbstractArrayRead___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Array::_length */
/* 3: Attribute Array::_items */
/* 4: Attribute Array::_capacity */
void INIT_ATTRIBUTES__Array(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Array;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:329 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_array___Array____items(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:337 */
  REGB0 = TAG_Int(0);
  ATTR_array___Array____capacity(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Array(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_Array;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Array(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Array;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_array___Array____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Array_array___Array___with_capacity(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 297;
  fra.me.meth = LOCATE_NEW_Array_array___Array___with_capacity;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:297 */
  fra.me.REG[0] = NEW_Array();
  INIT_ATTRIBUTES__Array(fra.me.REG[0]);
  array___Array___with_capacity(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_Array(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
val_t NEW_Array_array___Array___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 282;
  fra.me.meth = LOCATE_NEW_Array_array___Array___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:282 */
  fra.me.REG[0] = NEW_Array();
  INIT_ATTRIBUTES__Array(fra.me.REG[0]);
  array___Array___init(fra.me.REG[0], init_table);
  CHECKNEW_Array(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
val_t NEW_Array_array___Array___filled_with(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 306;
  fra.me.meth = LOCATE_NEW_Array_array___Array___filled_with;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:306 */
  fra.me.REG[1] = NEW_Array();
  INIT_ATTRIBUTES__Array(fra.me.REG[1]);
  array___Array___filled_with(fra.me.REG[1], fra.me.REG[0], REGB0, init_table);
  CHECKNEW_Array(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
val_t NEW_Array_array___Array___with_items(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 289;
  fra.me.meth = LOCATE_NEW_Array_array___Array___with_items;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:289 */
  fra.me.REG[1] = NEW_Array();
  INIT_ATTRIBUTES__Array(fra.me.REG[1]);
  array___Array___with_items(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Array(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
val_t NEW_Array_array___Array___with_native(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 320;
  fra.me.meth = LOCATE_NEW_Array_array___Array___with_native;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:320 */
  fra.me.REG[1] = NEW_Array();
  INIT_ATTRIBUTES__Array(fra.me.REG[1]);
  array___Array___with_native(fra.me.REG[1], fra.me.REG[0], REGB0, init_table);
  CHECKNEW_Array(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_ArrayIterator[53] = {
  {(bigint) 283 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ArrayIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: ArrayIterator < Iterator: superclass typecheck marker */},
  {(bigint) 111 /* 4: ArrayIterator < MapIterator: superclass typecheck marker */},
  {(bigint) 207 /* 5: ArrayIterator < IndexedIterator: superclass typecheck marker */},
  {(bigint) 283 /* 6: ArrayIterator < ArrayIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 3 /* 18: ArrayIterator < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 2 /* 43: ArrayIterator < Iterator: superclass init_table position */},
  {(bigint) array___ArrayIterator___item},
  {(bigint) array___ArrayIterator___next},
  {(bigint) array___ArrayIterator___is_ok},
  {(bigint) 1 /* 47: ArrayIterator < MapIterator: superclass init_table position */},
  {(bigint) abstract_collection___IndexedIterator___key},
  {(bigint) 0 /* 49: ArrayIterator < IndexedIterator: superclass init_table position */},
  {(bigint) array___ArrayIterator___index},
  {(bigint) 4 /* 51: ArrayIterator < ArrayIterator: superclass init_table position */},
  {(bigint) array___ArrayIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArrayIterator::_index */
/* 3: Attribute ArrayIterator::_array */
void INIT_ATTRIBUTES__ArrayIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ArrayIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:409 */
  REGB0 = TAG_Int(0);
  ATTR_array___ArrayIterator____index(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArrayIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_ArrayIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ArrayIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ArrayIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_array___ArrayIterator____index(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_index", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_array___ArrayIterator____array(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_array", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArrayIterator_array___ArrayIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 403;
  fra.me.meth = LOCATE_NEW_ArrayIterator_array___ArrayIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:403 */
  fra.me.REG[1] = NEW_ArrayIterator();
  INIT_ATTRIBUTES__ArrayIterator(fra.me.REG[1]);
  array___ArrayIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_ArrayIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_ArraySet[83] = {
  {(bigint) 311 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ArraySet < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: ArraySet < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: ArraySet < RemovableCollection: superclass typecheck marker */},
  {(bigint) 247 /* 7: ArraySet < Set: superclass typecheck marker */},
  {(bigint) 179 /* 8: ArraySet < SimpleCollection: superclass typecheck marker */},
  {(bigint) 311 /* 9: ArraySet < ArraySet: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 4 /* 18: ArraySet < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 54: ArraySet < Set: superclass init_table position */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 3 /* 59: ArraySet < Collection: superclass init_table position */},
  {(bigint) array___ArraySet___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) array___ArraySet___is_empty},
  {(bigint) array___ArraySet___length},
  {(bigint) array___ArraySet___has},
  {(bigint) abstract_collection___Set___has_only},
  {(bigint) abstract_collection___Set___count},
  {(bigint) array___ArraySet___first},
  {(bigint) 2 /* 68: ArraySet < RemovableCollection: superclass init_table position */},
  {(bigint) array___ArraySet___clear},
  {(bigint) array___ArraySet___remove},
  {(bigint) array___ArraySet___remove_all},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 75: ArraySet < SimpleCollection: superclass init_table position */},
  {(bigint) array___ArraySet___add},
  {(bigint) abstract_collection___SimpleCollection___add_all},
  {(bigint) 5 /* 78: ArraySet < ArraySet: superclass init_table position */},
  {(bigint) array___ArraySet___enlarge},
  {(bigint) array___ArraySet___remove_at},
  {(bigint) array___ArraySet___init},
  {(bigint) array___ArraySet___with_capacity},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArraySet::_array */
void INIT_ATTRIBUTES__ArraySet(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ArraySet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArraySet(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_ArraySet;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ArraySet(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ArraySet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_array___ArraySet____array(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_array", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArraySet_array___ArraySet___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 456;
  fra.me.meth = LOCATE_NEW_ArraySet_array___ArraySet___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:456 */
  fra.me.REG[0] = NEW_ArraySet();
  INIT_ATTRIBUTES__ArraySet(fra.me.REG[0]);
  array___ArraySet___init(fra.me.REG[0], init_table);
  CHECKNEW_ArraySet(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
val_t NEW_ArraySet_array___ArraySet___with_capacity(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 459;
  fra.me.meth = LOCATE_NEW_ArraySet_array___ArraySet___with_capacity;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:459 */
  fra.me.REG[0] = NEW_ArraySet();
  INIT_ATTRIBUTES__ArraySet(fra.me.REG[0]);
  array___ArraySet___with_capacity(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_ArraySet(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_ArraySetIterator[49] = {
  {(bigint) 171 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ArraySetIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: ArraySetIterator < Iterator: superclass typecheck marker */},
  {(bigint) 171 /* 4: ArraySetIterator < ArraySetIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: ArraySetIterator < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 0 /* 43: ArraySetIterator < Iterator: superclass init_table position */},
  {(bigint) array___ArraySetIterator___item},
  {(bigint) array___ArraySetIterator___next},
  {(bigint) array___ArraySetIterator___is_ok},
  {(bigint) 2 /* 47: ArraySetIterator < ArraySetIterator: superclass init_table position */},
  {(bigint) array___ArraySetIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArraySetIterator::_iter */
void INIT_ATTRIBUTES__ArraySetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ArraySetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArraySetIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_ArraySetIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ArraySetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ArraySetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_array___ArraySetIterator____iter(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_iter", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArraySetIterator_array___ArraySetIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 473;
  fra.me.meth = LOCATE_NEW_ArraySetIterator_array___ArraySetIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:473 */
  fra.me.REG[1] = NEW_ArraySetIterator();
  INIT_ATTRIBUTES__ArraySetIterator(fra.me.REG[1]);
  array___ArraySetIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_ArraySetIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_ArrayMap[93] = {
  {(bigint) 315 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ArrayMap < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 67 /* 5: ArrayMap < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: ArrayMap < RemovableCollection: superclass typecheck marker */},
  {(bigint) 107 /* 7: ArrayMap < MapRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 199 /* 10: ArrayMap < Map: superclass typecheck marker */},
  {(bigint) 279 /* 11: ArrayMap < CoupleMap: superclass typecheck marker */},
  {(bigint) 315 /* 12: ArrayMap < ArrayMap: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 5 /* 18: ArrayMap < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 4 /* 59: ArrayMap < Collection: superclass init_table position */},
  {(bigint) array___ArrayMap___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) array___ArrayMap___is_empty},
  {(bigint) array___ArrayMap___length},
  {(bigint) array___ArrayMap___has},
  {(bigint) array___ArrayMap___has_only},
  {(bigint) array___ArrayMap___count},
  {(bigint) array___ArrayMap___first},
  {(bigint) 2 /* 68: ArrayMap < RemovableCollection: superclass init_table position */},
  {(bigint) array___ArrayMap___clear},
  {(bigint) array___ArrayMap___remove},
  {(bigint) array___ArrayMap___remove_all},
  {(bigint) 3 /* 72: ArrayMap < MapRead: superclass init_table position */},
  {(bigint) array___ArrayMap_____bra},
  {(bigint) array___ArrayMap___has_key},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Map___map_join},
  {(bigint) 1 /* 82: ArrayMap < Map: superclass init_table position */},
  {(bigint) array___ArrayMap_____braeq},
  {(bigint) array___ArrayMap___remove_at},
  {(bigint) abstract_collection___Map___recover_with},
  {(bigint) 0 /* 86: ArrayMap < CoupleMap: superclass init_table position */},
  {(bigint) array___ArrayMap___couple_at},
  {(bigint) 6 /* 88: ArrayMap < ArrayMap: superclass init_table position */},
  {(bigint) array___ArrayMap___enlarge},
  {(bigint) array___ArrayMap___remove_at_index},
  {(bigint) array___ArrayMap___index},
  {(bigint) array___ArrayMap___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArrayMap::_items */
/* 3: Attribute ArrayMap::_last_index */
void INIT_ATTRIBUTES__ArrayMap(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ArrayMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:594 */
  REGB0 = TAG_Int(0);
  ATTR_array___ArrayMap____last_index(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArrayMap(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_ArrayMap;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ArrayMap(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ArrayMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_array___ArrayMap____items(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_items", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_array___ArrayMap____last_index(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_last_index", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_ArrayMap_array___ArrayMap___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 614;
  fra.me.meth = LOCATE_NEW_ArrayMap_array___ArrayMap___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:614 */
  fra.me.REG[0] = NEW_ArrayMap();
  INIT_ATTRIBUTES__ArrayMap(fra.me.REG[0]);
  array___ArrayMap___init(fra.me.REG[0], init_table);
  CHECKNEW_ArrayMap(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_NativeArray[46] = {
  {(bigint) 31 /* 0: Identity */},
  {(bigint) -1 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: NativeArray < Object: superclass typecheck marker */},
  {(bigint) 31 /* 3: NativeArray < NativeArray: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: NativeArray < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: NativeArray < NativeArray: superclass init_table position */},
  {(bigint) array___NativeArray_____bra},
  {(bigint) array___NativeArray_____braeq},
  {(bigint) array___NativeArray___copy_to},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t NEW_NativeArray(size_t length, size_t size) {
  Nit_NativeArray array;
  array = (Nit_NativeArray)alloc(sizeof(struct Nit_NativeArray) + ((length - 1) * size));
  array->vft = (classtable_elt_t*)VFT_NativeArray;
  array->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  array->size = length;
  return OBJ2VAL(array);
}
const classtable_elt_t VFT_AbstractSorter[49] = {
  {(bigint) 75 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: AbstractSorter < Object: superclass typecheck marker */},
  {(bigint) 75 /* 3: AbstractSorter < AbstractSorter: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: AbstractSorter < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: AbstractSorter < AbstractSorter: superclass init_table position */},
  {(bigint) sorter___AbstractSorter___compare},
  {(bigint) sorter___AbstractSorter___sort},
  {(bigint) sorter___AbstractSorter___sub_sort},
  {(bigint) sorter___AbstractSorter___quick_sort},
  {(bigint) sorter___AbstractSorter___bubble_sort},
  {(bigint) sorter___AbstractSorter___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__AbstractSorter(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__AbstractSorter;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_AbstractSorter(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_AbstractSorter;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_AbstractSorter(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_AbstractSorter;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_AbstractSorter_sorter___AbstractSorter___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_AbstractSorter_sorter___AbstractSorter___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_AbstractSorter();
  INIT_ATTRIBUTES__AbstractSorter(fra.me.REG[0]);
  sorter___AbstractSorter___init(fra.me.REG[0], init_table);
  CHECKNEW_AbstractSorter(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_ComparableSorter[51] = {
  {(bigint) 159 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: ComparableSorter < Object: superclass typecheck marker */},
  {(bigint) 75 /* 3: ComparableSorter < AbstractSorter: superclass typecheck marker */},
  {(bigint) 159 /* 4: ComparableSorter < ComparableSorter: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: ComparableSorter < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: ComparableSorter < AbstractSorter: superclass init_table position */},
  {(bigint) sorter___ComparableSorter___compare},
  {(bigint) sorter___AbstractSorter___sort},
  {(bigint) sorter___AbstractSorter___sub_sort},
  {(bigint) sorter___AbstractSorter___quick_sort},
  {(bigint) sorter___AbstractSorter___bubble_sort},
  {(bigint) sorter___AbstractSorter___init},
  {(bigint) 2 /* 49: ComparableSorter < ComparableSorter: superclass init_table position */},
  {(bigint) sorter___ComparableSorter___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__ComparableSorter(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__ComparableSorter;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ComparableSorter(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_ComparableSorter;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_ComparableSorter(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_ComparableSorter;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_ComparableSorter_sorter___ComparableSorter___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 96;
  fra.me.meth = LOCATE_NEW_ComparableSorter_sorter___ComparableSorter___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//collection//sorter.nit:96 */
  fra.me.REG[0] = NEW_ComparableSorter();
  INIT_ATTRIBUTES__ComparableSorter(fra.me.REG[0]);
  sorter___ComparableSorter___init(fra.me.REG[0], init_table);
  CHECKNEW_ComparableSorter(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_HashCollection[68] = {
  {(bigint) 135 /* 0: Identity */},
  {(bigint) 9 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashCollection < Object: superclass typecheck marker */},
  {(bigint) 71 /* 3: HashCollection < ArrayCapable: superclass typecheck marker */},
  {(bigint) 135 /* 4: HashCollection < HashCollection: superclass typecheck marker */},
  {(bigint) 67 /* 5: HashCollection < Collection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: HashCollection < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: HashCollection < ArrayCapable: superclass init_table position */},
  {(bigint) array___ArrayCapable___calloc_array},
  {(bigint) 3 /* 44: HashCollection < HashCollection: superclass init_table position */},
  {(bigint) hash_collection___HashCollection___first_item},
  {(bigint) hash_collection___HashCollection___index_at},
  {(bigint) hash_collection___HashCollection___node_at},
  {(bigint) hash_collection___HashCollection___node_at_idx},
  {(bigint) hash_collection___HashCollection___store},
  {(bigint) hash_collection___HashCollection___remove_node},
  {(bigint) hash_collection___HashCollection___raz},
  {(bigint) hash_collection___HashCollection___enlarge},
  {(bigint) hash_collection___HashCollection___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 0 /* 59: HashCollection < Collection: superclass init_table position */},
  {(bigint) abstract_collection___Collection___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) abstract_collection___Collection___is_empty},
  {(bigint) hash_collection___HashCollection___length},
  {(bigint) abstract_collection___Collection___has},
  {(bigint) abstract_collection___Collection___has_only},
  {(bigint) abstract_collection___Collection___count},
  {(bigint) abstract_collection___Collection___first},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashCollection::_array */
/* 3: Attribute HashCollection::_capacity */
/* 4: Attribute HashCollection::_length */
/* 5: Attribute HashCollection::_first_item */
/* 6: Attribute HashCollection::_last_item */
/* 7: Attribute HashCollection::_last_accessed_key */
/* 8: Attribute HashCollection::_last_accessed_node */
void INIT_ATTRIBUTES__HashCollection(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashCollection;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:23 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____array(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_hash_collection___HashCollection____capacity(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:25 */
  REGB0 = TAG_Int(0);
  ATTR_hash_collection___HashCollection____length(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:27 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____first_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:28 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:30 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_accessed_key(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:33 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_accessed_node(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashCollection(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 9);
  obj->vft = (classtable_elt_t*)VFT_HashCollection;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashCollection(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashCollection;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashCollection____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_hash_collection___HashCollection____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashCollection_hash_collection___HashCollection___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_HashCollection_hash_collection___HashCollection___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_HashCollection();
  INIT_ATTRIBUTES__HashCollection(fra.me.REG[0]);
  hash_collection___HashCollection___init(fra.me.REG[0], init_table);
  CHECKNEW_HashCollection(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_HashNode[48] = {
  {(bigint) 47 /* 0: Identity */},
  {(bigint) 7 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashNode < Object: superclass typecheck marker */},
  {(bigint) 47 /* 3: HashNode < HashNode: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: HashNode < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: HashNode < HashNode: superclass init_table position */},
  {(bigint) hash_collection___HashNode___next_item},
  {(bigint) hash_collection___HashNode___next_item__eq},
  {(bigint) hash_collection___HashNode___prev_item},
  {(bigint) hash_collection___HashNode___prev_item__eq},
  {(bigint) hash_collection___HashNode___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashNode::_key */
/* 3: Attribute HashNode::_next_item */
/* 4: Attribute HashNode::_prev_item */
/* 5: Attribute HashNode::_prev_in_bucklet */
/* 6: Attribute HashNode::_next_in_bucklet */
void INIT_ATTRIBUTES__HashNode(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:190 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____next_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:191 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____prev_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:192 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____prev_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:193 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____next_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashNode(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 7);
  obj->vft = (classtable_elt_t*)VFT_HashNode;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashNode____key(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_key", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashNode_hash_collection___HashNode___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 194;
  fra.me.meth = LOCATE_NEW_HashNode_hash_collection___HashNode___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:194 */
  fra.me.REG[1] = NEW_HashNode();
  INIT_ATTRIBUTES__HashNode(fra.me.REG[1]);
  hash_collection___HashNode___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_HashNode(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_HashMap[86] = {
  {(bigint) 271 /* 0: Identity */},
  {(bigint) 9 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashMap < Object: superclass typecheck marker */},
  {(bigint) 71 /* 3: HashMap < ArrayCapable: superclass typecheck marker */},
  {(bigint) 135 /* 4: HashMap < HashCollection: superclass typecheck marker */},
  {(bigint) 67 /* 5: HashMap < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: HashMap < RemovableCollection: superclass typecheck marker */},
  {(bigint) 107 /* 7: HashMap < MapRead: superclass typecheck marker */},
  {(bigint) 271 /* 8: HashMap < HashMap: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 199 /* 10: HashMap < Map: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 4 /* 18: HashMap < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 5 /* 42: HashMap < ArrayCapable: superclass init_table position */},
  {(bigint) array___ArrayCapable___calloc_array},
  {(bigint) 6 /* 44: HashMap < HashCollection: superclass init_table position */},
  {(bigint) hash_collection___HashCollection___first_item},
  {(bigint) hash_collection___HashCollection___index_at},
  {(bigint) hash_collection___HashCollection___node_at},
  {(bigint) hash_collection___HashCollection___node_at_idx},
  {(bigint) hash_collection___HashCollection___store},
  {(bigint) hash_collection___HashCollection___remove_node},
  {(bigint) hash_collection___HashCollection___raz},
  {(bigint) hash_collection___HashCollection___enlarge},
  {(bigint) hash_collection___HashCollection___init},
  {(bigint) 7 /* 54: HashMap < HashMap: superclass init_table position */},
  {(bigint) hash_collection___HashMap___init},
  {0} /* Class Hole :( */,
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 3 /* 59: HashMap < Collection: superclass init_table position */},
  {(bigint) hash_collection___HashMap___iterator},
  {(bigint) hash_collection___HashMap___iterate},
  {(bigint) hash_collection___HashMap___is_empty},
  {(bigint) hash_collection___HashCollection___length},
  {(bigint) hash_collection___HashMap___has},
  {(bigint) hash_collection___HashMap___has_only},
  {(bigint) hash_collection___HashMap___count},
  {(bigint) hash_collection___HashMap___first},
  {(bigint) 1 /* 68: HashMap < RemovableCollection: superclass init_table position */},
  {(bigint) hash_collection___HashMap___clear},
  {(bigint) hash_collection___HashMap___remove},
  {(bigint) abstract_collection___RemovableCollection___remove_all},
  {(bigint) 2 /* 72: HashMap < MapRead: superclass init_table position */},
  {(bigint) hash_collection___HashMap_____bra},
  {(bigint) hash_collection___HashMap___has_key},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) string___Map___map_join},
  {(bigint) 0 /* 82: HashMap < Map: superclass init_table position */},
  {(bigint) hash_collection___HashMap_____braeq},
  {(bigint) hash_collection___HashMap___remove_at},
  {(bigint) abstract_collection___Map___recover_with},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMap::_array */
/* 3: Attribute HashMap::_capacity */
/* 4: Attribute HashMap::_length */
/* 5: Attribute HashMap::_first_item */
/* 6: Attribute HashMap::_last_item */
/* 7: Attribute HashMap::_last_accessed_key */
/* 8: Attribute HashMap::_last_accessed_node */
void INIT_ATTRIBUTES__HashMap(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:23 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____array(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_hash_collection___HashCollection____capacity(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:25 */
  REGB0 = TAG_Int(0);
  ATTR_hash_collection___HashCollection____length(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:27 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____first_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:28 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:30 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_accessed_key(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:33 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_accessed_node(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashMap(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 9);
  obj->vft = (classtable_elt_t*)VFT_HashMap;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashMap(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashCollection____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_hash_collection___HashCollection____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashMap_hash_collection___HashMap___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 295;
  fra.me.meth = LOCATE_NEW_HashMap_hash_collection___HashMap___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:295 */
  fra.me.REG[0] = NEW_HashMap();
  INIT_ATTRIBUTES__HashMap(fra.me.REG[0]);
  hash_collection___HashMap___init(fra.me.REG[0], init_table);
  CHECKNEW_HashMap(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_HashMapNode[50] = {
  {(bigint) 131 /* 0: Identity */},
  {(bigint) 8 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashMapNode < Object: superclass typecheck marker */},
  {(bigint) 47 /* 3: HashMapNode < HashNode: superclass typecheck marker */},
  {(bigint) 131 /* 4: HashMapNode < HashMapNode: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: HashMapNode < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: HashMapNode < HashNode: superclass init_table position */},
  {(bigint) hash_collection___HashNode___next_item},
  {(bigint) hash_collection___HashNode___next_item__eq},
  {(bigint) hash_collection___HashNode___prev_item},
  {(bigint) hash_collection___HashNode___prev_item__eq},
  {(bigint) hash_collection___HashNode___init},
  {(bigint) 2 /* 48: HashMapNode < HashMapNode: superclass init_table position */},
  {(bigint) hash_collection___HashMapNode___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMapNode::_key */
/* 3: Attribute HashMapNode::_next_item */
/* 4: Attribute HashMapNode::_prev_item */
/* 5: Attribute HashMapNode::_prev_in_bucklet */
/* 6: Attribute HashMapNode::_next_in_bucklet */
/* 7: Attribute HashMapNode::_value */
void INIT_ATTRIBUTES__HashMapNode(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashMapNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:190 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____next_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:191 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____prev_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:192 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____prev_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:193 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____next_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashMapNode(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 8);
  obj->vft = (classtable_elt_t*)VFT_HashMapNode;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashMapNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashMapNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashNode____key(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_key", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashMapNode_hash_collection___HashMapNode___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 308;
  fra.me.meth = LOCATE_NEW_HashMapNode_hash_collection___HashMapNode___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:308 */
  fra.me.REG[2] = NEW_HashMapNode();
  INIT_ATTRIBUTES__HashMapNode(fra.me.REG[2]);
  hash_collection___HashMapNode___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_HashMapNode(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_HashMapIterator[51] = {
  {(bigint) 219 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashMapIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: HashMapIterator < Iterator: superclass typecheck marker */},
  {(bigint) 111 /* 4: HashMapIterator < MapIterator: superclass typecheck marker */},
  {(bigint) 219 /* 5: HashMapIterator < HashMapIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 2 /* 18: HashMapIterator < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 1 /* 43: HashMapIterator < Iterator: superclass init_table position */},
  {(bigint) hash_collection___HashMapIterator___item},
  {(bigint) hash_collection___HashMapIterator___next},
  {(bigint) hash_collection___HashMapIterator___is_ok},
  {(bigint) 0 /* 47: HashMapIterator < MapIterator: superclass init_table position */},
  {(bigint) hash_collection___HashMapIterator___key},
  {(bigint) 3 /* 49: HashMapIterator < HashMapIterator: superclass init_table position */},
  {(bigint) hash_collection___HashMapIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMapIterator::_map */
/* 3: Attribute HashMapIterator::_node */
void INIT_ATTRIBUTES__HashMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashMapIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_HashMapIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashMapIterator____map(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_map", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashMapIterator_hash_collection___HashMapIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 349;
  fra.me.meth = LOCATE_NEW_HashMapIterator_hash_collection___HashMapIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:349 */
  fra.me.REG[1] = NEW_HashMapIterator();
  INIT_ATTRIBUTES__HashMapIterator(fra.me.REG[1]);
  hash_collection___HashMapIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_HashMapIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_HashSet[78] = {
  {(bigint) 307 /* 0: Identity */},
  {(bigint) 9 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashSet < Object: superclass typecheck marker */},
  {(bigint) 71 /* 3: HashSet < ArrayCapable: superclass typecheck marker */},
  {(bigint) 135 /* 4: HashSet < HashCollection: superclass typecheck marker */},
  {(bigint) 67 /* 5: HashSet < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: HashSet < RemovableCollection: superclass typecheck marker */},
  {(bigint) 247 /* 7: HashSet < Set: superclass typecheck marker */},
  {(bigint) 179 /* 8: HashSet < SimpleCollection: superclass typecheck marker */},
  {(bigint) 307 /* 9: HashSet < HashSet: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 4 /* 18: HashSet < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Collection___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 5 /* 42: HashSet < ArrayCapable: superclass init_table position */},
  {(bigint) array___ArrayCapable___calloc_array},
  {(bigint) 6 /* 44: HashSet < HashCollection: superclass init_table position */},
  {(bigint) hash_collection___HashCollection___first_item},
  {(bigint) hash_collection___HashCollection___index_at},
  {(bigint) hash_collection___HashCollection___node_at},
  {(bigint) hash_collection___HashCollection___node_at_idx},
  {(bigint) hash_collection___HashCollection___store},
  {(bigint) hash_collection___HashCollection___remove_node},
  {(bigint) hash_collection___HashCollection___raz},
  {(bigint) hash_collection___HashCollection___enlarge},
  {(bigint) hash_collection___HashCollection___init},
  {(bigint) 0 /* 54: HashSet < Set: superclass init_table position */},
  {(bigint) 7 /* 55: HashSet < HashSet: superclass init_table position */},
  {(bigint) hash_collection___HashSet___init},
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 3 /* 59: HashSet < Collection: superclass init_table position */},
  {(bigint) hash_collection___HashSet___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) hash_collection___HashSet___is_empty},
  {(bigint) hash_collection___HashCollection___length},
  {(bigint) hash_collection___HashSet___has},
  {(bigint) abstract_collection___Set___has_only},
  {(bigint) abstract_collection___Set___count},
  {(bigint) hash_collection___HashSet___first},
  {(bigint) 2 /* 68: HashSet < RemovableCollection: superclass init_table position */},
  {(bigint) hash_collection___HashSet___clear},
  {(bigint) hash_collection___HashSet___remove},
  {(bigint) abstract_collection___Set___remove_all},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 75: HashSet < SimpleCollection: superclass init_table position */},
  {(bigint) hash_collection___HashSet___add},
  {(bigint) abstract_collection___SimpleCollection___add_all},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashSet::_array */
/* 3: Attribute HashSet::_capacity */
/* 4: Attribute HashSet::_length */
/* 5: Attribute HashSet::_first_item */
/* 6: Attribute HashSet::_last_item */
/* 7: Attribute HashSet::_last_accessed_key */
/* 8: Attribute HashSet::_last_accessed_node */
void INIT_ATTRIBUTES__HashSet(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashSet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:23 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____array(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_hash_collection___HashCollection____capacity(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:25 */
  REGB0 = TAG_Int(0);
  ATTR_hash_collection___HashCollection____length(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:27 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____first_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:28 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:30 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_accessed_key(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:33 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashCollection____last_accessed_node(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashSet(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 9);
  obj->vft = (classtable_elt_t*)VFT_HashSet;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashSet(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashSet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashCollection____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_hash_collection___HashCollection____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashSet_hash_collection___HashSet___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 390;
  fra.me.meth = LOCATE_NEW_HashSet_hash_collection___HashSet___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:390 */
  fra.me.REG[0] = NEW_HashSet();
  INIT_ATTRIBUTES__HashSet(fra.me.REG[0]);
  hash_collection___HashSet___init(fra.me.REG[0], init_table);
  CHECKNEW_HashSet(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_HashSetNode[50] = {
  {(bigint) 123 /* 0: Identity */},
  {(bigint) 7 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashSetNode < Object: superclass typecheck marker */},
  {(bigint) 47 /* 3: HashSetNode < HashNode: superclass typecheck marker */},
  {(bigint) 123 /* 4: HashSetNode < HashSetNode: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: HashSetNode < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: HashSetNode < HashNode: superclass init_table position */},
  {(bigint) hash_collection___HashNode___next_item},
  {(bigint) hash_collection___HashNode___next_item__eq},
  {(bigint) hash_collection___HashNode___prev_item},
  {(bigint) hash_collection___HashNode___prev_item__eq},
  {(bigint) hash_collection___HashNode___init},
  {(bigint) 2 /* 48: HashSetNode < HashSetNode: superclass init_table position */},
  {(bigint) hash_collection___HashSetNode___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashSetNode::_key */
/* 3: Attribute HashSetNode::_next_item */
/* 4: Attribute HashSetNode::_prev_item */
/* 5: Attribute HashSetNode::_prev_in_bucklet */
/* 6: Attribute HashSetNode::_next_in_bucklet */
void INIT_ATTRIBUTES__HashSetNode(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashSetNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:190 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____next_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:191 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____prev_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:192 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____prev_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:193 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_hash_collection___HashNode____next_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashSetNode(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 7);
  obj->vft = (classtable_elt_t*)VFT_HashSetNode;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashSetNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashSetNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashNode____key(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_key", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashSetNode_hash_collection___HashSetNode___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 402;
  fra.me.meth = LOCATE_NEW_HashSetNode_hash_collection___HashSetNode___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:402 */
  fra.me.REG[1] = NEW_HashSetNode();
  INIT_ATTRIBUTES__HashSetNode(fra.me.REG[1]);
  hash_collection___HashSetNode___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_HashSetNode(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_HashSetIterator[49] = {
  {(bigint) 127 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: HashSetIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 3: HashSetIterator < Iterator: superclass typecheck marker */},
  {(bigint) 127 /* 4: HashSetIterator < HashSetIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: HashSetIterator < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) array___Iterator___to_a},
  {(bigint) 0 /* 43: HashSetIterator < Iterator: superclass init_table position */},
  {(bigint) hash_collection___HashSetIterator___item},
  {(bigint) hash_collection___HashSetIterator___next},
  {(bigint) hash_collection___HashSetIterator___is_ok},
  {(bigint) 2 /* 47: HashSetIterator < HashSetIterator: superclass init_table position */},
  {(bigint) hash_collection___HashSetIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashSetIterator::_set */
/* 3: Attribute HashSetIterator::_node */
void INIT_ATTRIBUTES__HashSetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__HashSetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashSetIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_HashSetIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_HashSetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_HashSetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_hash_collection___HashSetIterator____set(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_set", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_HashSetIterator_hash_collection___HashSetIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 430;
  fra.me.meth = LOCATE_NEW_HashSetIterator_hash_collection___HashSetIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//hash_collection.nit:430 */
  fra.me.REG[1] = NEW_HashSetIterator();
  INIT_ATTRIBUTES__HashSetIterator(fra.me.REG[1]);
  hash_collection___HashSetIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_HashSetIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_String[133] = {
  {(bigint) 327 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: String < Object: superclass typecheck marker */},
  {(bigint) 23 /* 3: String < Pattern: superclass typecheck marker */},
  {(bigint) 63 /* 4: String < Comparable: superclass typecheck marker */},
  {(bigint) 67 /* 5: String < Collection: superclass typecheck marker */},
  {(bigint) 327 /* 6: String < String: superclass typecheck marker */},
  {(bigint) 107 /* 7: String < MapRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 183 /* 9: String < SequenceRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 287 /* 12: String < AbstractArrayRead: superclass typecheck marker */},
  {(bigint) 319 /* 13: String < AbstractString: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: String < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) string___String_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) string___AbstractString___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___String___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) string___String___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 7 /* 42: String < Pattern: superclass init_table position */},
  {(bigint) string_search___String___search_index_in},
  {(bigint) string_search___String___search_in},
  {(bigint) string_search___Pattern___search_all_in},
  {(bigint) string_search___Pattern___split_in},
  {(bigint) string_search___Pattern___init},
  {(bigint) 0 /* 48: String < Comparable: superclass init_table position */},
  {(bigint) string___String_____l},
  {(bigint) kernel___Comparable_____leq},
  {(bigint) kernel___Comparable_____geq},
  {(bigint) kernel___Comparable_____g},
  {(bigint) kernel___Comparable_____leqg},
  {(bigint) kernel___Comparable___is_between},
  {(bigint) kernel___Comparable___max},
  {(bigint) kernel___Comparable___min},
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 5 /* 59: String < Collection: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) array___AbstractArrayRead___is_empty},
  {(bigint) array___AbstractArrayRead___length},
  {(bigint) array___AbstractArrayRead___has},
  {(bigint) array___AbstractArrayRead___has_only},
  {(bigint) array___AbstractArrayRead___count},
  {(bigint) abstract_collection___SequenceRead___first},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 72: String < MapRead: superclass init_table position */},
  {(bigint) string___AbstractString_____bra},
  {(bigint) array___AbstractArrayRead___has_key},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 3 /* 78: String < SequenceRead: superclass init_table position */},
  {(bigint) abstract_collection___SequenceRead___last},
  {(bigint) array___AbstractArrayRead___index_of},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 6 /* 94: String < AbstractArrayRead: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___last_index_of},
  {(bigint) array___AbstractArrayRead___index_of_from},
  {(bigint) array___AbstractArrayRead___last_index_of_from},
  {(bigint) array___AbstractArrayRead___reversed},
  {(bigint) array___AbstractArrayRead___copy_to},
  {(bigint) array___AbstractArrayRead___init},
  {(bigint) 2 /* 101: String < AbstractString: superclass init_table position */},
  {(bigint) string___AbstractString___items},
  {(bigint) string___AbstractString___substring},
  {(bigint) string___AbstractString___substring_from},
  {(bigint) string___AbstractString___has_substring},
  {(bigint) string___AbstractString___has_prefix},
  {(bigint) string___AbstractString___has_suffix},
  {(bigint) string___AbstractString___to_i},
  {(bigint) string___AbstractString___to_hex},
  {(bigint) string___AbstractString___a_to},
  {(bigint) string___AbstractString___to_upper},
  {(bigint) string___AbstractString___to_lower},
  {(bigint) symbol___String___to_symbol},
  {(bigint) 8 /* 114: String < String: superclass init_table position */},
  {(bigint) string___String___with_native},
  {(bigint) string___String___from_cstring},
  {(bigint) string___String___to_cstring},
  {(bigint) string___String_____plus},
  {(bigint) string___String_____star},
  {(bigint) file___String___file_exists},
  {(bigint) file___String___file_stat},
  {(bigint) file___String___file_delete},
  {(bigint) file___String___strip_extension},
  {(bigint) file___String___basename},
  {(bigint) file___String___dirname},
  {(bigint) file___String___file_path},
  {(bigint) file___String___mkdir},
  {(bigint) string_search___String___search},
  {(bigint) string_search___String___search_from},
  {(bigint) string_search___String___search_all},
  {(bigint) string_search___String___split_with},
  {(bigint) string_search___String___split},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute String::_length */
/* 3: Attribute String::_items */
void INIT_ATTRIBUTES__String(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__String;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_String(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_String;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_String(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_String;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_string___AbstractString____items(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_items", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_String_string___String___with_native(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 167;
  fra.me.meth = LOCATE_NEW_String_string___String___with_native;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  /* /Users/tony/Projects/nit/lib/standard//string.nit:167 */
  fra.me.REG[1] = NEW_String();
  INIT_ATTRIBUTES__String(fra.me.REG[1]);
  string___String___with_native(fra.me.REG[1], fra.me.REG[0], REGB0, init_table);
  CHECKNEW_String(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
val_t NEW_String_string___String___from_cstring(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 175;
  fra.me.meth = LOCATE_NEW_String_string___String___from_cstring;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//string.nit:175 */
  fra.me.REG[1] = NEW_String();
  INIT_ATTRIBUTES__String(fra.me.REG[1]);
  string___String___from_cstring(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_String(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Buffer[119] = {
  {(bigint) 335 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Buffer < Object: superclass typecheck marker */},
  {(bigint) 15 /* 3: Buffer < StringCapable: superclass typecheck marker */},
  {(bigint) 63 /* 4: Buffer < Comparable: superclass typecheck marker */},
  {(bigint) 67 /* 5: Buffer < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 6: Buffer < RemovableCollection: superclass typecheck marker */},
  {(bigint) 107 /* 7: Buffer < MapRead: superclass typecheck marker */},
  {(bigint) 179 /* 8: Buffer < SimpleCollection: superclass typecheck marker */},
  {(bigint) 183 /* 9: Buffer < SequenceRead: superclass typecheck marker */},
  {(bigint) 199 /* 10: Buffer < Map: superclass typecheck marker */},
  {(bigint) 251 /* 11: Buffer < Sequence: superclass typecheck marker */},
  {(bigint) 287 /* 12: Buffer < AbstractArrayRead: superclass typecheck marker */},
  {(bigint) 319 /* 13: Buffer < AbstractString: superclass typecheck marker */},
  {(bigint) 323 /* 14: Buffer < AbstractArray: superclass typecheck marker */},
  {(bigint) 335 /* 15: Buffer < Buffer: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 4 /* 18: Buffer < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) string___Buffer_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) string___AbstractString___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Buffer___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 7 /* 42: Buffer < StringCapable: superclass init_table position */},
  {(bigint) string___StringCapable___calloc_string},
  {(bigint) string___StringCapable___init},
  {(bigint) 12 /* 45: Buffer < AbstractArray: superclass init_table position */},
  {(bigint) string___Buffer___enlarge},
  {(bigint) array___AbstractArray___insert},
  {(bigint) 6 /* 48: Buffer < Comparable: superclass init_table position */},
  {(bigint) string___Buffer_____l},
  {(bigint) kernel___Comparable_____leq},
  {(bigint) kernel___Comparable_____geq},
  {(bigint) kernel___Comparable_____g},
  {(bigint) kernel___Comparable_____leqg},
  {(bigint) kernel___Comparable___is_between},
  {(bigint) kernel___Comparable___max},
  {(bigint) kernel___Comparable___min},
  {(bigint) string___Collection___join},
  {(bigint) array___Collection___to_a},
  {(bigint) 3 /* 59: Buffer < Collection: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___iterator},
  {(bigint) abstract_collection___Collection___iterate},
  {(bigint) array___AbstractArrayRead___is_empty},
  {(bigint) array___AbstractArrayRead___length},
  {(bigint) array___AbstractArrayRead___has},
  {(bigint) array___AbstractArrayRead___has_only},
  {(bigint) array___AbstractArrayRead___count},
  {(bigint) abstract_collection___SequenceRead___first},
  {(bigint) 11 /* 68: Buffer < RemovableCollection: superclass init_table position */},
  {(bigint) array___AbstractArray___clear},
  {(bigint) array___AbstractArray___remove},
  {(bigint) array___AbstractArray___remove_all},
  {(bigint) 2 /* 72: Buffer < MapRead: superclass init_table position */},
  {(bigint) string___AbstractString_____bra},
  {(bigint) array___AbstractArrayRead___has_key},
  {(bigint) 10 /* 75: Buffer < SimpleCollection: superclass init_table position */},
  {(bigint) string___Buffer___add},
  {(bigint) abstract_collection___SimpleCollection___add_all},
  {(bigint) 1 /* 78: Buffer < SequenceRead: superclass init_table position */},
  {(bigint) abstract_collection___SequenceRead___last},
  {(bigint) array___AbstractArrayRead___index_of},
  {(bigint) string___Map___map_join},
  {(bigint) 9 /* 82: Buffer < Map: superclass init_table position */},
  {(bigint) string___Buffer_____braeq},
  {(bigint) array___AbstractArray___remove_at},
  {(bigint) abstract_collection___Map___recover_with},
  {(bigint) 8 /* 86: Buffer < Sequence: superclass init_table position */},
  {(bigint) abstract_collection___Sequence___first__eq},
  {(bigint) abstract_collection___Sequence___last__eq},
  {(bigint) array___AbstractArray___push},
  {(bigint) string___Buffer___append},
  {(bigint) array___AbstractArray___pop},
  {(bigint) array___AbstractArray___unshift},
  {(bigint) array___AbstractArray___shift},
  {(bigint) 5 /* 94: Buffer < AbstractArrayRead: superclass init_table position */},
  {(bigint) array___AbstractArrayRead___last_index_of},
  {(bigint) array___AbstractArrayRead___index_of_from},
  {(bigint) array___AbstractArrayRead___last_index_of_from},
  {(bigint) array___AbstractArrayRead___reversed},
  {(bigint) array___AbstractArrayRead___copy_to},
  {(bigint) array___AbstractArrayRead___init},
  {(bigint) 0 /* 101: Buffer < AbstractString: superclass init_table position */},
  {(bigint) string___AbstractString___items},
  {(bigint) string___AbstractString___substring},
  {(bigint) string___AbstractString___substring_from},
  {(bigint) string___AbstractString___has_substring},
  {(bigint) string___AbstractString___has_prefix},
  {(bigint) string___AbstractString___has_suffix},
  {(bigint) string___AbstractString___to_i},
  {(bigint) string___AbstractString___to_hex},
  {(bigint) string___AbstractString___a_to},
  {(bigint) string___AbstractString___to_upper},
  {(bigint) string___AbstractString___to_lower},
  {(bigint) 13 /* 113: Buffer < Buffer: superclass init_table position */},
  {(bigint) abstract_collection___Sequence___append},
  {(bigint) string___Buffer___init},
  {(bigint) string___Buffer___from},
  {(bigint) string___Buffer___with_capacity},
  {(bigint) string___Buffer___capacity},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Buffer::_length */
/* 3: Attribute Buffer::_items */
/* 4: Attribute Buffer::_capacity */
void INIT_ATTRIBUTES__Buffer(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Buffer;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//collection//array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Buffer(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_Buffer;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Buffer(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Buffer;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_string___Buffer____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_string___AbstractString____items(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_items", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Buffer_string___Buffer___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[14] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 349;
  fra.me.meth = LOCATE_NEW_Buffer_string___Buffer___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//string.nit:349 */
  fra.me.REG[0] = NEW_Buffer();
  INIT_ATTRIBUTES__Buffer(fra.me.REG[0]);
  string___Buffer___init(fra.me.REG[0], init_table);
  CHECKNEW_Buffer(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
val_t NEW_Buffer_string___Buffer___from(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[14] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 355;
  fra.me.meth = LOCATE_NEW_Buffer_string___Buffer___from;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//string.nit:355 */
  fra.me.REG[1] = NEW_Buffer();
  INIT_ATTRIBUTES__Buffer(fra.me.REG[1]);
  string___Buffer___from(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Buffer(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
val_t NEW_Buffer_string___Buffer___with_capacity(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[14] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 363;
  fra.me.meth = LOCATE_NEW_Buffer_string___Buffer___with_capacity;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /Users/tony/Projects/nit/lib/standard//string.nit:363 */
  fra.me.REG[0] = NEW_Buffer();
  INIT_ATTRIBUTES__Buffer(fra.me.REG[0]);
  string___Buffer___with_capacity(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_Buffer(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_NativeString[55] = {
  {(bigint) -5 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: NativeString < Object: superclass typecheck marker */},
  {(bigint) -5 /* 3: NativeString < NativeString: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: NativeString < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) environ___NativeString___get_environ},
  {(bigint) 1 /* 43: NativeString < NativeString: superclass init_table position */},
  {(bigint) string___NativeString_____bra},
  {(bigint) string___NativeString_____braeq},
  {(bigint) string___NativeString___copy_to},
  {(bigint) string___NativeString___cstring_length},
  {(bigint) string___NativeString___atoi},
  {(bigint) string___NativeString___init},
  {(bigint) file___NativeString___file_exists},
  {(bigint) file___NativeString___file_stat},
  {(bigint) file___NativeString___file_mkdir},
  {(bigint) file___NativeString___file_delete},
  {(bigint) exec___NativeString___system},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_NativeString(char * val) {
  struct TBOX_NativeString *box = (struct TBOX_NativeString*)alloc(sizeof(struct TBOX_NativeString));
  box->vft = VFT_NativeString;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_StringCapable[45] = {
  {(bigint) 15 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: StringCapable < Object: superclass typecheck marker */},
  {(bigint) 15 /* 3: StringCapable < StringCapable: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: StringCapable < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: StringCapable < StringCapable: superclass init_table position */},
  {(bigint) string___StringCapable___calloc_string},
  {(bigint) string___StringCapable___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__StringCapable(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__StringCapable;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_StringCapable(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_StringCapable;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_StringCapable(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_StringCapable;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_StringCapable_string___StringCapable___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_StringCapable_string___StringCapable___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_StringCapable();
  INIT_ATTRIBUTES__StringCapable(fra.me.REG[0]);
  string___StringCapable___init(fra.me.REG[0], init_table);
  CHECKNEW_StringCapable(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_Symbol[45] = {
  {(bigint) 11 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Symbol < Object: superclass typecheck marker */},
  {(bigint) 11 /* 3: Symbol < Symbol: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Symbol < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) symbol___Symbol___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) environ___Symbol___environ},
  {(bigint) 1 /* 43: Symbol < Symbol: superclass init_table position */},
  {(bigint) symbol___Symbol___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Symbol::_string */
void INIT_ATTRIBUTES__Symbol(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Symbol;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Symbol(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Symbol;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Symbol(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Symbol;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_symbol___Symbol____string(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_string", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Symbol_symbol___Symbol___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 39;
  fra.me.meth = LOCATE_NEW_Symbol_symbol___Symbol___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//symbol.nit:39 */
  fra.me.REG[1] = NEW_Symbol();
  INIT_ATTRIBUTES__Symbol(fra.me.REG[1]);
  symbol___Symbol___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Symbol(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_IOS[54] = {
  {(bigint) 43 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: IOS < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 43 /* 4: IOS < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: IOS < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: IOS < IOS: superclass init_table position */},
  {(bigint) stream___IOS___close},
  {(bigint) stream___IOS___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__IOS(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__IOS;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IOS(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_IOS;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_IOS(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_IOS;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IOS_stream___IOS___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_IOS_stream___IOS___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_IOS();
  INIT_ATTRIBUTES__IOS(fra.me.REG[0]);
  stream___IOS___init(fra.me.REG[0], init_table);
  CHECKNEW_IOS(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_IStream[64] = {
  {(bigint) 119 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: IStream < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 43 /* 4: IStream < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 119 /* 6: IStream < IStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: IStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: IStream < IOS: superclass init_table position */},
  {(bigint) stream___IOS___close},
  {(bigint) stream___IOS___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 2 /* 57: IStream < IStream: superclass init_table position */},
  {(bigint) stream___IStream___read_char},
  {(bigint) stream___IStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___IStream___read_all},
  {(bigint) stream___IStream___append_line_to},
  {(bigint) stream___IStream___eof},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__IStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__IStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_IStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_IStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_IStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IStream_stream___IOS___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_IStream_stream___IOS___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_IStream();
  INIT_ATTRIBUTES__IStream(fra.me.REG[0]);
  stream___IOS___init(fra.me.REG[0], init_table);
  CHECKNEW_IStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_OStream[57] = {
  {(bigint) 99 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: OStream < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 43 /* 4: OStream < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: OStream < OStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: OStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: OStream < IOS: superclass init_table position */},
  {(bigint) stream___IOS___close},
  {(bigint) stream___IOS___init},
  {(bigint) 2 /* 54: OStream < OStream: superclass init_table position */},
  {(bigint) stream___OStream___write},
  {(bigint) stream___OStream___is_writable},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__OStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__OStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_OStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_OStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_OStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_OStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_OStream_stream___IOS___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_OStream_stream___IOS___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_OStream();
  INIT_ATTRIBUTES__OStream(fra.me.REG[0]);
  stream___IOS___init(fra.me.REG[0], init_table);
  CHECKNEW_OStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_BufferedIStream[68] = {
  {(bigint) 235 /* 0: Identity */},
  {(bigint) 6 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: BufferedIStream < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 43 /* 4: BufferedIStream < IOS: superclass typecheck marker */},
  {(bigint) 235 /* 5: BufferedIStream < BufferedIStream: superclass typecheck marker */},
  {(bigint) 119 /* 6: BufferedIStream < IStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: BufferedIStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: BufferedIStream < IOS: superclass init_table position */},
  {(bigint) stream___IOS___close},
  {(bigint) stream___IOS___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 2 /* 57: BufferedIStream < IStream: superclass init_table position */},
  {(bigint) stream___BufferedIStream___read_char},
  {(bigint) stream___BufferedIStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___BufferedIStream___read_all},
  {(bigint) stream___BufferedIStream___append_line_to},
  {(bigint) stream___BufferedIStream___eof},
  {(bigint) 3 /* 64: BufferedIStream < BufferedIStream: superclass init_table position */},
  {(bigint) stream___BufferedIStream___fill_buffer},
  {(bigint) stream___BufferedIStream___end_reached},
  {(bigint) stream___BufferedIStream___prepare_buffer},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* Instance Hole :( */
/* Instance Hole :( */
/* 4: Attribute BufferedIStream::_buffer */
/* 5: Attribute BufferedIStream::_buffer_pos */
void INIT_ATTRIBUTES__BufferedIStream(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__BufferedIStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:186 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_stream___BufferedIStream____buffer(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:190 */
  REGB0 = TAG_Int(0);
  ATTR_stream___BufferedIStream____buffer_pos(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_BufferedIStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 6);
  obj->vft = (classtable_elt_t*)VFT_BufferedIStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_BufferedIStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_BufferedIStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_stream___BufferedIStream____buffer_pos(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_buffer_pos", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_BufferedIStream_stream___IOS___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_BufferedIStream_stream___IOS___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_BufferedIStream();
  INIT_ATTRIBUTES__BufferedIStream(fra.me.REG[0]);
  stream___IOS___init(fra.me.REG[0], init_table);
  CHECKNEW_BufferedIStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_IOStream[71] = {
  {(bigint) 215 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: IOStream < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 43 /* 4: IOStream < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: IOStream < OStream: superclass typecheck marker */},
  {(bigint) 119 /* 6: IOStream < IStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 215 /* 9: IOStream < IOStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: IOStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: IOStream < IOS: superclass init_table position */},
  {(bigint) stream___IOS___close},
  {(bigint) stream___IOS___init},
  {(bigint) 3 /* 54: IOStream < OStream: superclass init_table position */},
  {(bigint) stream___OStream___write},
  {(bigint) stream___OStream___is_writable},
  {(bigint) 2 /* 57: IOStream < IStream: superclass init_table position */},
  {(bigint) stream___IStream___read_char},
  {(bigint) stream___IStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___IStream___read_all},
  {(bigint) stream___IStream___append_line_to},
  {(bigint) stream___IStream___eof},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 70: IOStream < IOStream: superclass init_table position */},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__IOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__IOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IOStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_IOStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_IOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_IOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IOStream_stream___IOS___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_IOStream_stream___IOS___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_IOStream();
  INIT_ATTRIBUTES__IOStream(fra.me.REG[0]);
  stream___IOS___init(fra.me.REG[0], init_table);
  CHECKNEW_IOStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_FDStream[54] = {
  {(bigint) 143 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: FDStream < Object: superclass typecheck marker */},
  {(bigint) 143 /* 3: FDStream < FDStream: superclass typecheck marker */},
  {(bigint) 43 /* 4: FDStream < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: FDStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: FDStream < FDStream: superclass init_table position */},
  {(bigint) stream___FDStream___native_close},
  {(bigint) stream___FDStream___native_read_char},
  {(bigint) stream___FDStream___native_read},
  {(bigint) stream___FDStream___native_write},
  {(bigint) stream___FDStream___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: FDStream < IOS: superclass init_table position */},
  {(bigint) stream___FDStream___close},
  {(bigint) stream___IOS___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FDStream::_fd */
void INIT_ATTRIBUTES__FDStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__FDStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_FDStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_FDStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_FDStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_stream___FDStream____fd(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_fd", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDStream_stream___FDStream___init(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 225;
  fra.me.meth = LOCATE_NEW_FDStream_stream___FDStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:225 */
  fra.me.REG[0] = NEW_FDStream();
  INIT_ATTRIBUTES__FDStream(fra.me.REG[0]);
  stream___FDStream___init(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_FDStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_FDIStream[66] = {
  {(bigint) 227 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: FDIStream < Object: superclass typecheck marker */},
  {(bigint) 143 /* 3: FDIStream < FDStream: superclass typecheck marker */},
  {(bigint) 43 /* 4: FDIStream < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 119 /* 6: FDIStream < IStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 227 /* 8: FDIStream < FDIStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: FDIStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: FDIStream < FDStream: superclass init_table position */},
  {(bigint) stream___FDStream___native_close},
  {(bigint) stream___FDStream___native_read_char},
  {(bigint) stream___FDStream___native_read},
  {(bigint) stream___FDStream___native_write},
  {(bigint) stream___FDStream___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: FDIStream < IOS: superclass init_table position */},
  {(bigint) stream___FDStream___close},
  {(bigint) stream___IOS___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 3 /* 57: FDIStream < IStream: superclass init_table position */},
  {(bigint) stream___FDIStream___read_char},
  {(bigint) stream___IStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___IStream___read_all},
  {(bigint) stream___IStream___append_line_to},
  {(bigint) stream___FDIStream___eof},
  {(bigint) 4 /* 64: FDIStream < FDIStream: superclass init_table position */},
  {(bigint) stream___FDIStream___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FDIStream::_fd */
/* Instance Hole :( */
/* 4: Attribute FDIStream::_eof */
void INIT_ATTRIBUTES__FDIStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__FDIStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:231 */
  REGB0 = TAG_Bool(false);
  ATTR_stream___FDIStream____eof(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDIStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_FDIStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_FDIStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_FDIStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_stream___FDIStream____eof(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_eof", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_stream___FDStream____fd(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_fd", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDIStream_stream___FDIStream___init(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 240;
  fra.me.meth = LOCATE_NEW_FDIStream_stream___FDIStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:240 */
  fra.me.REG[0] = NEW_FDIStream();
  INIT_ATTRIBUTES__FDIStream(fra.me.REG[0]);
  stream___FDIStream___init(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_FDIStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_FDOStream[57] = {
  {(bigint) 223 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: FDOStream < Object: superclass typecheck marker */},
  {(bigint) 143 /* 3: FDOStream < FDStream: superclass typecheck marker */},
  {(bigint) 43 /* 4: FDOStream < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: FDOStream < OStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 223 /* 7: FDOStream < FDOStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: FDOStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: FDOStream < FDStream: superclass init_table position */},
  {(bigint) stream___FDStream___native_close},
  {(bigint) stream___FDStream___native_read_char},
  {(bigint) stream___FDStream___native_read},
  {(bigint) stream___FDStream___native_write},
  {(bigint) stream___FDStream___init},
  {(bigint) 4 /* 48: FDOStream < FDOStream: superclass init_table position */},
  {(bigint) stream___FDOStream___init},
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: FDOStream < IOS: superclass init_table position */},
  {(bigint) stream___FDStream___close},
  {(bigint) stream___IOS___init},
  {(bigint) 3 /* 54: FDOStream < OStream: superclass init_table position */},
  {(bigint) stream___FDOStream___write},
  {(bigint) stream___FDOStream___is_writable},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FDOStream::_fd */
/* 3: Attribute FDOStream::_is_writable */
void INIT_ATTRIBUTES__FDOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__FDOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDOStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_FDOStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_FDOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_FDOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_stream___FDOStream____is_writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_is_writable", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_stream___FDStream____fd(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_fd", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDOStream_stream___FDOStream___init(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 254;
  fra.me.meth = LOCATE_NEW_FDOStream_stream___FDOStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:254 */
  fra.me.REG[0] = NEW_FDOStream();
  INIT_ATTRIBUTES__FDOStream(fra.me.REG[0]);
  stream___FDOStream___init(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_FDOStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_FDIOStream[71] = {
  {(bigint) 275 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: FDIOStream < Object: superclass typecheck marker */},
  {(bigint) 143 /* 3: FDIOStream < FDStream: superclass typecheck marker */},
  {(bigint) 43 /* 4: FDIOStream < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: FDIOStream < OStream: superclass typecheck marker */},
  {(bigint) 119 /* 6: FDIOStream < IStream: superclass typecheck marker */},
  {(bigint) 223 /* 7: FDIOStream < FDOStream: superclass typecheck marker */},
  {(bigint) 227 /* 8: FDIOStream < FDIStream: superclass typecheck marker */},
  {(bigint) 215 /* 9: FDIOStream < IOStream: superclass typecheck marker */},
  {(bigint) 275 /* 10: FDIOStream < FDIOStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: FDIOStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: FDIOStream < FDStream: superclass init_table position */},
  {(bigint) stream___FDStream___native_close},
  {(bigint) stream___FDStream___native_read_char},
  {(bigint) stream___FDStream___native_read},
  {(bigint) stream___FDStream___native_write},
  {(bigint) stream___FDStream___init},
  {(bigint) 6 /* 48: FDIOStream < FDOStream: superclass init_table position */},
  {(bigint) stream___FDOStream___init},
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: FDIOStream < IOS: superclass init_table position */},
  {(bigint) stream___FDStream___close},
  {(bigint) stream___IOS___init},
  {(bigint) 5 /* 54: FDIOStream < OStream: superclass init_table position */},
  {(bigint) stream___FDOStream___write},
  {(bigint) stream___FDOStream___is_writable},
  {(bigint) 3 /* 57: FDIOStream < IStream: superclass init_table position */},
  {(bigint) stream___FDIStream___read_char},
  {(bigint) stream___IStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___IStream___read_all},
  {(bigint) stream___IStream___append_line_to},
  {(bigint) stream___FDIStream___eof},
  {(bigint) 4 /* 64: FDIOStream < FDIStream: superclass init_table position */},
  {(bigint) stream___FDIStream___init},
  {(bigint) 8 /* 66: FDIOStream < FDIOStream: superclass init_table position */},
  {(bigint) stream___FDIOStream___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 7 /* 70: FDIOStream < IOStream: superclass init_table position */},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FDIOStream::_fd */
/* 3: Attribute FDIOStream::_is_writable */
/* 4: Attribute FDIOStream::_eof */
void INIT_ATTRIBUTES__FDIOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__FDIOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:231 */
  REGB0 = TAG_Bool(false);
  ATTR_stream___FDIStream____eof(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDIOStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_FDIOStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_FDIOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_FDIOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_stream___FDIStream____eof(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_eof", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_stream___FDStream____fd(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_fd", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_stream___FDOStream____is_writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_is_writable", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_FDIOStream_stream___FDIOStream___init(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 264;
  fra.me.meth = LOCATE_NEW_FDIOStream_stream___FDIOStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:264 */
  fra.me.REG[0] = NEW_FDIOStream();
  INIT_ATTRIBUTES__FDIOStream(fra.me.REG[0]);
  stream___FDIOStream___init(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_FDIOStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_Pattern[48] = {
  {(bigint) 23 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Pattern < Object: superclass typecheck marker */},
  {(bigint) 23 /* 3: Pattern < Pattern: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Pattern < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: Pattern < Pattern: superclass init_table position */},
  {(bigint) string_search___Pattern___search_index_in},
  {(bigint) string_search___Pattern___search_in},
  {(bigint) string_search___Pattern___search_all_in},
  {(bigint) string_search___Pattern___split_in},
  {(bigint) string_search___Pattern___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__Pattern(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Pattern;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Pattern(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_Pattern;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Pattern(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Pattern;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Pattern_string_search___Pattern___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_Pattern_string_search___Pattern___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_Pattern();
  INIT_ATTRIBUTES__Pattern(fra.me.REG[0]);
  string_search___Pattern___init(fra.me.REG[0], init_table);
  CHECKNEW_Pattern(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_BM_Pattern[54] = {
  {(bigint) 167 /* 0: Identity */},
  {(bigint) 6 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: BM_Pattern < Object: superclass typecheck marker */},
  {(bigint) 23 /* 3: BM_Pattern < Pattern: superclass typecheck marker */},
  {(bigint) 167 /* 4: BM_Pattern < BM_Pattern: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: BM_Pattern < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string_search___BM_Pattern___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: BM_Pattern < Pattern: superclass init_table position */},
  {(bigint) string_search___BM_Pattern___search_index_in},
  {(bigint) string_search___BM_Pattern___search_in},
  {(bigint) string_search___Pattern___search_all_in},
  {(bigint) string_search___Pattern___split_in},
  {(bigint) string_search___Pattern___init},
  {(bigint) 2 /* 48: BM_Pattern < BM_Pattern: superclass init_table position */},
  {(bigint) string_search___BM_Pattern___init},
  {(bigint) string_search___BM_Pattern___bc},
  {(bigint) string_search___BM_Pattern___compute_bc},
  {(bigint) string_search___BM_Pattern___suffixes},
  {(bigint) string_search___BM_Pattern___compute_gs},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute BM_Pattern::_motif */
/* 3: Attribute BM_Pattern::_length */
/* 4: Attribute BM_Pattern::_gs */
/* 5: Attribute BM_Pattern::_bc_table */
void INIT_ATTRIBUTES__BM_Pattern(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__BM_Pattern;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_BM_Pattern(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 6);
  obj->vft = (classtable_elt_t*)VFT_BM_Pattern;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_BM_Pattern(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_BM_Pattern;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_string_search___BM_Pattern____motif(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_motif", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_string_search___BM_Pattern____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_string_search___BM_Pattern____gs(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_gs", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_string_search___BM_Pattern____bc_table(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_bc_table", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_BM_Pattern_string_search___BM_Pattern___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 107;
  fra.me.meth = LOCATE_NEW_BM_Pattern_string_search___BM_Pattern___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//string_search.nit:107 */
  fra.me.REG[1] = NEW_BM_Pattern();
  INIT_ATTRIBUTES__BM_Pattern(fra.me.REG[1]);
  string_search___BM_Pattern___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_BM_Pattern(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Match[48] = {
  {(bigint) 35 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Match < Object: superclass typecheck marker */},
  {(bigint) 35 /* 3: Match < Match: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Match < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string_search___Match___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: Match < Match: superclass init_table position */},
  {(bigint) string_search___Match___string},
  {(bigint) string_search___Match___from},
  {(bigint) string_search___Match___length},
  {(bigint) string_search___Match___after},
  {(bigint) string_search___Match___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Match::_string */
/* 3: Attribute Match::_from */
/* 4: Attribute Match::_length */
void INIT_ATTRIBUTES__Match(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Match;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Match(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_Match;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Match(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Match;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_string_search___Match____string(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_string", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_string_search___Match____from(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_from", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_string_search___Match____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Match_string_search___Match___init(val_t p0, val_t p1, val_t p2){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t REGB1;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 220;
  fra.me.meth = LOCATE_NEW_Match_string_search___Match___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  REGB1 = p2;
  /* /Users/tony/Projects/nit/lib/standard//string_search.nit:220 */
  fra.me.REG[1] = NEW_Match();
  INIT_ATTRIBUTES__Match(fra.me.REG[1]);
  string_search___Match___init(fra.me.REG[1], fra.me.REG[0], REGB0, REGB1, init_table);
  CHECKNEW_Match(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_FStream[54] = {
  {(bigint) 139 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: FStream < Object: superclass typecheck marker */},
  {(bigint) 27 /* 3: FStream < NativeFileCapable: superclass typecheck marker */},
  {(bigint) 43 /* 4: FStream < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 139 /* 7: FStream < FStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: FStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: FStream < NativeFileCapable: superclass init_table position */},
  {(bigint) file___NativeFileCapable___io_open_read},
  {(bigint) file___NativeFileCapable___io_open_write},
  {(bigint) file___NativeFileCapable___native_stdin},
  {(bigint) file___NativeFileCapable___native_stdout},
  {(bigint) file___NativeFileCapable___native_stderr},
  {(bigint) 3 /* 48: FStream < FStream: superclass init_table position */},
  {(bigint) file___FStream___path},
  {(bigint) file___FStream___file_stat},
  {(bigint) 1 /* 51: FStream < IOS: superclass init_table position */},
  {(bigint) stream___IOS___close},
  {(bigint) stream___IOS___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FStream::_path */
/* 3: Attribute FStream::_file */
void INIT_ATTRIBUTES__FStream(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__FStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:55 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//file.nit:58 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_FStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_FStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_FStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_FStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_FStream_stream___IOS___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_FStream_stream___IOS___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_FStream();
  INIT_ATTRIBUTES__FStream(fra.me.REG[0]);
  stream___IOS___init(fra.me.REG[0], init_table);
  CHECKNEW_FStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_IFStream[73] = {
  {(bigint) 267 /* 0: Identity */},
  {(bigint) 7 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: IFStream < Object: superclass typecheck marker */},
  {(bigint) 27 /* 3: IFStream < NativeFileCapable: superclass typecheck marker */},
  {(bigint) 43 /* 4: IFStream < IOS: superclass typecheck marker */},
  {(bigint) 235 /* 5: IFStream < BufferedIStream: superclass typecheck marker */},
  {(bigint) 119 /* 6: IFStream < IStream: superclass typecheck marker */},
  {(bigint) 139 /* 7: IFStream < FStream: superclass typecheck marker */},
  {(bigint) 267 /* 8: IFStream < IFStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: IFStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: IFStream < NativeFileCapable: superclass init_table position */},
  {(bigint) file___NativeFileCapable___io_open_read},
  {(bigint) file___NativeFileCapable___io_open_write},
  {(bigint) file___NativeFileCapable___native_stdin},
  {(bigint) file___NativeFileCapable___native_stdout},
  {(bigint) file___NativeFileCapable___native_stderr},
  {(bigint) 3 /* 48: IFStream < FStream: superclass init_table position */},
  {(bigint) file___FStream___path},
  {(bigint) file___FStream___file_stat},
  {(bigint) 1 /* 51: IFStream < IOS: superclass init_table position */},
  {(bigint) file___IFStream___close},
  {(bigint) stream___IOS___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 57: IFStream < IStream: superclass init_table position */},
  {(bigint) stream___BufferedIStream___read_char},
  {(bigint) stream___BufferedIStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___BufferedIStream___read_all},
  {(bigint) stream___BufferedIStream___append_line_to},
  {(bigint) stream___BufferedIStream___eof},
  {(bigint) 5 /* 64: IFStream < BufferedIStream: superclass init_table position */},
  {(bigint) file___IFStream___fill_buffer},
  {(bigint) file___IFStream___end_reached},
  {(bigint) stream___BufferedIStream___prepare_buffer},
  {(bigint) 6 /* 68: IFStream < IFStream: superclass init_table position */},
  {(bigint) file___IFStream___reopen},
  {(bigint) file___IFStream___open},
  {(bigint) file___IFStream___init},
  {(bigint) file___IFStream___without_file},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IFStream::_path */
/* 3: Attribute IFStream::_file */
/* 4: Attribute IFStream::_buffer */
/* 5: Attribute IFStream::_buffer_pos */
/* 6: Attribute IFStream::_end_reached */
void INIT_ATTRIBUTES__IFStream(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__IFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:99 */
  REGB0 = TAG_Bool(false);
  ATTR_file___IFStream____end_reached(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:55 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//file.nit:58 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:186 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_stream___BufferedIStream____buffer(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:190 */
  REGB0 = TAG_Int(0);
  ATTR_stream___BufferedIStream____buffer_pos(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IFStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 7);
  obj->vft = (classtable_elt_t*)VFT_IFStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_IFStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_IFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_file___IFStream____end_reached(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_end_reached", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_stream___BufferedIStream____buffer_pos(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_buffer_pos", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_IFStream_file___IFStream___open(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 101;
  fra.me.meth = LOCATE_NEW_IFStream_file___IFStream___open;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:101 */
  fra.me.REG[1] = NEW_IFStream();
  INIT_ATTRIBUTES__IFStream(fra.me.REG[1]);
  file___IFStream___open(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_IFStream(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
val_t NEW_IFStream_file___IFStream___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 110;
  fra.me.meth = LOCATE_NEW_IFStream_file___IFStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:110 */
  fra.me.REG[0] = NEW_IFStream();
  INIT_ATTRIBUTES__IFStream(fra.me.REG[0]);
  file___IFStream___init(fra.me.REG[0], init_table);
  CHECKNEW_IFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
val_t NEW_IFStream_file___IFStream___without_file(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 111;
  fra.me.meth = LOCATE_NEW_IFStream_file___IFStream___without_file;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:111 */
  fra.me.REG[0] = NEW_IFStream();
  INIT_ATTRIBUTES__IFStream(fra.me.REG[0]);
  file___IFStream___without_file(fra.me.REG[0], init_table);
  CHECKNEW_IFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_OFStream[62] = {
  {(bigint) 195 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: OFStream < Object: superclass typecheck marker */},
  {(bigint) 27 /* 3: OFStream < NativeFileCapable: superclass typecheck marker */},
  {(bigint) 43 /* 4: OFStream < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: OFStream < OStream: superclass typecheck marker */},
  {(bigint) 195 /* 6: OFStream < OFStream: superclass typecheck marker */},
  {(bigint) 139 /* 7: OFStream < FStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: OFStream < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: OFStream < NativeFileCapable: superclass init_table position */},
  {(bigint) file___NativeFileCapable___io_open_read},
  {(bigint) file___NativeFileCapable___io_open_write},
  {(bigint) file___NativeFileCapable___native_stdin},
  {(bigint) file___NativeFileCapable___native_stdout},
  {(bigint) file___NativeFileCapable___native_stderr},
  {(bigint) 3 /* 48: OFStream < FStream: superclass init_table position */},
  {(bigint) file___FStream___path},
  {(bigint) file___FStream___file_stat},
  {(bigint) 1 /* 51: OFStream < IOS: superclass init_table position */},
  {(bigint) file___OFStream___close},
  {(bigint) stream___IOS___init},
  {(bigint) 4 /* 54: OFStream < OStream: superclass init_table position */},
  {(bigint) file___OFStream___write},
  {(bigint) file___OFStream___is_writable},
  {(bigint) 5 /* 57: OFStream < OFStream: superclass init_table position */},
  {(bigint) file___OFStream___write_native},
  {(bigint) file___OFStream___open},
  {(bigint) file___OFStream___init},
  {(bigint) file___OFStream___without_file},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute OFStream::_path */
/* 3: Attribute OFStream::_file */
/* 4: Attribute OFStream::_writable */
void INIT_ATTRIBUTES__OFStream(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__OFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:55 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//file.nit:58 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_OFStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_OFStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_OFStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_OFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_file___OFStream____writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_writable", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_OFStream_file___OFStream___open(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 148;
  fra.me.meth = LOCATE_NEW_OFStream_file___OFStream___open;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:148 */
  fra.me.REG[1] = NEW_OFStream();
  INIT_ATTRIBUTES__OFStream(fra.me.REG[1]);
  file___OFStream___open(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_OFStream(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
val_t NEW_OFStream_file___OFStream___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 157;
  fra.me.meth = LOCATE_NEW_OFStream_file___OFStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:157 */
  fra.me.REG[0] = NEW_OFStream();
  INIT_ATTRIBUTES__OFStream(fra.me.REG[0]);
  file___OFStream___init(fra.me.REG[0], init_table);
  CHECKNEW_OFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
val_t NEW_OFStream_file___OFStream___without_file(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 158;
  fra.me.meth = LOCATE_NEW_OFStream_file___OFStream___without_file;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:158 */
  fra.me.REG[0] = NEW_OFStream();
  INIT_ATTRIBUTES__OFStream(fra.me.REG[0]);
  file___OFStream___without_file(fra.me.REG[0], init_table);
  CHECKNEW_OFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_Stdin[75] = {
  {(bigint) 291 /* 0: Identity */},
  {(bigint) 7 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Stdin < Object: superclass typecheck marker */},
  {(bigint) 27 /* 3: Stdin < NativeFileCapable: superclass typecheck marker */},
  {(bigint) 43 /* 4: Stdin < IOS: superclass typecheck marker */},
  {(bigint) 235 /* 5: Stdin < BufferedIStream: superclass typecheck marker */},
  {(bigint) 119 /* 6: Stdin < IStream: superclass typecheck marker */},
  {(bigint) 139 /* 7: Stdin < FStream: superclass typecheck marker */},
  {(bigint) 267 /* 8: Stdin < IFStream: superclass typecheck marker */},
  {(bigint) 291 /* 9: Stdin < Stdin: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Stdin < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: Stdin < NativeFileCapable: superclass init_table position */},
  {(bigint) file___NativeFileCapable___io_open_read},
  {(bigint) file___NativeFileCapable___io_open_write},
  {(bigint) file___NativeFileCapable___native_stdin},
  {(bigint) file___NativeFileCapable___native_stdout},
  {(bigint) file___NativeFileCapable___native_stderr},
  {(bigint) 3 /* 48: Stdin < FStream: superclass init_table position */},
  {(bigint) file___FStream___path},
  {(bigint) file___FStream___file_stat},
  {(bigint) 1 /* 51: Stdin < IOS: superclass init_table position */},
  {(bigint) file___IFStream___close},
  {(bigint) stream___IOS___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 57: Stdin < IStream: superclass init_table position */},
  {(bigint) stream___BufferedIStream___read_char},
  {(bigint) stream___BufferedIStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___BufferedIStream___read_all},
  {(bigint) stream___BufferedIStream___append_line_to},
  {(bigint) stream___BufferedIStream___eof},
  {(bigint) 5 /* 64: Stdin < BufferedIStream: superclass init_table position */},
  {(bigint) file___IFStream___fill_buffer},
  {(bigint) file___IFStream___end_reached},
  {(bigint) stream___BufferedIStream___prepare_buffer},
  {(bigint) 6 /* 68: Stdin < IFStream: superclass init_table position */},
  {(bigint) file___IFStream___reopen},
  {(bigint) file___IFStream___open},
  {(bigint) file___IFStream___init},
  {(bigint) file___IFStream___without_file},
  {(bigint) 7 /* 73: Stdin < Stdin: superclass init_table position */},
  {(bigint) file___Stdin___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Stdin::_path */
/* 3: Attribute Stdin::_file */
/* 4: Attribute Stdin::_buffer */
/* 5: Attribute Stdin::_buffer_pos */
/* 6: Attribute Stdin::_end_reached */
void INIT_ATTRIBUTES__Stdin(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Stdin;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:99 */
  REGB0 = TAG_Bool(false);
  ATTR_file___IFStream____end_reached(fra.me.REG[0]) = REGB0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:55 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//file.nit:58 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:186 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_stream___BufferedIStream____buffer(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//stream.nit:190 */
  REGB0 = TAG_Int(0);
  ATTR_stream___BufferedIStream____buffer_pos(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Stdin(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 7);
  obj->vft = (classtable_elt_t*)VFT_Stdin;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Stdin(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Stdin;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_file___IFStream____end_reached(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_end_reached", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_stream___BufferedIStream____buffer_pos(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_buffer_pos", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Stdin_file___Stdin___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 165;
  fra.me.meth = LOCATE_NEW_Stdin_file___Stdin___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:165 */
  fra.me.REG[0] = NEW_Stdin();
  INIT_ATTRIBUTES__Stdin(fra.me.REG[0]);
  file___Stdin___init(fra.me.REG[0], init_table);
  CHECKNEW_Stdin(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_Stdout[64] = {
  {(bigint) 239 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Stdout < Object: superclass typecheck marker */},
  {(bigint) 27 /* 3: Stdout < NativeFileCapable: superclass typecheck marker */},
  {(bigint) 43 /* 4: Stdout < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: Stdout < OStream: superclass typecheck marker */},
  {(bigint) 195 /* 6: Stdout < OFStream: superclass typecheck marker */},
  {(bigint) 139 /* 7: Stdout < FStream: superclass typecheck marker */},
  {(bigint) 239 /* 8: Stdout < Stdout: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Stdout < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: Stdout < NativeFileCapable: superclass init_table position */},
  {(bigint) file___NativeFileCapable___io_open_read},
  {(bigint) file___NativeFileCapable___io_open_write},
  {(bigint) file___NativeFileCapable___native_stdin},
  {(bigint) file___NativeFileCapable___native_stdout},
  {(bigint) file___NativeFileCapable___native_stderr},
  {(bigint) 3 /* 48: Stdout < FStream: superclass init_table position */},
  {(bigint) file___FStream___path},
  {(bigint) file___FStream___file_stat},
  {(bigint) 1 /* 51: Stdout < IOS: superclass init_table position */},
  {(bigint) file___OFStream___close},
  {(bigint) stream___IOS___init},
  {(bigint) 4 /* 54: Stdout < OStream: superclass init_table position */},
  {(bigint) file___OFStream___write},
  {(bigint) file___OFStream___is_writable},
  {(bigint) 5 /* 57: Stdout < OFStream: superclass init_table position */},
  {(bigint) file___OFStream___write_native},
  {(bigint) file___OFStream___open},
  {(bigint) file___OFStream___init},
  {(bigint) file___OFStream___without_file},
  {(bigint) 6 /* 62: Stdout < Stdout: superclass init_table position */},
  {(bigint) file___Stdout___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Stdout::_path */
/* 3: Attribute Stdout::_file */
/* 4: Attribute Stdout::_writable */
void INIT_ATTRIBUTES__Stdout(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Stdout;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:55 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//file.nit:58 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_Stdout(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_Stdout;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Stdout(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Stdout;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_file___OFStream____writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_writable", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Stdout_file___Stdout___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 174;
  fra.me.meth = LOCATE_NEW_Stdout_file___Stdout___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:174 */
  fra.me.REG[0] = NEW_Stdout();
  INIT_ATTRIBUTES__Stdout(fra.me.REG[0]);
  file___Stdout___init(fra.me.REG[0], init_table);
  CHECKNEW_Stdout(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_Stderr[64] = {
  {(bigint) 243 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Stderr < Object: superclass typecheck marker */},
  {(bigint) 27 /* 3: Stderr < NativeFileCapable: superclass typecheck marker */},
  {(bigint) 43 /* 4: Stderr < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: Stderr < OStream: superclass typecheck marker */},
  {(bigint) 195 /* 6: Stderr < OFStream: superclass typecheck marker */},
  {(bigint) 139 /* 7: Stderr < FStream: superclass typecheck marker */},
  {(bigint) 243 /* 8: Stderr < Stderr: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Stderr < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 2 /* 42: Stderr < NativeFileCapable: superclass init_table position */},
  {(bigint) file___NativeFileCapable___io_open_read},
  {(bigint) file___NativeFileCapable___io_open_write},
  {(bigint) file___NativeFileCapable___native_stdin},
  {(bigint) file___NativeFileCapable___native_stdout},
  {(bigint) file___NativeFileCapable___native_stderr},
  {(bigint) 3 /* 48: Stderr < FStream: superclass init_table position */},
  {(bigint) file___FStream___path},
  {(bigint) file___FStream___file_stat},
  {(bigint) 1 /* 51: Stderr < IOS: superclass init_table position */},
  {(bigint) file___OFStream___close},
  {(bigint) stream___IOS___init},
  {(bigint) 4 /* 54: Stderr < OStream: superclass init_table position */},
  {(bigint) file___OFStream___write},
  {(bigint) file___OFStream___is_writable},
  {(bigint) 5 /* 57: Stderr < OFStream: superclass init_table position */},
  {(bigint) file___OFStream___write_native},
  {(bigint) file___OFStream___open},
  {(bigint) file___OFStream___init},
  {(bigint) file___OFStream___without_file},
  {(bigint) 6 /* 62: Stderr < Stderr: superclass init_table position */},
  {(bigint) file___Stderr___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Stderr::_path */
/* 3: Attribute Stderr::_file */
/* 4: Attribute Stderr::_writable */
void INIT_ATTRIBUTES__Stderr(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Stderr;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:55 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /Users/tony/Projects/nit/lib/standard//file.nit:58 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_Stderr(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_Stderr;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Stderr(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Stderr;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_file___OFStream____writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_writable", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Stderr_file___Stderr___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 183;
  fra.me.meth = LOCATE_NEW_Stderr_file___Stderr___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  /* /Users/tony/Projects/nit/lib/standard//file.nit:183 */
  fra.me.REG[0] = NEW_Stderr();
  INIT_ATTRIBUTES__Stderr(fra.me.REG[0]);
  file___Stderr___init(fra.me.REG[0], init_table);
  CHECKNEW_Stderr(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_FileStat[49] = {
  {(bigint) -25 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: FileStat < Object: superclass typecheck marker */},
  {(bigint) -1 /* 3: FileStat < Pointer: superclass typecheck marker */},
  {(bigint) -25 /* 4: FileStat < FileStat: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: FileStat < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: FileStat < Pointer: superclass init_table position */},
  {(bigint) 2 /* 43: FileStat < FileStat: superclass init_table position */},
  {(bigint) file___FileStat___mode},
  {(bigint) file___FileStat___atime},
  {(bigint) file___FileStat___ctime},
  {(bigint) file___FileStat___mtime},
  {(bigint) file___FileStat___size},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_FileStat(void * val) {
  struct TBOX_FileStat *box = (struct TBOX_FileStat*)alloc(sizeof(struct TBOX_FileStat));
  box->vft = VFT_FileStat;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_NativeFile[48] = {
  {(bigint) -21 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: NativeFile < Object: superclass typecheck marker */},
  {(bigint) -1 /* 3: NativeFile < Pointer: superclass typecheck marker */},
  {(bigint) -21 /* 4: NativeFile < NativeFile: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: NativeFile < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: NativeFile < Pointer: superclass init_table position */},
  {(bigint) 2 /* 43: NativeFile < NativeFile: superclass init_table position */},
  {(bigint) file___NativeFile___io_read},
  {(bigint) file___NativeFile___io_write},
  {(bigint) file___NativeFile___io_close},
  {(bigint) file___NativeFile___file_stat},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_NativeFile(void * val) {
  struct TBOX_NativeFile *box = (struct TBOX_NativeFile*)alloc(sizeof(struct TBOX_NativeFile));
  box->vft = VFT_NativeFile;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_Process[51] = {
  {(bigint) 19 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Process < Object: superclass typecheck marker */},
  {(bigint) 19 /* 3: Process < Process: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Process < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: Process < Process: superclass init_table position */},
  {(bigint) exec___Process___id},
  {(bigint) exec___Process___is_finished},
  {(bigint) exec___Process___wait},
  {(bigint) exec___Process___status},
  {(bigint) exec___Process___init},
  {(bigint) exec___Process___init_},
  {(bigint) exec___Process___execute},
  {(bigint) exec___Process___basic_exec_execute},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Process::_data */
void INIT_ATTRIBUTES__Process(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Process;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Process(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Process;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Process(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Process;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_exec___Process____data(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_data", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Process_exec___Process___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 43;
  fra.me.meth = LOCATE_NEW_Process_exec___Process___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:43 */
  fra.me.REG[2] = NEW_Process();
  INIT_ATTRIBUTES__Process(fra.me.REG[2]);
  exec___Process___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_Process(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
val_t NEW_Process_exec___Process___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 49;
  fra.me.meth = LOCATE_NEW_Process_exec___Process___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:49 */
  fra.me.REG[1] = NEW_Process();
  INIT_ATTRIBUTES__Process(fra.me.REG[1]);
  exec___Process___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Process(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
val_t NEW_Process_exec___Process___execute(val_t p0, val_t p1, val_t p2){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 55;
  fra.me.meth = LOCATE_NEW_Process_exec___Process___execute;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  REGB0 = p2;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:55 */
  fra.me.REG[2] = NEW_Process();
  INIT_ATTRIBUTES__Process(fra.me.REG[2]);
  exec___Process___execute(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], REGB0, init_table);
  CHECKNEW_Process(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_IProcess[70] = {
  {(bigint) 211 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: IProcess < Object: superclass typecheck marker */},
  {(bigint) 19 /* 3: IProcess < Process: superclass typecheck marker */},
  {(bigint) 43 /* 4: IProcess < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 119 /* 6: IProcess < IStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 211 /* 8: IProcess < IProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: IProcess < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: IProcess < Process: superclass init_table position */},
  {(bigint) exec___Process___id},
  {(bigint) exec___Process___is_finished},
  {(bigint) exec___Process___wait},
  {(bigint) exec___Process___status},
  {(bigint) exec___Process___init},
  {(bigint) exec___Process___init_},
  {(bigint) exec___Process___execute},
  {(bigint) exec___Process___basic_exec_execute},
  {(bigint) 2 /* 51: IProcess < IOS: superclass init_table position */},
  {(bigint) exec___IProcess___close},
  {(bigint) stream___IOS___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 3 /* 57: IProcess < IStream: superclass init_table position */},
  {(bigint) exec___IProcess___read_char},
  {(bigint) stream___IStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___IStream___read_all},
  {(bigint) stream___IStream___append_line_to},
  {(bigint) exec___IProcess___eof},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 67: IProcess < IProcess: superclass init_table position */},
  {(bigint) exec___IProcess___init},
  {(bigint) exec___IProcess___init_},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IProcess::_data */
/* Instance Hole :( */
/* 4: Attribute IProcess::_in */
void INIT_ATTRIBUTES__IProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__IProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IProcess(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_IProcess;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_IProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_IProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_exec___IProcess____in(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_in", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_exec___Process____data(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_data", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_IProcess_exec___IProcess___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 87;
  fra.me.meth = LOCATE_NEW_IProcess_exec___IProcess___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:87 */
  fra.me.REG[2] = NEW_IProcess();
  INIT_ATTRIBUTES__IProcess(fra.me.REG[2]);
  exec___IProcess___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_IProcess(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
val_t NEW_IProcess_exec___IProcess___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 93;
  fra.me.meth = LOCATE_NEW_IProcess_exec___IProcess___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:93 */
  fra.me.REG[1] = NEW_IProcess();
  INIT_ATTRIBUTES__IProcess(fra.me.REG[1]);
  exec___IProcess___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_IProcess(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_OProcess[67] = {
  {(bigint) 191 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: OProcess < Object: superclass typecheck marker */},
  {(bigint) 19 /* 3: OProcess < Process: superclass typecheck marker */},
  {(bigint) 43 /* 4: OProcess < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: OProcess < OStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 191 /* 7: OProcess < OProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: OProcess < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: OProcess < Process: superclass init_table position */},
  {(bigint) exec___Process___id},
  {(bigint) exec___Process___is_finished},
  {(bigint) exec___Process___wait},
  {(bigint) exec___Process___status},
  {(bigint) exec___Process___init},
  {(bigint) exec___Process___init_},
  {(bigint) exec___Process___execute},
  {(bigint) exec___Process___basic_exec_execute},
  {(bigint) 2 /* 51: OProcess < IOS: superclass init_table position */},
  {(bigint) exec___OProcess___close},
  {(bigint) stream___IOS___init},
  {(bigint) 3 /* 54: OProcess < OStream: superclass init_table position */},
  {(bigint) exec___OProcess___write},
  {(bigint) exec___OProcess___is_writable},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 64: OProcess < OProcess: superclass init_table position */},
  {(bigint) exec___OProcess___init},
  {(bigint) exec___OProcess___init_},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute OProcess::_data */
/* 3: Attribute OProcess::_out */
void INIT_ATTRIBUTES__OProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__OProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_OProcess(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_OProcess;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_OProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_OProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_exec___OProcess____out(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_out", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_exec___Process____data(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_data", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_OProcess_exec___OProcess___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 112;
  fra.me.meth = LOCATE_NEW_OProcess_exec___OProcess___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:112 */
  fra.me.REG[2] = NEW_OProcess();
  INIT_ATTRIBUTES__OProcess(fra.me.REG[2]);
  exec___OProcess___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_OProcess(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
val_t NEW_OProcess_exec___OProcess___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 118;
  fra.me.meth = LOCATE_NEW_OProcess_exec___OProcess___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:118 */
  fra.me.REG[1] = NEW_OProcess();
  INIT_ATTRIBUTES__OProcess(fra.me.REG[1]);
  exec___OProcess___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_OProcess(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_IOProcess[74] = {
  {(bigint) 263 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: IOProcess < Object: superclass typecheck marker */},
  {(bigint) 19 /* 3: IOProcess < Process: superclass typecheck marker */},
  {(bigint) 43 /* 4: IOProcess < IOS: superclass typecheck marker */},
  {(bigint) 99 /* 5: IOProcess < OStream: superclass typecheck marker */},
  {(bigint) 119 /* 6: IOProcess < IStream: superclass typecheck marker */},
  {(bigint) 191 /* 7: IOProcess < OProcess: superclass typecheck marker */},
  {(bigint) 211 /* 8: IOProcess < IProcess: superclass typecheck marker */},
  {(bigint) 215 /* 9: IOProcess < IOStream: superclass typecheck marker */},
  {(bigint) 263 /* 10: IOProcess < IOProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: IOProcess < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: IOProcess < Process: superclass init_table position */},
  {(bigint) exec___Process___id},
  {(bigint) exec___Process___is_finished},
  {(bigint) exec___Process___wait},
  {(bigint) exec___Process___status},
  {(bigint) exec___Process___init},
  {(bigint) exec___Process___init_},
  {(bigint) exec___Process___execute},
  {(bigint) exec___Process___basic_exec_execute},
  {(bigint) 2 /* 51: IOProcess < IOS: superclass init_table position */},
  {(bigint) exec___IOProcess___close},
  {(bigint) stream___IOS___init},
  {(bigint) 5 /* 54: IOProcess < OStream: superclass init_table position */},
  {(bigint) exec___OProcess___write},
  {(bigint) exec___OProcess___is_writable},
  {(bigint) 3 /* 57: IOProcess < IStream: superclass init_table position */},
  {(bigint) exec___IProcess___read_char},
  {(bigint) stream___IStream___read},
  {(bigint) stream___IStream___read_line},
  {(bigint) stream___IStream___read_all},
  {(bigint) stream___IStream___append_line_to},
  {(bigint) exec___IProcess___eof},
  {(bigint) 6 /* 64: IOProcess < OProcess: superclass init_table position */},
  {(bigint) exec___OProcess___init},
  {(bigint) exec___OProcess___init_},
  {(bigint) 4 /* 67: IOProcess < IProcess: superclass init_table position */},
  {(bigint) exec___IProcess___init},
  {(bigint) exec___IProcess___init_},
  {(bigint) 7 /* 70: IOProcess < IOStream: superclass init_table position */},
  {(bigint) 8 /* 71: IOProcess < IOProcess: superclass init_table position */},
  {(bigint) exec___IOProcess___init},
  {(bigint) exec___IOProcess___init_},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IOProcess::_data */
/* 3: Attribute IOProcess::_out */
/* 4: Attribute IOProcess::_in */
void INIT_ATTRIBUTES__IOProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__IOProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_IOProcess(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_IOProcess;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_IOProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_IOProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_exec___IProcess____in(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_in", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_exec___Process____data(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_data", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_exec___OProcess____out(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_out", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_IOProcess_exec___IOProcess___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 137;
  fra.me.meth = LOCATE_NEW_IOProcess_exec___IOProcess___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:137 */
  fra.me.REG[2] = NEW_IOProcess();
  INIT_ATTRIBUTES__IOProcess(fra.me.REG[2]);
  exec___IOProcess___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_IOProcess(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
val_t NEW_IOProcess_exec___IOProcess___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 144;
  fra.me.meth = LOCATE_NEW_IOProcess_exec___IOProcess___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /Users/tony/Projects/nit/lib/standard//exec.nit:144 */
  fra.me.REG[1] = NEW_IOProcess();
  INIT_ATTRIBUTES__IOProcess(fra.me.REG[1]);
  exec___IOProcess___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_IOProcess(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_NativeProcess[51] = {
  {(bigint) -17 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: NativeProcess < Object: superclass typecheck marker */},
  {(bigint) -1 /* 3: NativeProcess < Pointer: superclass typecheck marker */},
  {(bigint) -17 /* 4: NativeProcess < NativeProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: NativeProcess < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: NativeProcess < Pointer: superclass init_table position */},
  {(bigint) 2 /* 43: NativeProcess < NativeProcess: superclass init_table position */},
  {(bigint) exec___NativeProcess___id},
  {(bigint) exec___NativeProcess___is_finished},
  {(bigint) exec___NativeProcess___status},
  {(bigint) exec___NativeProcess___wait},
  {(bigint) exec___NativeProcess___in_fd},
  {(bigint) exec___NativeProcess___out_fd},
  {(bigint) exec___NativeProcess___err_fd},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_NativeProcess(void * val) {
  struct TBOX_NativeProcess *box = (struct TBOX_NativeProcess*)alloc(sizeof(struct TBOX_NativeProcess));
  box->vft = VFT_NativeProcess;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_Point[49] = {
  {(bigint) 95 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Point < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Point < Figure: superclass typecheck marker */},
  {(bigint) 95 /* 4: Point < Point: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Point < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) figure___Point_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) figure___Point___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Point < Figure: superclass init_table position */},
  {(bigint) figure___Point___aire},
  {(bigint) figure___Point___perimetre},
  {(bigint) 2 /* 45: Point < Point: superclass init_table position */},
  {(bigint) figure___Point___x},
  {(bigint) figure___Point___y},
  {(bigint) figure___Point___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Point::_x */
/* 3: Attribute Point::_y */
void INIT_ATTRIBUTES__Point(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Point;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Point(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_Point;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Point(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Point;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_figure___Point____x(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_x", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_figure___Point____y(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_y", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Point_figure___Point___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 20;
  fra.me.meth = LOCATE_NEW_Point_figure___Point___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* ./figure.nit:20 */
  fra.me.REG[2] = NEW_Point();
  INIT_ATTRIBUTES__Point(fra.me.REG[2]);
  figure___Point___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_Point(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_Segment[50] = {
  {(bigint) 79 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Segment < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Segment < Figure: superclass typecheck marker */},
  {(bigint) 79 /* 4: Segment < Segment: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Segment < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) figure___Segment_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) figure___Segment___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Segment < Figure: superclass init_table position */},
  {(bigint) figure___Segment___aire},
  {(bigint) figure___Segment___perimetre},
  {(bigint) 2 /* 45: Segment < Segment: superclass init_table position */},
  {(bigint) figure___Segment___sommets},
  {(bigint) figure___Segment___init},
  {(bigint) figure___Segment___taille},
  {(bigint) figure___Segment___milieu},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Segment::_sommets */
void INIT_ATTRIBUTES__Segment(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Segment;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Segment(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Segment;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Segment(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Segment;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_figure___Segment____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Segment_figure___Segment___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 59;
  fra.me.meth = LOCATE_NEW_Segment_figure___Segment___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./figure.nit:59 */
  fra.me.REG[1] = NEW_Segment();
  INIT_ATTRIBUTES__Segment(fra.me.REG[1]);
  figure___Segment___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Segment(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Cercle[49] = {
  {(bigint) 163 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Cercle < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Cercle < Figure: superclass typecheck marker */},
  {(bigint) 163 /* 4: Cercle < Cercle: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Cercle < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) figure___Cercle_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) figure___Cercle___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Cercle < Figure: superclass init_table position */},
  {(bigint) figure___Cercle___aire},
  {(bigint) figure___Cercle___perimetre},
  {(bigint) 2 /* 45: Cercle < Cercle: superclass init_table position */},
  {(bigint) figure___Cercle___centre},
  {(bigint) figure___Cercle___rayon},
  {(bigint) figure___Cercle___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Cercle::_centre */
/* 3: Attribute Cercle::_rayon */
void INIT_ATTRIBUTES__Cercle(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Cercle;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Cercle(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_Cercle;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Cercle(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Cercle;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_figure___Cercle____centre(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_centre", LOCATE_main, 0);
  }
  REGB0 = TAG_Bool(ATTR_figure___Cercle____rayon(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_rayon", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Cercle_figure___Cercle___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 122;
  fra.me.meth = LOCATE_NEW_Cercle_figure___Cercle___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* ./figure.nit:122 */
  fra.me.REG[2] = NEW_Cercle();
  INIT_ATTRIBUTES__Cercle(fra.me.REG[2]);
  figure___Cercle___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_Cercle(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_Polygone[49] = {
  {(bigint) 91 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Polygone < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Polygone < Figure: superclass typecheck marker */},
  {(bigint) 91 /* 4: Polygone < Polygone: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Polygone < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) polygone___Polygone_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) polygone___Polygone___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Polygone < Figure: superclass init_table position */},
  {(bigint) polygone___Polygone___aire},
  {(bigint) polygone___Polygone___perimetre},
  {(bigint) 2 /* 45: Polygone < Polygone: superclass init_table position */},
  {(bigint) polygone___Polygone___sommets},
  {(bigint) polygone___Polygone___init},
  {(bigint) polygone___Polygone___cotes},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Polygone::_sommets */
void INIT_ATTRIBUTES__Polygone(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Polygone;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Polygone(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Polygone;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Polygone(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Polygone;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_polygone___Polygone____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Polygone_polygone___Polygone___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 10;
  fra.me.meth = LOCATE_NEW_Polygone_polygone___Polygone___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./polygone.nit:10 */
  fra.me.REG[1] = NEW_Polygone();
  INIT_ATTRIBUTES__Polygone(fra.me.REG[1]);
  polygone___Polygone___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Polygone(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Triangle[53] = {
  {(bigint) 175 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Triangle < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Triangle < Figure: superclass typecheck marker */},
  {(bigint) 91 /* 4: Triangle < Polygone: superclass typecheck marker */},
  {(bigint) 175 /* 5: Triangle < Triangle: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Triangle < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) polygone___Triangle_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) polygone___Triangle___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Triangle < Figure: superclass init_table position */},
  {(bigint) polygone___Triangle___aire},
  {(bigint) polygone___Polygone___perimetre},
  {(bigint) 2 /* 45: Triangle < Polygone: superclass init_table position */},
  {(bigint) polygone___Polygone___sommets},
  {(bigint) polygone___Polygone___init},
  {(bigint) polygone___Polygone___cotes},
  {(bigint) 3 /* 49: Triangle < Triangle: superclass init_table position */},
  {(bigint) polygone___Triangle___init},
  {(bigint) polygone___Polygone_____eqeq},
  {(bigint) polygone___Polygone___to_s},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Triangle::_sommets */
void INIT_ATTRIBUTES__Triangle(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Triangle;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Triangle(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Triangle;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Triangle(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Triangle;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_polygone___Polygone____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Triangle_polygone___Triangle___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 86;
  fra.me.meth = LOCATE_NEW_Triangle_polygone___Triangle___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./polygone.nit:86 */
  fra.me.REG[1] = NEW_Triangle();
  INIT_ATTRIBUTES__Triangle(fra.me.REG[1]);
  polygone___Triangle___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Triangle(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Quadrilatere[54] = {
  {(bigint) 187 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Quadrilatere < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Quadrilatere < Figure: superclass typecheck marker */},
  {(bigint) 91 /* 4: Quadrilatere < Polygone: superclass typecheck marker */},
  {(bigint) 187 /* 5: Quadrilatere < Quadrilatere: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Quadrilatere < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) polygone___Quadrilatere_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) polygone___Quadrilatere___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Quadrilatere < Figure: superclass init_table position */},
  {(bigint) polygone___Polygone___aire},
  {(bigint) polygone___Polygone___perimetre},
  {(bigint) 2 /* 45: Quadrilatere < Polygone: superclass init_table position */},
  {(bigint) polygone___Polygone___sommets},
  {(bigint) polygone___Polygone___init},
  {(bigint) polygone___Polygone___cotes},
  {(bigint) 3 /* 49: Quadrilatere < Quadrilatere: superclass init_table position */},
  {(bigint) polygone___Quadrilatere___init},
  {(bigint) polygone___Quadrilatere___diagonales},
  {(bigint) polygone___Polygone_____eqeq},
  {(bigint) polygone___Polygone___to_s},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Quadrilatere::_sommets */
void INIT_ATTRIBUTES__Quadrilatere(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Quadrilatere;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Quadrilatere(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Quadrilatere;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Quadrilatere(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Quadrilatere;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_polygone___Polygone____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Quadrilatere_polygone___Quadrilatere___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 120;
  fra.me.meth = LOCATE_NEW_Quadrilatere_polygone___Quadrilatere___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./polygone.nit:120 */
  fra.me.REG[1] = NEW_Quadrilatere();
  INIT_ATTRIBUTES__Quadrilatere(fra.me.REG[1]);
  polygone___Quadrilatere___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Quadrilatere(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Parallelogramme[58] = {
  {(bigint) 255 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Parallelogramme < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Parallelogramme < Figure: superclass typecheck marker */},
  {(bigint) 91 /* 4: Parallelogramme < Polygone: superclass typecheck marker */},
  {(bigint) 187 /* 5: Parallelogramme < Quadrilatere: superclass typecheck marker */},
  {(bigint) 255 /* 6: Parallelogramme < Parallelogramme: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Parallelogramme < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) polygone___Parallelogramme_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) polygone___Parallelogramme___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Parallelogramme < Figure: superclass init_table position */},
  {(bigint) polygone___Parallelogramme___aire},
  {(bigint) polygone___Polygone___perimetre},
  {(bigint) 2 /* 45: Parallelogramme < Polygone: superclass init_table position */},
  {(bigint) polygone___Polygone___sommets},
  {(bigint) polygone___Polygone___init},
  {(bigint) polygone___Polygone___cotes},
  {(bigint) 3 /* 49: Parallelogramme < Quadrilatere: superclass init_table position */},
  {(bigint) polygone___Quadrilatere___init},
  {(bigint) polygone___Quadrilatere___diagonales},
  {(bigint) polygone___Polygone_____eqeq},
  {(bigint) polygone___Polygone___to_s},
  {(bigint) 4 /* 54: Parallelogramme < Parallelogramme: superclass init_table position */},
  {(bigint) polygone___Parallelogramme___init},
  {(bigint) polygone___Quadrilatere_____eqeq},
  {(bigint) polygone___Quadrilatere___to_s},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Parallelogramme::_sommets */
void INIT_ATTRIBUTES__Parallelogramme(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Parallelogramme;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Parallelogramme(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Parallelogramme;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Parallelogramme(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Parallelogramme;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_polygone___Polygone____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Parallelogramme_polygone___Parallelogramme___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 157;
  fra.me.meth = LOCATE_NEW_Parallelogramme_polygone___Parallelogramme___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./polygone.nit:157 */
  fra.me.REG[1] = NEW_Parallelogramme();
  INIT_ATTRIBUTES__Parallelogramme(fra.me.REG[1]);
  polygone___Parallelogramme___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Parallelogramme(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Losange[70] = {
  {(bigint) 299 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Losange < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Losange < Figure: superclass typecheck marker */},
  {(bigint) 91 /* 4: Losange < Polygone: superclass typecheck marker */},
  {(bigint) 187 /* 5: Losange < Quadrilatere: superclass typecheck marker */},
  {(bigint) 255 /* 6: Losange < Parallelogramme: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 299 /* 8: Losange < Losange: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Losange < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) polygone___Losange_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) polygone___Losange___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Losange < Figure: superclass init_table position */},
  {(bigint) polygone___Losange___aire},
  {(bigint) polygone___Polygone___perimetre},
  {(bigint) 2 /* 45: Losange < Polygone: superclass init_table position */},
  {(bigint) polygone___Polygone___sommets},
  {(bigint) polygone___Polygone___init},
  {(bigint) polygone___Polygone___cotes},
  {(bigint) 3 /* 49: Losange < Quadrilatere: superclass init_table position */},
  {(bigint) polygone___Quadrilatere___init},
  {(bigint) polygone___Quadrilatere___diagonales},
  {(bigint) polygone___Polygone_____eqeq},
  {(bigint) polygone___Polygone___to_s},
  {(bigint) 4 /* 54: Losange < Parallelogramme: superclass init_table position */},
  {(bigint) polygone___Parallelogramme___init},
  {(bigint) polygone___Quadrilatere_____eqeq},
  {(bigint) polygone___Quadrilatere___to_s},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 5 /* 64: Losange < Losange: superclass init_table position */},
  {(bigint) polygone___Losange___init},
  {(bigint) polygone___Losange___rectangleInscrit},
  {(bigint) polygone___Losange___cercleInscrit},
  {(bigint) polygone___Parallelogramme_____eqeq},
  {(bigint) polygone___Parallelogramme___to_s},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Losange::_sommets */
void INIT_ATTRIBUTES__Losange(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Losange;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Losange(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Losange;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Losange(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Losange;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_polygone___Polygone____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Losange_polygone___Losange___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 187;
  fra.me.meth = LOCATE_NEW_Losange_polygone___Losange___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./polygone.nit:187 */
  fra.me.REG[1] = NEW_Losange();
  INIT_ATTRIBUTES__Losange(fra.me.REG[1]);
  polygone___Losange___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Losange(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Rectangle[64] = {
  {(bigint) 295 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Rectangle < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Rectangle < Figure: superclass typecheck marker */},
  {(bigint) 91 /* 4: Rectangle < Polygone: superclass typecheck marker */},
  {(bigint) 187 /* 5: Rectangle < Quadrilatere: superclass typecheck marker */},
  {(bigint) 255 /* 6: Rectangle < Parallelogramme: superclass typecheck marker */},
  {(bigint) 295 /* 7: Rectangle < Rectangle: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Rectangle < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) polygone___Rectangle_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) polygone___Rectangle___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Rectangle < Figure: superclass init_table position */},
  {(bigint) polygone___Rectangle___aire},
  {(bigint) polygone___Polygone___perimetre},
  {(bigint) 2 /* 45: Rectangle < Polygone: superclass init_table position */},
  {(bigint) polygone___Polygone___sommets},
  {(bigint) polygone___Polygone___init},
  {(bigint) polygone___Polygone___cotes},
  {(bigint) 3 /* 49: Rectangle < Quadrilatere: superclass init_table position */},
  {(bigint) polygone___Quadrilatere___init},
  {(bigint) polygone___Quadrilatere___diagonales},
  {(bigint) polygone___Polygone_____eqeq},
  {(bigint) polygone___Polygone___to_s},
  {(bigint) 4 /* 54: Rectangle < Parallelogramme: superclass init_table position */},
  {(bigint) polygone___Parallelogramme___init},
  {(bigint) polygone___Quadrilatere_____eqeq},
  {(bigint) polygone___Quadrilatere___to_s},
  {(bigint) 5 /* 58: Rectangle < Rectangle: superclass init_table position */},
  {(bigint) polygone___Rectangle___init},
  {(bigint) polygone___Rectangle___cercleCirconscrit},
  {(bigint) polygone___Rectangle___losangeInscrit},
  {(bigint) polygone___Parallelogramme_____eqeq},
  {(bigint) polygone___Parallelogramme___to_s},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Rectangle::_sommets */
void INIT_ATTRIBUTES__Rectangle(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Rectangle;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Rectangle(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Rectangle;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Rectangle(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Rectangle;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_polygone___Polygone____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Rectangle_polygone___Rectangle___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 232;
  fra.me.meth = LOCATE_NEW_Rectangle_polygone___Rectangle___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./polygone.nit:232 */
  fra.me.REG[1] = NEW_Rectangle();
  INIT_ATTRIBUTES__Rectangle(fra.me.REG[1]);
  polygone___Rectangle___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Rectangle(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Carre[74] = {
  {(bigint) 331 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Carre < Object: superclass typecheck marker */},
  {(bigint) 51 /* 3: Carre < Figure: superclass typecheck marker */},
  {(bigint) 91 /* 4: Carre < Polygone: superclass typecheck marker */},
  {(bigint) 187 /* 5: Carre < Quadrilatere: superclass typecheck marker */},
  {(bigint) 255 /* 6: Carre < Parallelogramme: superclass typecheck marker */},
  {(bigint) 295 /* 7: Carre < Rectangle: superclass typecheck marker */},
  {(bigint) 299 /* 8: Carre < Losange: superclass typecheck marker */},
  {(bigint) 331 /* 9: Carre < Carre: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 1 /* 18: Carre < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) polygone___Carre_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) polygone___Carre___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 0 /* 42: Carre < Figure: superclass init_table position */},
  {(bigint) polygone___Carre___aire},
  {(bigint) polygone___Polygone___perimetre},
  {(bigint) 2 /* 45: Carre < Polygone: superclass init_table position */},
  {(bigint) polygone___Polygone___sommets},
  {(bigint) polygone___Polygone___init},
  {(bigint) polygone___Polygone___cotes},
  {(bigint) 3 /* 49: Carre < Quadrilatere: superclass init_table position */},
  {(bigint) polygone___Quadrilatere___init},
  {(bigint) polygone___Quadrilatere___diagonales},
  {(bigint) polygone___Polygone_____eqeq},
  {(bigint) polygone___Polygone___to_s},
  {(bigint) 4 /* 54: Carre < Parallelogramme: superclass init_table position */},
  {(bigint) polygone___Parallelogramme___init},
  {(bigint) polygone___Quadrilatere_____eqeq},
  {(bigint) polygone___Quadrilatere___to_s},
  {(bigint) 6 /* 58: Carre < Rectangle: superclass init_table position */},
  {(bigint) polygone___Rectangle___init},
  {(bigint) polygone___Rectangle___cercleCirconscrit},
  {(bigint) polygone___Rectangle___losangeInscrit},
  {(bigint) polygone___Parallelogramme_____eqeq},
  {(bigint) polygone___Parallelogramme___to_s},
  {(bigint) 5 /* 64: Carre < Losange: superclass init_table position */},
  {(bigint) polygone___Losange___init},
  {(bigint) polygone___Losange___rectangleInscrit},
  {(bigint) polygone___Losange___cercleInscrit},
  {(bigint) polygone___Rectangle_____eqeq},
  {(bigint) polygone___Rectangle___to_s},
  {(bigint) 7 /* 70: Carre < Carre: superclass init_table position */},
  {(bigint) polygone___Carre___init},
  {(bigint) polygone___Losange_____eqeq},
  {(bigint) polygone___Losange___to_s},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Carre::_sommets */
void INIT_ATTRIBUTES__Carre(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Carre;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Carre(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_Carre;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Carre(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Carre;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_polygone___Polygone____sommets(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_sommets", LOCATE_main, 0);
  }
  stack_frame_head = fra.me.prev;
}
val_t NEW_Carre_polygone___Carre___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 280;
  fra.me.meth = LOCATE_NEW_Carre_polygone___Carre___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* ./polygone.nit:280 */
  fra.me.REG[1] = NEW_Carre();
  INIT_ATTRIBUTES__Carre(fra.me.REG[1]);
  polygone___Carre___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_Carre(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_Fabrique[45] = {
  {(bigint) 55 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) 3 /* 2: Fabrique < Object: superclass typecheck marker */},
  {(bigint) 55 /* 3: Fabrique < Fabrique: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) time___Object___get_time},
  {(bigint) 0 /* 18: Fabrique < Object: superclass init_table position */},
  {(bigint) kernel___Object___object_id},
  {(bigint) kernel___Object___is_same_type},
  {(bigint) kernel___Object_____eqeq},
  {(bigint) kernel___Object_____neq},
  {(bigint) kernel___Object___output},
  {(bigint) kernel___Object___exit},
  {(bigint) kernel___Object___sys},
  {(bigint) file___Object___printn},
  {(bigint) file___Object___print},
  {(bigint) file___Object___getc},
  {(bigint) file___Object___gets},
  {(bigint) file___Object___stdin},
  {(bigint) file___Object___stdout},
  {(bigint) file___Object___stderr},
  {(bigint) string___Object___to_s},
  {(bigint) string___Object___inspect},
  {(bigint) string___Object___inspect_head},
  {(bigint) string___Object___args},
  {(bigint) hash___Object___hash},
  {(bigint) math___Object___atan2},
  {(bigint) math___Object___pi},
  {(bigint) math___Object___srand_from},
  {(bigint) math___Object___srand},
  {(bigint) 1 /* 42: Fabrique < Fabrique: superclass init_table position */},
  {(bigint) factory___Fabrique___creerPolygone},
  {(bigint) factory___Fabrique___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
void INIT_ATTRIBUTES__Fabrique(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__Fabrique;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Fabrique(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_Fabrique;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
void CHECKNEW_Fabrique(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_Fabrique;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_Fabrique_factory___Fabrique___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_main;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_Fabrique_factory___Fabrique___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_Fabrique();
  INIT_ATTRIBUTES__Fabrique(fra.me.REG[0]);
  factory___Fabrique___init(fra.me.REG[0], init_table);
  CHECKNEW_Fabrique(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
classtable_t TAG2VFT[4] = {NULL, (const classtable_t)VFT_Int, (const classtable_t)VFT_Char, (const classtable_t)VFT_Bool};
int main(int argc, char **argv) {
  prepare_signals();
  glob_argc = argc; glob_argv = argv;
  G_sys = NEW_Sys();
  register_static_object(&G_sys);
  main___Sys___main(G_sys);
  return 0;
}
