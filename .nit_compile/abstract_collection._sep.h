/* This C header file is generated by NIT to compile modules and programs that requires abstract_collection. */
#ifndef abstract_collection_sep
#define abstract_collection_sep
#include "kernel._sep.h"
#include <nit_common.h>

extern const classtable_elt_t VFT_Collection[];

extern const classtable_elt_t VFT_NaiveCollection[];

extern const classtable_elt_t VFT_Iterator[];

extern const classtable_elt_t VFT_Container[];

extern const classtable_elt_t VFT_ContainerIterator[];

extern const classtable_elt_t VFT_RemovableCollection[];

extern const classtable_elt_t VFT_SimpleCollection[];

extern const classtable_elt_t VFT_Set[];

extern const classtable_elt_t VFT_MapRead[];

extern const classtable_elt_t VFT_Map[];

extern const classtable_elt_t VFT_MapIterator[];

extern const classtable_elt_t VFT_SequenceRead[];

extern const classtable_elt_t VFT_Sequence[];

extern const classtable_elt_t VFT_IndexedIterator[];

extern const classtable_elt_t VFT_CoupleMap[];

extern const classtable_elt_t VFT_CoupleMapIterator[];

extern const classtable_elt_t VFT_Couple[];
extern const char *LOCATE_abstract_collection;
extern const int SFT_abstract_collection[];
#define ID_Collection (SFT_abstract_collection[0])
#define COLOR_Collection (SFT_abstract_collection[1])
#define INIT_TABLE_POS_Collection (SFT_abstract_collection[2] + 0)
#define CALL_abstract_collection___Collection___iterator(recv) ((abstract_collection___Collection___iterator_t)CALL((recv), (SFT_abstract_collection[2] + 1)))
#define CALL_abstract_collection___Collection___iterate(recv) ((abstract_collection___Collection___iterate_t)CALL((recv), (SFT_abstract_collection[2] + 2)))
#define CALL_abstract_collection___Collection___is_empty(recv) ((abstract_collection___Collection___is_empty_t)CALL((recv), (SFT_abstract_collection[2] + 3)))
#define CALL_abstract_collection___Collection___length(recv) ((abstract_collection___Collection___length_t)CALL((recv), (SFT_abstract_collection[2] + 4)))
#define CALL_abstract_collection___Collection___has(recv) ((abstract_collection___Collection___has_t)CALL((recv), (SFT_abstract_collection[2] + 5)))
#define CALL_abstract_collection___Collection___has_only(recv) ((abstract_collection___Collection___has_only_t)CALL((recv), (SFT_abstract_collection[2] + 6)))
#define CALL_abstract_collection___Collection___count(recv) ((abstract_collection___Collection___count_t)CALL((recv), (SFT_abstract_collection[2] + 7)))
#define CALL_abstract_collection___Collection___first(recv) ((abstract_collection___Collection___first_t)CALL((recv), (SFT_abstract_collection[2] + 8)))
#define ID_NaiveCollection (SFT_abstract_collection[3])
#define COLOR_NaiveCollection (SFT_abstract_collection[4])
#define INIT_TABLE_POS_NaiveCollection (SFT_abstract_collection[5] + 0)
#define ID_Iterator (SFT_abstract_collection[6])
#define COLOR_Iterator (SFT_abstract_collection[7])
#define INIT_TABLE_POS_Iterator (SFT_abstract_collection[8] + 0)
#define CALL_abstract_collection___Iterator___item(recv) ((abstract_collection___Iterator___item_t)CALL((recv), (SFT_abstract_collection[8] + 1)))
#define CALL_abstract_collection___Iterator___next(recv) ((abstract_collection___Iterator___next_t)CALL((recv), (SFT_abstract_collection[8] + 2)))
#define CALL_abstract_collection___Iterator___is_ok(recv) ((abstract_collection___Iterator___is_ok_t)CALL((recv), (SFT_abstract_collection[8] + 3)))
#define ID_Container (SFT_abstract_collection[9])
#define COLOR_Container (SFT_abstract_collection[10])
#define ATTR_abstract_collection___Container____item(recv) ATTR(recv, (SFT_abstract_collection[11] + 0))
#define INIT_TABLE_POS_Container (SFT_abstract_collection[12] + 0)
#define CALL_abstract_collection___Container___init(recv) ((abstract_collection___Container___init_t)CALL((recv), (SFT_abstract_collection[12] + 1)))
#define CALL_abstract_collection___Container___item(recv) ((abstract_collection___Container___item_t)CALL((recv), (SFT_abstract_collection[12] + 2)))
#define CALL_abstract_collection___Container___item__eq(recv) ((abstract_collection___Container___item__eq_t)CALL((recv), (SFT_abstract_collection[12] + 3)))
#define ID_ContainerIterator (SFT_abstract_collection[13])
#define COLOR_ContainerIterator (SFT_abstract_collection[14])
#define ATTR_abstract_collection___ContainerIterator____is_ok(recv) ATTR(recv, (SFT_abstract_collection[15] + 0))
#define ATTR_abstract_collection___ContainerIterator____container(recv) ATTR(recv, (SFT_abstract_collection[15] + 1))
#define INIT_TABLE_POS_ContainerIterator (SFT_abstract_collection[16] + 0)
#define CALL_abstract_collection___ContainerIterator___init(recv) ((abstract_collection___ContainerIterator___init_t)CALL((recv), (SFT_abstract_collection[16] + 1)))
#define ID_RemovableCollection (SFT_abstract_collection[17])
#define COLOR_RemovableCollection (SFT_abstract_collection[18])
#define INIT_TABLE_POS_RemovableCollection (SFT_abstract_collection[19] + 0)
#define CALL_abstract_collection___RemovableCollection___clear(recv) ((abstract_collection___RemovableCollection___clear_t)CALL((recv), (SFT_abstract_collection[19] + 1)))
#define CALL_abstract_collection___RemovableCollection___remove(recv) ((abstract_collection___RemovableCollection___remove_t)CALL((recv), (SFT_abstract_collection[19] + 2)))
#define CALL_abstract_collection___RemovableCollection___remove_all(recv) ((abstract_collection___RemovableCollection___remove_all_t)CALL((recv), (SFT_abstract_collection[19] + 3)))
#define ID_SimpleCollection (SFT_abstract_collection[20])
#define COLOR_SimpleCollection (SFT_abstract_collection[21])
#define INIT_TABLE_POS_SimpleCollection (SFT_abstract_collection[22] + 0)
#define CALL_abstract_collection___SimpleCollection___add(recv) ((abstract_collection___SimpleCollection___add_t)CALL((recv), (SFT_abstract_collection[22] + 1)))
#define CALL_abstract_collection___SimpleCollection___add_all(recv) ((abstract_collection___SimpleCollection___add_all_t)CALL((recv), (SFT_abstract_collection[22] + 2)))
#define ID_Set (SFT_abstract_collection[23])
#define COLOR_Set (SFT_abstract_collection[24])
#define INIT_TABLE_POS_Set (SFT_abstract_collection[25] + 0)
#define ID_MapRead (SFT_abstract_collection[26])
#define COLOR_MapRead (SFT_abstract_collection[27])
#define INIT_TABLE_POS_MapRead (SFT_abstract_collection[28] + 0)
#define CALL_abstract_collection___MapRead_____bra(recv) ((abstract_collection___MapRead_____bra_t)CALL((recv), (SFT_abstract_collection[28] + 1)))
#define CALL_abstract_collection___MapRead___has_key(recv) ((abstract_collection___MapRead___has_key_t)CALL((recv), (SFT_abstract_collection[28] + 2)))
#define ID_Map (SFT_abstract_collection[29])
#define COLOR_Map (SFT_abstract_collection[30])
#define INIT_TABLE_POS_Map (SFT_abstract_collection[31] + 0)
#define CALL_abstract_collection___Map_____braeq(recv) ((abstract_collection___Map_____braeq_t)CALL((recv), (SFT_abstract_collection[31] + 1)))
#define CALL_abstract_collection___Map___remove_at(recv) ((abstract_collection___Map___remove_at_t)CALL((recv), (SFT_abstract_collection[31] + 2)))
#define CALL_abstract_collection___Map___recover_with(recv) ((abstract_collection___Map___recover_with_t)CALL((recv), (SFT_abstract_collection[31] + 3)))
#define ID_MapIterator (SFT_abstract_collection[32])
#define COLOR_MapIterator (SFT_abstract_collection[33])
#define INIT_TABLE_POS_MapIterator (SFT_abstract_collection[34] + 0)
#define CALL_abstract_collection___MapIterator___key(recv) ((abstract_collection___MapIterator___key_t)CALL((recv), (SFT_abstract_collection[34] + 1)))
#define ID_SequenceRead (SFT_abstract_collection[35])
#define COLOR_SequenceRead (SFT_abstract_collection[36])
#define INIT_TABLE_POS_SequenceRead (SFT_abstract_collection[37] + 0)
#define CALL_abstract_collection___SequenceRead___last(recv) ((abstract_collection___SequenceRead___last_t)CALL((recv), (SFT_abstract_collection[37] + 1)))
#define CALL_abstract_collection___SequenceRead___index_of(recv) ((abstract_collection___SequenceRead___index_of_t)CALL((recv), (SFT_abstract_collection[37] + 2)))
#define ID_Sequence (SFT_abstract_collection[38])
#define COLOR_Sequence (SFT_abstract_collection[39])
#define INIT_TABLE_POS_Sequence (SFT_abstract_collection[40] + 0)
#define CALL_abstract_collection___Sequence___first__eq(recv) ((abstract_collection___Sequence___first__eq_t)CALL((recv), (SFT_abstract_collection[40] + 1)))
#define CALL_abstract_collection___Sequence___last__eq(recv) ((abstract_collection___Sequence___last__eq_t)CALL((recv), (SFT_abstract_collection[40] + 2)))
#define CALL_abstract_collection___Sequence___push(recv) ((abstract_collection___Sequence___push_t)CALL((recv), (SFT_abstract_collection[40] + 3)))
#define CALL_abstract_collection___Sequence___append(recv) ((abstract_collection___Sequence___append_t)CALL((recv), (SFT_abstract_collection[40] + 4)))
#define CALL_abstract_collection___Sequence___pop(recv) ((abstract_collection___Sequence___pop_t)CALL((recv), (SFT_abstract_collection[40] + 5)))
#define CALL_abstract_collection___Sequence___unshift(recv) ((abstract_collection___Sequence___unshift_t)CALL((recv), (SFT_abstract_collection[40] + 6)))
#define CALL_abstract_collection___Sequence___shift(recv) ((abstract_collection___Sequence___shift_t)CALL((recv), (SFT_abstract_collection[40] + 7)))
#define ID_IndexedIterator (SFT_abstract_collection[41])
#define COLOR_IndexedIterator (SFT_abstract_collection[42])
#define INIT_TABLE_POS_IndexedIterator (SFT_abstract_collection[43] + 0)
#define CALL_abstract_collection___IndexedIterator___index(recv) ((abstract_collection___IndexedIterator___index_t)CALL((recv), (SFT_abstract_collection[43] + 1)))
#define ID_CoupleMap (SFT_abstract_collection[44])
#define COLOR_CoupleMap (SFT_abstract_collection[45])
#define INIT_TABLE_POS_CoupleMap (SFT_abstract_collection[46] + 0)
#define CALL_abstract_collection___CoupleMap___couple_at(recv) ((abstract_collection___CoupleMap___couple_at_t)CALL((recv), (SFT_abstract_collection[46] + 1)))
#define ID_CoupleMapIterator (SFT_abstract_collection[47])
#define COLOR_CoupleMapIterator (SFT_abstract_collection[48])
#define ATTR_abstract_collection___CoupleMapIterator____iter(recv) ATTR(recv, (SFT_abstract_collection[49] + 0))
#define INIT_TABLE_POS_CoupleMapIterator (SFT_abstract_collection[50] + 0)
#define CALL_abstract_collection___CoupleMapIterator___init(recv) ((abstract_collection___CoupleMapIterator___init_t)CALL((recv), (SFT_abstract_collection[50] + 1)))
#define ID_Couple (SFT_abstract_collection[51])
#define COLOR_Couple (SFT_abstract_collection[52])
#define ATTR_abstract_collection___Couple____first(recv) ATTR(recv, (SFT_abstract_collection[53] + 0))
#define ATTR_abstract_collection___Couple____second(recv) ATTR(recv, (SFT_abstract_collection[53] + 1))
#define INIT_TABLE_POS_Couple (SFT_abstract_collection[54] + 0)
#define CALL_abstract_collection___Couple___first(recv) ((abstract_collection___Couple___first_t)CALL((recv), (SFT_abstract_collection[54] + 1)))
#define CALL_abstract_collection___Couple___first__eq(recv) ((abstract_collection___Couple___first__eq_t)CALL((recv), (SFT_abstract_collection[54] + 2)))
#define CALL_abstract_collection___Couple___second(recv) ((abstract_collection___Couple___second_t)CALL((recv), (SFT_abstract_collection[54] + 3)))
#define CALL_abstract_collection___Couple___second__eq(recv) ((abstract_collection___Couple___second__eq_t)CALL((recv), (SFT_abstract_collection[54] + 4)))
#define CALL_abstract_collection___Couple___init(recv) ((abstract_collection___Couple___init_t)CALL((recv), (SFT_abstract_collection[54] + 5)))
static const char * const LOCATE_abstract_collection___Collection___iterator = "abstract_collection::Collection::iterator";
val_t abstract_collection___Collection___iterator(val_t p0);
typedef val_t (*abstract_collection___Collection___iterator_t)(val_t p0);
typedef void (*CLOS_abstract_collection___Collection___iterate_0)(struct stack_frame_t *, val_t);
static const char * const LOCATE_abstract_collection___Collection___iterate = "abstract_collection::Collection::iterate";
void abstract_collection___Collection___iterate(val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
typedef void (*abstract_collection___Collection___iterate_t)(val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
static const char * const LOCATE_abstract_collection___Collection___is_empty = "abstract_collection::Collection::is_empty";
val_t abstract_collection___Collection___is_empty(val_t p0);
typedef val_t (*abstract_collection___Collection___is_empty_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Collection___length = "abstract_collection::Collection::length";
val_t abstract_collection___Collection___length(val_t p0);
typedef val_t (*abstract_collection___Collection___length_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Collection___has = "abstract_collection::Collection::has";
val_t abstract_collection___Collection___has(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Collection___has_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Collection___has_only = "abstract_collection::Collection::has_only";
val_t abstract_collection___Collection___has_only(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Collection___has_only_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Collection___count = "abstract_collection::Collection::count";
val_t abstract_collection___Collection___count(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Collection___count_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Collection___first = "abstract_collection::Collection::first";
val_t abstract_collection___Collection___first(val_t p0);
typedef val_t (*abstract_collection___Collection___first_t)(val_t p0);
static const char * const LOCATE_abstract_collection___NaiveCollection___is_empty = "abstract_collection::NaiveCollection::(abstract_collection::Collection::is_empty)";
val_t abstract_collection___NaiveCollection___is_empty(val_t p0);
typedef val_t (*abstract_collection___NaiveCollection___is_empty_t)(val_t p0);
static const char * const LOCATE_abstract_collection___NaiveCollection___length = "abstract_collection::NaiveCollection::(abstract_collection::Collection::length)";
val_t abstract_collection___NaiveCollection___length(val_t p0);
typedef val_t (*abstract_collection___NaiveCollection___length_t)(val_t p0);
  typedef void (*CLOS_OC_abstract_collection___NaiveCollection___length_1_0)(struct stack_frame_t *);
  void OC_abstract_collection___NaiveCollection___length_1(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
  typedef void (*OC_abstract_collection___NaiveCollection___length_1_t)(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
static const char * const LOCATE_abstract_collection___NaiveCollection___has = "abstract_collection::NaiveCollection::(abstract_collection::Collection::has)";
val_t abstract_collection___NaiveCollection___has(val_t p0, val_t p1);
typedef val_t (*abstract_collection___NaiveCollection___has_t)(val_t p0, val_t p1);
  typedef void (*CLOS_OC_abstract_collection___NaiveCollection___has_1_0)(struct stack_frame_t *);
  void OC_abstract_collection___NaiveCollection___has_1(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
  typedef void (*OC_abstract_collection___NaiveCollection___has_1_t)(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
static const char * const LOCATE_abstract_collection___NaiveCollection___has_only = "abstract_collection::NaiveCollection::(abstract_collection::Collection::has_only)";
val_t abstract_collection___NaiveCollection___has_only(val_t p0, val_t p1);
typedef val_t (*abstract_collection___NaiveCollection___has_only_t)(val_t p0, val_t p1);
  typedef void (*CLOS_OC_abstract_collection___NaiveCollection___has_only_1_0)(struct stack_frame_t *);
  void OC_abstract_collection___NaiveCollection___has_only_1(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
  typedef void (*OC_abstract_collection___NaiveCollection___has_only_1_t)(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
static const char * const LOCATE_abstract_collection___NaiveCollection___count = "abstract_collection::NaiveCollection::(abstract_collection::Collection::count)";
val_t abstract_collection___NaiveCollection___count(val_t p0, val_t p1);
typedef val_t (*abstract_collection___NaiveCollection___count_t)(val_t p0, val_t p1);
  typedef void (*CLOS_OC_abstract_collection___NaiveCollection___count_1_0)(struct stack_frame_t *);
  void OC_abstract_collection___NaiveCollection___count_1(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
  typedef void (*OC_abstract_collection___NaiveCollection___count_1_t)(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
static const char * const LOCATE_abstract_collection___NaiveCollection___first = "abstract_collection::NaiveCollection::(abstract_collection::Collection::first)";
val_t abstract_collection___NaiveCollection___first(val_t p0);
typedef val_t (*abstract_collection___NaiveCollection___first_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Iterator___item = "abstract_collection::Iterator::item";
val_t abstract_collection___Iterator___item(val_t p0);
typedef val_t (*abstract_collection___Iterator___item_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Iterator___next = "abstract_collection::Iterator::next";
void abstract_collection___Iterator___next(val_t p0);
typedef void (*abstract_collection___Iterator___next_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Iterator___is_ok = "abstract_collection::Iterator::is_ok";
val_t abstract_collection___Iterator___is_ok(val_t p0);
typedef val_t (*abstract_collection___Iterator___is_ok_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Container___first = "abstract_collection::Container::(abstract_collection::Collection::first)";
val_t abstract_collection___Container___first(val_t p0);
typedef val_t (*abstract_collection___Container___first_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Container___is_empty = "abstract_collection::Container::(abstract_collection::Collection::is_empty)";
val_t abstract_collection___Container___is_empty(val_t p0);
typedef val_t (*abstract_collection___Container___is_empty_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Container___length = "abstract_collection::Container::(abstract_collection::Collection::length)";
val_t abstract_collection___Container___length(val_t p0);
typedef val_t (*abstract_collection___Container___length_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Container___has = "abstract_collection::Container::(abstract_collection::Collection::has)";
val_t abstract_collection___Container___has(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Container___has_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Container___has_only = "abstract_collection::Container::(abstract_collection::Collection::has_only)";
val_t abstract_collection___Container___has_only(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Container___has_only_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Container___count = "abstract_collection::Container::(abstract_collection::Collection::count)";
val_t abstract_collection___Container___count(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Container___count_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Container___iterator = "abstract_collection::Container::(abstract_collection::Collection::iterator)";
val_t abstract_collection___Container___iterator(val_t p0);
typedef val_t (*abstract_collection___Container___iterator_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Container___init = "abstract_collection::Container::init";
void abstract_collection___Container___init(val_t p0, val_t p1, int* init_table);
typedef void (*abstract_collection___Container___init_t)(val_t p0, val_t p1, int* init_table);
val_t NEW_Container_abstract_collection___Container___init(val_t p0);
static const char * const LOCATE_abstract_collection___Container___item = "abstract_collection::Container::item";
val_t abstract_collection___Container___item(val_t p0);
typedef val_t (*abstract_collection___Container___item_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Container___item__eq = "abstract_collection::Container::item=";
void abstract_collection___Container___item__eq(val_t p0, val_t p1);
typedef void (*abstract_collection___Container___item__eq_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___ContainerIterator___item = "abstract_collection::ContainerIterator::(abstract_collection::Iterator::item)";
val_t abstract_collection___ContainerIterator___item(val_t p0);
typedef val_t (*abstract_collection___ContainerIterator___item_t)(val_t p0);
static const char * const LOCATE_abstract_collection___ContainerIterator___next = "abstract_collection::ContainerIterator::(abstract_collection::Iterator::next)";
void abstract_collection___ContainerIterator___next(val_t p0);
typedef void (*abstract_collection___ContainerIterator___next_t)(val_t p0);
static const char * const LOCATE_abstract_collection___ContainerIterator___init = "abstract_collection::ContainerIterator::init";
void abstract_collection___ContainerIterator___init(val_t p0, val_t p1, int* init_table);
typedef void (*abstract_collection___ContainerIterator___init_t)(val_t p0, val_t p1, int* init_table);
val_t NEW_ContainerIterator_abstract_collection___ContainerIterator___init(val_t p0);
static const char * const LOCATE_abstract_collection___ContainerIterator___is_ok = "abstract_collection::ContainerIterator::(abstract_collection::Iterator::is_ok)";
val_t abstract_collection___ContainerIterator___is_ok(val_t p0);
typedef val_t (*abstract_collection___ContainerIterator___is_ok_t)(val_t p0);
static const char * const LOCATE_abstract_collection___RemovableCollection___clear = "abstract_collection::RemovableCollection::clear";
void abstract_collection___RemovableCollection___clear(val_t p0);
typedef void (*abstract_collection___RemovableCollection___clear_t)(val_t p0);
static const char * const LOCATE_abstract_collection___RemovableCollection___remove = "abstract_collection::RemovableCollection::remove";
void abstract_collection___RemovableCollection___remove(val_t p0, val_t p1);
typedef void (*abstract_collection___RemovableCollection___remove_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___RemovableCollection___remove_all = "abstract_collection::RemovableCollection::remove_all";
void abstract_collection___RemovableCollection___remove_all(val_t p0, val_t p1);
typedef void (*abstract_collection___RemovableCollection___remove_all_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___SimpleCollection___add = "abstract_collection::SimpleCollection::add";
void abstract_collection___SimpleCollection___add(val_t p0, val_t p1);
typedef void (*abstract_collection___SimpleCollection___add_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___SimpleCollection___add_all = "abstract_collection::SimpleCollection::add_all";
void abstract_collection___SimpleCollection___add_all(val_t p0, val_t p1);
typedef void (*abstract_collection___SimpleCollection___add_all_t)(val_t p0, val_t p1);
  typedef void (*CLOS_OC_abstract_collection___SimpleCollection___add_all_1_0)(struct stack_frame_t *);
  void OC_abstract_collection___SimpleCollection___add_all_1(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
  typedef void (*OC_abstract_collection___SimpleCollection___add_all_1_t)(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
static const char * const LOCATE_abstract_collection___Set___has_only = "abstract_collection::Set::(abstract_collection::Collection::has_only)";
val_t abstract_collection___Set___has_only(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Set___has_only_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Set___count = "abstract_collection::Set::(abstract_collection::Collection::count)";
val_t abstract_collection___Set___count(val_t p0, val_t p1);
typedef val_t (*abstract_collection___Set___count_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Set___remove_all = "abstract_collection::Set::(abstract_collection::RemovableCollection::remove_all)";
void abstract_collection___Set___remove_all(val_t p0, val_t p1);
typedef void (*abstract_collection___Set___remove_all_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___MapRead_____bra = "abstract_collection::MapRead::[]";
val_t abstract_collection___MapRead_____bra(val_t p0, val_t p1);
typedef val_t (*abstract_collection___MapRead_____bra_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___MapRead___has_key = "abstract_collection::MapRead::has_key";
val_t abstract_collection___MapRead___has_key(val_t p0, val_t p1);
typedef val_t (*abstract_collection___MapRead___has_key_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___MapRead___iterator = "abstract_collection::MapRead::(abstract_collection::Collection::iterator)";
val_t abstract_collection___MapRead___iterator(val_t p0);
typedef val_t (*abstract_collection___MapRead___iterator_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Map_____braeq = "abstract_collection::Map::[]=";
void abstract_collection___Map_____braeq(val_t p0, val_t p1, val_t p2);
typedef void (*abstract_collection___Map_____braeq_t)(val_t p0, val_t p1, val_t p2);
static const char * const LOCATE_abstract_collection___Map___remove_at = "abstract_collection::Map::remove_at";
void abstract_collection___Map___remove_at(val_t p0, val_t p1);
typedef void (*abstract_collection___Map___remove_at_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Map___recover_with = "abstract_collection::Map::recover_with";
void abstract_collection___Map___recover_with(val_t p0, val_t p1);
typedef void (*abstract_collection___Map___recover_with_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___MapIterator___key = "abstract_collection::MapIterator::key";
val_t abstract_collection___MapIterator___key(val_t p0);
typedef val_t (*abstract_collection___MapIterator___key_t)(val_t p0);
static const char * const LOCATE_abstract_collection___SequenceRead___first = "abstract_collection::SequenceRead::(abstract_collection::Collection::first)";
val_t abstract_collection___SequenceRead___first(val_t p0);
typedef val_t (*abstract_collection___SequenceRead___first_t)(val_t p0);
static const char * const LOCATE_abstract_collection___SequenceRead___last = "abstract_collection::SequenceRead::last";
val_t abstract_collection___SequenceRead___last(val_t p0);
typedef val_t (*abstract_collection___SequenceRead___last_t)(val_t p0);
static const char * const LOCATE_abstract_collection___SequenceRead___index_of = "abstract_collection::SequenceRead::index_of";
val_t abstract_collection___SequenceRead___index_of(val_t p0, val_t p1);
typedef val_t (*abstract_collection___SequenceRead___index_of_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___SequenceRead___iterator = "abstract_collection::SequenceRead::(abstract_collection::Collection::iterator)";
val_t abstract_collection___SequenceRead___iterator(val_t p0);
typedef val_t (*abstract_collection___SequenceRead___iterator_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Sequence___first__eq = "abstract_collection::Sequence::first=";
void abstract_collection___Sequence___first__eq(val_t p0, val_t p1);
typedef void (*abstract_collection___Sequence___first__eq_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Sequence___last__eq = "abstract_collection::Sequence::last=";
void abstract_collection___Sequence___last__eq(val_t p0, val_t p1);
typedef void (*abstract_collection___Sequence___last__eq_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Sequence___add = "abstract_collection::Sequence::(abstract_collection::SimpleCollection::add)";
void abstract_collection___Sequence___add(val_t p0, val_t p1);
typedef void (*abstract_collection___Sequence___add_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Sequence___push = "abstract_collection::Sequence::push";
void abstract_collection___Sequence___push(val_t p0, val_t p1);
typedef void (*abstract_collection___Sequence___push_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Sequence___append = "abstract_collection::Sequence::append";
void abstract_collection___Sequence___append(val_t p0, val_t p1);
typedef void (*abstract_collection___Sequence___append_t)(val_t p0, val_t p1);
  typedef void (*CLOS_OC_abstract_collection___Sequence___append_1_0)(struct stack_frame_t *);
  void OC_abstract_collection___Sequence___append_1(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
  typedef void (*OC_abstract_collection___Sequence___append_1_t)(struct stack_frame_t *closctx, val_t p0, struct stack_frame_t *closctx_param, fun_t clos_fun0);
static const char * const LOCATE_abstract_collection___Sequence___pop = "abstract_collection::Sequence::pop";
val_t abstract_collection___Sequence___pop(val_t p0);
typedef val_t (*abstract_collection___Sequence___pop_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Sequence___unshift = "abstract_collection::Sequence::unshift";
void abstract_collection___Sequence___unshift(val_t p0, val_t p1);
typedef void (*abstract_collection___Sequence___unshift_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Sequence___shift = "abstract_collection::Sequence::shift";
val_t abstract_collection___Sequence___shift(val_t p0);
typedef val_t (*abstract_collection___Sequence___shift_t)(val_t p0);
static const char * const LOCATE_abstract_collection___IndexedIterator___index = "abstract_collection::IndexedIterator::index";
val_t abstract_collection___IndexedIterator___index(val_t p0);
typedef val_t (*abstract_collection___IndexedIterator___index_t)(val_t p0);
static const char * const LOCATE_abstract_collection___IndexedIterator___key = "abstract_collection::IndexedIterator::(abstract_collection::MapIterator::key)";
val_t abstract_collection___IndexedIterator___key(val_t p0);
typedef val_t (*abstract_collection___IndexedIterator___key_t)(val_t p0);
static const char * const LOCATE_abstract_collection___CoupleMap___couple_at = "abstract_collection::CoupleMap::couple_at";
val_t abstract_collection___CoupleMap___couple_at(val_t p0, val_t p1);
typedef val_t (*abstract_collection___CoupleMap___couple_at_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___CoupleMap_____bra = "abstract_collection::CoupleMap::(abstract_collection::MapRead::[])";
val_t abstract_collection___CoupleMap_____bra(val_t p0, val_t p1);
typedef val_t (*abstract_collection___CoupleMap_____bra_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___CoupleMap___has_key = "abstract_collection::CoupleMap::(abstract_collection::MapRead::has_key)";
val_t abstract_collection___CoupleMap___has_key(val_t p0, val_t p1);
typedef val_t (*abstract_collection___CoupleMap___has_key_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___CoupleMapIterator___item = "abstract_collection::CoupleMapIterator::(abstract_collection::Iterator::item)";
val_t abstract_collection___CoupleMapIterator___item(val_t p0);
typedef val_t (*abstract_collection___CoupleMapIterator___item_t)(val_t p0);
static const char * const LOCATE_abstract_collection___CoupleMapIterator___key = "abstract_collection::CoupleMapIterator::(abstract_collection::MapIterator::key)";
val_t abstract_collection___CoupleMapIterator___key(val_t p0);
typedef val_t (*abstract_collection___CoupleMapIterator___key_t)(val_t p0);
static const char * const LOCATE_abstract_collection___CoupleMapIterator___is_ok = "abstract_collection::CoupleMapIterator::(abstract_collection::Iterator::is_ok)";
val_t abstract_collection___CoupleMapIterator___is_ok(val_t p0);
typedef val_t (*abstract_collection___CoupleMapIterator___is_ok_t)(val_t p0);
static const char * const LOCATE_abstract_collection___CoupleMapIterator___next = "abstract_collection::CoupleMapIterator::(abstract_collection::Iterator::next)";
void abstract_collection___CoupleMapIterator___next(val_t p0);
typedef void (*abstract_collection___CoupleMapIterator___next_t)(val_t p0);
static const char * const LOCATE_abstract_collection___CoupleMapIterator___init = "abstract_collection::CoupleMapIterator::init";
void abstract_collection___CoupleMapIterator___init(val_t p0, val_t p1, int* init_table);
typedef void (*abstract_collection___CoupleMapIterator___init_t)(val_t p0, val_t p1, int* init_table);
val_t NEW_CoupleMapIterator_abstract_collection___CoupleMapIterator___init(val_t p0);
static const char * const LOCATE_abstract_collection___Couple___first = "abstract_collection::Couple::first";
val_t abstract_collection___Couple___first(val_t p0);
typedef val_t (*abstract_collection___Couple___first_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Couple___first__eq = "abstract_collection::Couple::first=";
void abstract_collection___Couple___first__eq(val_t p0, val_t p1);
typedef void (*abstract_collection___Couple___first__eq_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Couple___second = "abstract_collection::Couple::second";
val_t abstract_collection___Couple___second(val_t p0);
typedef val_t (*abstract_collection___Couple___second_t)(val_t p0);
static const char * const LOCATE_abstract_collection___Couple___second__eq = "abstract_collection::Couple::second=";
void abstract_collection___Couple___second__eq(val_t p0, val_t p1);
typedef void (*abstract_collection___Couple___second__eq_t)(val_t p0, val_t p1);
static const char * const LOCATE_abstract_collection___Couple___init = "abstract_collection::Couple::init";
void abstract_collection___Couple___init(val_t p0, val_t p1, val_t p2, int* init_table);
typedef void (*abstract_collection___Couple___init_t)(val_t p0, val_t p1, val_t p2, int* init_table);
val_t NEW_Couple_abstract_collection___Couple___init(val_t p0, val_t p1);
#endif
