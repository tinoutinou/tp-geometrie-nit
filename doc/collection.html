<html><head><title>Module collection</title></head>
<body>
<table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td bgcolor="#eeeeff">
<a href="overview.html"><b>Overview</b></a>&nbsp; <a href="index-1.html"><b>Index</b></a>&nbsp; <a href="index.html" target="_top"><b>With Frames</b></a>
</td></tr></table>Visibility: <b>Public</b>&nbsp; <a href="collection_.html"><b>Inside</b></a>&nbsp; <a href="collection__.html"><b>Intrude</b></a>&nbsp; <br/><h1>Module collection</h1>
<dl><a href="standard.html">standard</a>::<br/>module <b>collection</b><br/>
<dt>Imported modules: <dd><a href="hash.html">hash</a>
</dl>
<pre> This module define several collection classes.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2"><big>Class Summary of collection</big></th><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_AbstractArray">AbstractArray</a></b>[E: nullable Object]<br/> Resizeable one dimention array of objects.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a></b>[E: nullable Object]<br/> One dimention array of objects.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_AbstractSorter">AbstractSorter</a></b>[E: <a href="kernel.html#CLASS_Object">Object</a>]<br/> This abstract class generalizes ways to sort an array
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Array">Array</a></b>[E: nullable Object]<br/> Resizeable one dimention array of objects.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ArrayCapable">ArrayCapable</a></b>[E: nullable Object]<br/> Subclasses of this class can create native arrays
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ArrayIterator">ArrayIterator</a></b>[E: nullable Object]<br/> An `Iterator' on `AbstractArray'
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ArrayMap">ArrayMap</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]<br/> Associative arrays implemented with an array of (key, value) pairs.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ArraySet">ArraySet</a></b>[E: <a href="kernel.html#CLASS_Object">Object</a>]<br/> A set implemented with an Array.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ArraySetIterator">ArraySetIterator</a></b>[E: <a href="kernel.html#CLASS_Object">Object</a>]<br/> Iterators on sets implemented with arrays.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Collection">Collection</a></b>[E: nullable Object]<br/> The root of the collection hierarchy.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ComparableSorter">ComparableSorter</a></b>[E: <a href="kernel.html#CLASS_Comparable">Comparable</a>]<br/> This class uses the operator <=> to sort arrays.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Container">Container</a></b>[E: nullable Object]<br/> A collection that contains only one item.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ContainerIterator">ContainerIterator</a></b>[E: nullable Object]<br/> This iterator is quite stupid since it is used for only one item.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Couple">Couple</a></b>[F: nullable ObjectS: nullable Object]<br/> Two objects in a simple structure.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_CoupleMap">CoupleMap</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]<br/> Associatives arrays that internally uses couples to represent each (key, value) pairs.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_CoupleMapIterator">CoupleMapIterator</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]<br/> Iterator on CoupleMap
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_HashMap">HashMap</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>V: nullable Object]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_HashMapIterator">HashMapIterator</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>V: nullable Object]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_HashMapNode">HashMapNode</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>V: nullable Object]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_HashSet">HashSet</a></b>[E: <a href="kernel.html#CLASS_Object">Object</a>]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_HashSetIterator">HashSetIterator</a></b>[E: <a href="kernel.html#CLASS_Object">Object</a>]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_HashSetNode">HashSetNode</a></b>[E: <a href="kernel.html#CLASS_Object">Object</a>]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_IndexedIterator">IndexedIterator</a></b>[E: nullable Object]<br/> Iterators on indexed collections.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Iterator">Iterator</a></b>[E: nullable Object]<br/> Instances of the Iterator class generates a series of elements, one at a time.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_IteratorRange">IteratorRange</a></b>[E: <a href="kernel.html#CLASS_Discrete">Discrete</a>]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_List">List</a></b>[E: nullable Object]<br/> Double linked lists.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_ListIterator">ListIterator</a></b>[E: nullable Object]<br/> This is the iterator class of List
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Map">Map</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]<br/> Maps are associative collections: `key' -> `item'.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_MapIterator">MapIterator</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]<br/> Iterators for Map.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_MapRead">MapRead</a></b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]<br/>&nbsp;</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_NaiveCollection">NaiveCollection</a></b>[E: nullable Object]<br/> Naive implementation of collections method
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_NativeArray">NativeArray</a></b>[E: nullable Object]<br/> Native C array (void ...).
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Range">Range</a></b>[E: <a href="kernel.html#CLASS_Discrete">Discrete</a>]<br/> Range of discrete objects. 
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_RemovableCollection">RemovableCollection</a></b>[E: nullable Object]<br/> Items can be removed from this collection
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Sequence">Sequence</a></b>[E: nullable Object]<br/> Indexed collection are ordoned collections.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_SequenceRead">SequenceRead</a></b>[E: nullable Object]<br/> Indexed collection are ordoned collections.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_Set">Set</a></b>[E: <a href="kernel.html#CLASS_Object">Object</a>]<br/> Abstract sets.
</td><tr>
<tr><td width="20%" align="right">class </td><td><b><a href="#CLASS_SimpleCollection">SimpleCollection</a></b>[E: nullable Object]<br/> Items can be added to these collections.
</td><tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th><big>Class Detail of collection</big></th><tr>
</table>
<a name="CLASS_AbstractArray"></a><h2>AbstractArray</h2><small>collection::</small><br/>class <b>AbstractArray</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>, <a href="#CLASS_Sequence">Sequence</a>
<dt>All superclasses: <dd><a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>, <a href="#CLASS_Sequence">Sequence</a>, <a href="#CLASS_SequenceRead">SequenceRead</a>, <a href="#CLASS_Map">Map</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_Array">Array</a>
</dl>
<pre> Resizeable one dimention array of objects.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of AbstractArray</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_AbstractArray_enlarge">enlarge</a></b>(<a href="kernel.html#CLASS_Int">Int</a>) is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_AbstractArray_insert">insert</a></b>(E, <a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a></small></td><td><small><a href="#PROP_AbstractArrayRead___eqeq">==</a>, <a href="#PROP_AbstractArrayRead_copy_to">copy_to</a>, <a href="#PROP_AbstractArrayRead_index_of_from">index_of_from</a>, <a href="#PROP_AbstractArrayRead_last_index_of">last_index_of</a>, <a href="#PROP_AbstractArrayRead_last_index_of_from">last_index_of_from</a>, <a href="#PROP_AbstractArrayRead_length">length</a>, <a href="#PROP_AbstractArrayRead_reversed">reversed</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Sequence">Sequence</a></small></td><td><small><a href="#PROP_Sequence_add">add</a>, <a href="#PROP_Sequence_append">append</a>, <a href="#PROP_Sequence_first__eq">first=</a>, <a href="#PROP_Sequence_last__eq">last=</a>, <a href="#PROP_Sequence_pop">pop</a>, <a href="#PROP_Sequence_push">push</a>, <a href="#PROP_Sequence_shift">shift</a>, <a href="#PROP_Sequence_unshift">unshift</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SequenceRead">SequenceRead</a></small></td><td><small><a href="#PROP_SequenceRead_first">first</a>, <a href="#PROP_SequenceRead_index_of">index_of</a>, <a href="#PROP_SequenceRead_last">last</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Map">Map</a></small></td><td><small><a href="#PROP_Map___braeq">[]=</a>, <a href="#PROP_Map_recover_with">recover_with</a>, <a href="#PROP_Map_remove_at">remove_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SimpleCollection">SimpleCollection</a></small></td><td><small><a href="#PROP_SimpleCollection_add">add</a>, <a href="#PROP_SimpleCollection_add_all">add_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of AbstractArray</th><tr>
</table>
<a name="PROP_AbstractArray_enlarge"></a><h3>enlarge</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArray">AbstractArray</a>::</small><br/>redef fun collection:: <b>enlarge</b>(<a href="kernel.html#CLASS_Int">Int</a>) is abstract</p>
<blockquote></blockquote>
<hr/>
<a name="PROP_AbstractArray_insert"></a><h3>insert</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArray">AbstractArray</a>::</small><br/>redef fun collection:: <b>insert</b>(E, <a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_AbstractArrayRead"></a><h2>AbstractArrayRead</h2><small>collection::</small><br/>class <b>AbstractArrayRead</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_SequenceRead">SequenceRead</a>
<dt>All superclasses: <dd><a href="#CLASS_SequenceRead">SequenceRead</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_AbstractArray">AbstractArray</a>
</dl>
<pre> One dimention array of objects.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of AbstractArrayRead</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_AbstractArrayRead_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of AbstractArrayRead</th></tr>
<tr><td width="20%" align="right">redef fun <a href="kernel.html#CLASS_Object">Object</a>::</td><td><b><a href="#PROP_AbstractArrayRead___eqeq">==</a></b>(nullable Object): <a href="kernel.html#CLASS_Bool">Bool</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; Two arrays are equals if they have the same items in the same order.
</td></tr>
<tr><td width="20%" align="right">redef protected fun collection::</td><td><b><a href="#PROP_AbstractArrayRead_copy_to">copy_to</a></b>(<a href="kernel.html#CLASS_Int">Int</a>, <a href="kernel.html#CLASS_Int">Int</a>, <a href="#CLASS_AbstractArray">AbstractArray</a>[E], <a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_AbstractArrayRead_index_of_from">index_of_from</a></b>(E, <a href="kernel.html#CLASS_Int">Int</a>): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_AbstractArrayRead_last_index_of">last_index_of</a></b>(E): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_AbstractArrayRead_last_index_of_from">last_index_of_from</a></b>(E, <a href="kernel.html#CLASS_Int">Int</a>): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_AbstractArrayRead_length">length</a></b>: <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; The current length
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_AbstractArrayRead_reversed">reversed</a></b>: <a href="#CLASS_Array">Array</a>[E]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SequenceRead">SequenceRead</a></small></td><td><small><a href="#PROP_SequenceRead_first">first</a>, <a href="#PROP_SequenceRead_index_of">index_of</a>, <a href="#PROP_SequenceRead_last">last</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of AbstractArrayRead</th><tr>
</table>
<a name="PROP_AbstractArrayRead_init"></a><h3>init</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote></blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of AbstractArrayRead</th><tr>
</table>
<a name="PROP_AbstractArrayRead___eqeq"></a><h3>==</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef fun <a href="kernel.html#CLASS_Object">Object</a>:: <b>==</b>(nullable Object): <a href="kernel.html#CLASS_Bool">Bool</a></p>
<blockquote><pre> Two arrays are equals if they have the same items in the same order.
</pre>
</blockquote>
<hr/>
<a name="PROP_AbstractArrayRead_copy_to"></a><h3>copy_to</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef protected fun collection:: <b>copy_to</b>(<a href="kernel.html#CLASS_Int">Int</a>, <a href="kernel.html#CLASS_Int">Int</a>, <a href="#CLASS_AbstractArray">AbstractArray</a>[E], <a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote></blockquote>
<hr/>
<a name="PROP_AbstractArrayRead_index_of_from"></a><h3>index_of_from</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef fun collection:: <b>index_of_from</b>(E, <a href="kernel.html#CLASS_Int">Int</a>): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote></blockquote>
<hr/>
<a name="PROP_AbstractArrayRead_last_index_of"></a><h3>last_index_of</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef fun collection:: <b>last_index_of</b>(E): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote></blockquote>
<hr/>
<a name="PROP_AbstractArrayRead_last_index_of_from"></a><h3>last_index_of_from</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef fun collection:: <b>last_index_of_from</b>(E, <a href="kernel.html#CLASS_Int">Int</a>): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote></blockquote>
<hr/>
<a name="PROP_AbstractArrayRead_length"></a><h3>length</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>length</b>: <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> The current length
</pre>
</blockquote>
<hr/>
<a name="PROP_AbstractArrayRead_reversed"></a><h3>reversed</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>::</small><br/>redef fun collection:: <b>reversed</b>: <a href="#CLASS_Array">Array</a>[E]</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_AbstractSorter"></a><h2>AbstractSorter</h2><small>collection::</small><br/>class <b>AbstractSorter</b>[E: <a href="kernel.html#CLASS_Object">Object</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>All superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_ComparableSorter">ComparableSorter</a>
</dl>
<pre> This abstract class generalizes ways to sort an array
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of AbstractSorter</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_AbstractSorter_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of AbstractSorter</th></tr>
<tr><td width="20%" align="right">redef protected fun collection::</td><td><b><a href="#PROP_AbstractSorter_compare">compare</a></b>(E, E): <a href="kernel.html#CLASS_Int">Int</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Compare `a' and `b'.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_AbstractSorter_sort">sort</a></b>(<a href="#CLASS_Array">Array</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp; Sort `array' using the `compare' function.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of AbstractSorter</th><tr>
</table>
<a name="PROP_AbstractSorter_init"></a><h3>init</h3><p><small><a href="sorter.html">sorter</a>::<a href="#CLASS_AbstractSorter">AbstractSorter</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote></blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of AbstractSorter</th><tr>
</table>
<a name="PROP_AbstractSorter_compare"></a><h3>compare</h3><p><small><a href="sorter.html">sorter</a>::<a href="#CLASS_AbstractSorter">AbstractSorter</a>::</small><br/>redef protected fun collection:: <b>compare</b>(E, E): <a href="kernel.html#CLASS_Int">Int</a> is abstract</p>
<blockquote><pre> Compare `a' and `b'.
 Returns:
 	-1 if a < b
	0  if a = b
	1  if a > b
</pre>
</blockquote>
<hr/>
<a name="PROP_AbstractSorter_sort"></a><h3>sort</h3><p><small><a href="sorter.html">sorter</a>::<a href="#CLASS_AbstractSorter">AbstractSorter</a>::</small><br/>redef fun collection:: <b>sort</b>(<a href="#CLASS_Array">Array</a>[E])</p>
<blockquote><pre> Sort `array' using the `compare' function.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_Array"></a><h2>Array</h2><small>collection::</small><br/>class <b>Array</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_AbstractArray">AbstractArray</a>, <a href="#CLASS_ArrayCapable">ArrayCapable</a>
<dt>All superclasses: <dd><a href="#CLASS_AbstractArray">AbstractArray</a>, <a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>, <a href="#CLASS_Sequence">Sequence</a>, <a href="#CLASS_SequenceRead">SequenceRead</a>, <a href="#CLASS_Map">Map</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="#CLASS_ArrayCapable">ArrayCapable</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Refinements in known modules: <dd><a href="string.html">string</a>
</dl>
<pre> Resizeable one dimention array of objects.

 Arrays have a literal representation.
     a = [12, 32, 8]
 is equivalent with:
     a = new Array[Int]
     a.push(12)
     a.push(32)
     a.push(8)
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of Array</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Array_filled_with">filled_with</a></b>(E, <a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create an array of `count' elements
</td></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Array_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp; Create an empty array.
</td></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Array_with_capacity">with_capacity</a></b>(<a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create an empty array with a given capacity.
</td></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Array_with_items">with_items</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create an array with some `items'.
</td></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Array_with_native">with_native</a></b>(<a href="#CLASS_NativeArray">NativeArray</a>[E], <a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create a array filled with a given native array.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Array</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Array_intern_items">intern_items</a></b>: <a href="#CLASS_NativeArray">NativeArray</a>[E]<br/>&nbsp;&nbsp;&nbsp;&nbsp; Do not use this method
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Array_sort">sort</a></b> !cmp(E, E): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; Sort the array using the !cmp function.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_AbstractArray">AbstractArray</a></small></td><td><small><a href="#PROP_AbstractArray_enlarge">enlarge</a>, <a href="#PROP_AbstractArray_insert">insert</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a></small></td><td><small><a href="#PROP_AbstractArrayRead___eqeq">==</a>, <a href="#PROP_AbstractArrayRead_copy_to">copy_to</a>, <a href="#PROP_AbstractArrayRead_index_of_from">index_of_from</a>, <a href="#PROP_AbstractArrayRead_last_index_of">last_index_of</a>, <a href="#PROP_AbstractArrayRead_last_index_of_from">last_index_of_from</a>, <a href="#PROP_AbstractArrayRead_length">length</a>, <a href="#PROP_AbstractArrayRead_reversed">reversed</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Sequence">Sequence</a></small></td><td><small><a href="#PROP_Sequence_add">add</a>, <a href="#PROP_Sequence_append">append</a>, <a href="#PROP_Sequence_first__eq">first=</a>, <a href="#PROP_Sequence_last__eq">last=</a>, <a href="#PROP_Sequence_pop">pop</a>, <a href="#PROP_Sequence_push">push</a>, <a href="#PROP_Sequence_shift">shift</a>, <a href="#PROP_Sequence_unshift">unshift</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SequenceRead">SequenceRead</a></small></td><td><small><a href="#PROP_SequenceRead_first">first</a>, <a href="#PROP_SequenceRead_index_of">index_of</a>, <a href="#PROP_SequenceRead_last">last</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Map">Map</a></small></td><td><small><a href="#PROP_Map___braeq">[]=</a>, <a href="#PROP_Map_recover_with">recover_with</a>, <a href="#PROP_Map_remove_at">remove_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SimpleCollection">SimpleCollection</a></small></td><td><small><a href="#PROP_SimpleCollection_add">add</a>, <a href="#PROP_SimpleCollection_add_all">add_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_ArrayCapable">ArrayCapable</a></small></td><td><small><a href="#PROP_ArrayCapable_calloc_array">calloc_array</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Added Methods in known modules</small></th><tr>
<tr><td width="20%"><small>in <a href="standard.html">standard</a></small></td><td><small><a href="standard.html#PROP_Array_to_s">to_s</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of Array</th><tr>
</table>
<a name="PROP_Array_filled_with"></a><h3>filled_with</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Array">Array</a>::</small><br/>redef init collection:: <b>filled_with</b>(E, <a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote><pre> Create an array of `count' elements
</pre>
</blockquote>
<hr/>
<a name="PROP_Array_init"></a><h3>init</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Array">Array</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote><pre> Create an empty array.
</pre>
</blockquote>
<hr/>
<a name="PROP_Array_with_capacity"></a><h3>with_capacity</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Array">Array</a>::</small><br/>redef init collection:: <b>with_capacity</b>(<a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote><pre> Create an empty array with a given capacity.
</pre>
</blockquote>
<hr/>
<a name="PROP_Array_with_items"></a><h3>with_items</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Array">Array</a>::</small><br/>redef init collection:: <b>with_items</b>(E)</p>
<blockquote><pre> Create an array with some `items'.
</pre>
</blockquote>
<hr/>
<a name="PROP_Array_with_native"></a><h3>with_native</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Array">Array</a>::</small><br/>redef init collection:: <b>with_native</b>(<a href="#CLASS_NativeArray">NativeArray</a>[E], <a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote><pre> Create a array filled with a given native array.
</pre>
</blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Array</th><tr>
</table>
<a name="PROP_Array_intern_items"></a><h3>intern_items</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Array">Array</a>::</small><br/>redef fun collection:: <b>intern_items</b>: <a href="#CLASS_NativeArray">NativeArray</a>[E]</p>
<blockquote><pre> Do not use this method
 FIXME: Remove it once modules can intrude non local modules
</pre>
</blockquote>
<hr/>
<a name="PROP_Array_sort"></a><h3>sort</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Array">Array</a>::</small><br/>redef fun collection:: <b>sort</b> !cmp(E, E): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> Sort the array using the !cmp function.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_ArrayCapable"></a><h2>ArrayCapable</h2><small>collection::</small><br/>class <b>ArrayCapable</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>All superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_Array">Array</a>, <a href="#CLASS_HashCollection">HashCollection</a>
</dl>
<pre> Subclasses of this class can create native arrays
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ArrayCapable</th></tr>
<tr><td width="20%" align="right">redef protected fun collection::</td><td><b><a href="#PROP_ArrayCapable_calloc_array">calloc_array</a></b>(<a href="kernel.html#CLASS_Int">Int</a>): <a href="#CLASS_NativeArray">NativeArray</a>[E] is intern<br/>&nbsp;&nbsp;&nbsp;&nbsp; Get a new array of `size' elements.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of ArrayCapable</th><tr>
</table>
<a name="PROP_ArrayCapable_calloc_array"></a><h3>calloc_array</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayCapable">ArrayCapable</a>::</small><br/>redef protected fun collection:: <b>calloc_array</b>(<a href="kernel.html#CLASS_Int">Int</a>): <a href="#CLASS_NativeArray">NativeArray</a>[E] is intern</p>
<blockquote><pre> Get a new array of `size' elements.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_ArrayIterator"></a><h2>ArrayIterator</h2><small>collection::</small><br/>class <b>ArrayIterator</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_IndexedIterator">IndexedIterator</a>
<dt>All superclasses: <dd><a href="#CLASS_IndexedIterator">IndexedIterator</a>, <a href="#CLASS_MapIterator">MapIterator</a>, <a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> An `Iterator' on `AbstractArray'
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of ArrayIterator</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_ArrayIterator_init">init</a></b>(<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ArrayIterator</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_IndexedIterator">IndexedIterator</a></small></td><td><small><a href="#PROP_IndexedIterator_index">index</a>, <a href="#PROP_IndexedIterator_key">key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapIterator">MapIterator</a></small></td><td><small><a href="#PROP_MapIterator_key">key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of ArrayIterator</th><tr>
</table>
<a name="PROP_ArrayIterator_init"></a><h3>init</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayIterator">ArrayIterator</a>::</small><br/>redef init collection:: <b>init</b>(<a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>[E])</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_ArrayMap"></a><h2>ArrayMap</h2><small>collection::</small><br/>class <b>ArrayMap</b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_CoupleMap">CoupleMap</a>
<dt>All superclasses: <dd><a href="#CLASS_CoupleMap">CoupleMap</a>, <a href="#CLASS_Map">Map</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Associative arrays implemented with an array of (key, value) pairs.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of ArrayMap</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_ArrayMap_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp; A new empty map.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ArrayMap</th></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_MapRead">MapRead</a>::</td><td><b><a href="#PROP_ArrayMap___bra">[]</a></b>(K): E<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Map">Map</a>::</td><td><b><a href="#PROP_ArrayMap___braeq">[]=</a></b>(K, E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_ArrayMap_count">count</a></b>(E): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_ArrayMap_enlarge">enlarge</a></b>(<a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Assume the capacity to be at least `cap'.
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_ArrayMap_has">has</a></b>(E): <a href="kernel.html#CLASS_Bool">Bool</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_MapRead">MapRead</a>::</td><td><b><a href="#PROP_ArrayMap_has_key">has_key</a></b>(K): <a href="kernel.html#CLASS_Bool">Bool</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_ArrayMap_has_only">has_only</a></b>(E): <a href="kernel.html#CLASS_Bool">Bool</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_ArrayMap_length">length</a></b>: <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_CoupleMap">CoupleMap</a></small></td><td><small><a href="#PROP_CoupleMap_couple_at">couple_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Map">Map</a></small></td><td><small><a href="#PROP_Map___braeq">[]=</a>, <a href="#PROP_Map_recover_with">recover_with</a>, <a href="#PROP_Map_remove_at">remove_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of ArrayMap</th><tr>
</table>
<a name="PROP_ArrayMap_init"></a><h3>init</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote><pre> A new empty map.
</pre>
</blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of ArrayMap</th><tr>
</table>
<a name="PROP_ArrayMap___bra"></a><h3>[]</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun <a href="#CLASS_MapRead">MapRead</a>:: <b>[]</b>(K): E</p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_ArrayMap___braeq"></a><h3>[]=</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun <a href="#CLASS_Map">Map</a>:: <b>[]=</b>(K, E)</p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_ArrayMap_count"></a><h3>count</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>count</b>(E): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_ArrayMap_enlarge"></a><h3>enlarge</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun collection:: <b>enlarge</b>(<a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote><pre> Assume the capacity to be at least `cap'.
</pre>
</blockquote>
<hr/>
<a name="PROP_ArrayMap_has"></a><h3>has</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>has</b>(E): <a href="kernel.html#CLASS_Bool">Bool</a></p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_ArrayMap_has_key"></a><h3>has_key</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun <a href="#CLASS_MapRead">MapRead</a>:: <b>has_key</b>(K): <a href="kernel.html#CLASS_Bool">Bool</a></p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_ArrayMap_has_only"></a><h3>has_only</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>has_only</b>(E): <a href="kernel.html#CLASS_Bool">Bool</a></p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_ArrayMap_length"></a><h3>length</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArrayMap">ArrayMap</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>length</b>: <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> O(1)
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_ArraySet"></a><h2>ArraySet</h2><small>collection::</small><br/>class <b>ArraySet</b>[E: <a href="kernel.html#CLASS_Object">Object</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Set">Set</a>
<dt>All superclasses: <dd><a href="#CLASS_Set">Set</a>, <a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> A set implemented with an Array.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of ArraySet</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_ArraySet_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp; Create an empty set
</td></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_ArraySet_with_capacity">with_capacity</a></b>(<a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create an empty set with a given capacity.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ArraySet</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_ArraySet_enlarge">enlarge</a></b>(<a href="kernel.html#CLASS_Int">Int</a>)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Assume the capacitydd is at least `cap'.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Set">Set</a></small></td><td><small><a href="#PROP_Set_count">count</a>, <a href="#PROP_Set_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SimpleCollection">SimpleCollection</a></small></td><td><small><a href="#PROP_SimpleCollection_add">add</a>, <a href="#PROP_SimpleCollection_add_all">add_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of ArraySet</th><tr>
</table>
<a name="PROP_ArraySet_init"></a><h3>init</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArraySet">ArraySet</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote><pre> Create an empty set
</pre>
</blockquote>
<hr/>
<a name="PROP_ArraySet_with_capacity"></a><h3>with_capacity</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArraySet">ArraySet</a>::</small><br/>redef init collection:: <b>with_capacity</b>(<a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote><pre> Create an empty set with a given capacity.
</pre>
</blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of ArraySet</th><tr>
</table>
<a name="PROP_ArraySet_enlarge"></a><h3>enlarge</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArraySet">ArraySet</a>::</small><br/>redef fun collection:: <b>enlarge</b>(<a href="kernel.html#CLASS_Int">Int</a>)</p>
<blockquote><pre> Assume the capacitydd is at least `cap'.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_ArraySetIterator"></a><h2>ArraySetIterator</h2><small>collection::</small><br/>class <b>ArraySetIterator</b>[E: <a href="kernel.html#CLASS_Object">Object</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>
<dt>All superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Iterators on sets implemented with arrays.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of ArraySetIterator</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_ArraySetIterator_init">init</a></b>(<a href="#CLASS_ArrayIterator">ArrayIterator</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ArraySetIterator</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of ArraySetIterator</th><tr>
</table>
<a name="PROP_ArraySetIterator_init"></a><h3>init</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_ArraySetIterator">ArraySetIterator</a>::</small><br/>redef init collection:: <b>init</b>(<a href="#CLASS_ArrayIterator">ArrayIterator</a>[E])</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_Collection"></a><h2>Collection</h2><small>collection::</small><br/>class <b>Collection</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>All superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_NaiveCollection">NaiveCollection</a>, <a href="#CLASS_Container">Container</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_Range">Range</a>, <a href="#CLASS_HashCollection">HashCollection</a>
<dt>Refinements in known modules: <dd><a href="string.html">string</a>
</dl>
<pre> The root of the collection hierarchy.

 Instances of this class offers an iterator method.

 Colections instances can use the "for" structure:
	  var x: Collection[U]
         ...
         for u in x do
             # u is a U
             ...
         end
 that is equivalent with
         var x: Collection[U]
         ...
         var i = x.iterator
         while i.is_ok do
             var u = i.item # u is a U
             ...
             i.next
         end

 This abstract class implements its others methods with an iterator.
 Subclasses may redefine them with an efficient implementation.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Collection</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_count">count</a></b>(E): <a href="kernel.html#CLASS_Int">Int</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; How many occurences of `item' are in the collection ?
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_first">first</a></b>: E is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Return one the item of the collection
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_has">has</a></b>(E): <a href="kernel.html#CLASS_Bool">Bool</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Is `item' in the collection ?
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_has_only">has_only</a></b>(E): <a href="kernel.html#CLASS_Bool">Bool</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Is the collection contain only `item' ?
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_is_empty">is_empty</a></b>: <a href="kernel.html#CLASS_Bool">Bool</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Is there no item in the collection ?
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_iterate">iterate</a></b> !each(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Iterate over each element of the collection
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_iterator">iterator</a></b>: <a href="#CLASS_Iterator">Iterator</a>[E] is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Get a new iterator on the collection.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_length">length</a></b>: <a href="kernel.html#CLASS_Int">Int</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Number of items in the collection.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Collection_to_a">to_a</a></b>: <a href="#CLASS_Array">Array</a>[E]<br/>&nbsp;&nbsp;&nbsp;&nbsp; Build a new array from a collection
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Added Methods in known modules</small></th><tr>
<tr><td width="20%"><small>in <a href="standard.html">standard</a></small></td><td><small><a href="standard.html#PROP_Collection_join">join</a>, <a href="standard.html#PROP_Collection_to_s">to_s</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Collection</th><tr>
</table>
<a name="PROP_Collection_count"></a><h3>count</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>count</b>(E): <a href="kernel.html#CLASS_Int">Int</a> is abstract</p>
<blockquote><pre> How many occurences of `item' are in the collection ?
 Comparaisons are done with ==
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_first"></a><h3>first</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>first</b>: E is abstract</p>
<blockquote><pre> Return one the item of the collection
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_has"></a><h3>has</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>has</b>(E): <a href="kernel.html#CLASS_Bool">Bool</a> is abstract</p>
<blockquote><pre> Is `item' in the collection ?
 Comparaisons are done with ==
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_has_only"></a><h3>has_only</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>has_only</b>(E): <a href="kernel.html#CLASS_Bool">Bool</a> is abstract</p>
<blockquote><pre> Is the collection contain only `item' ?
 Comparaisons are done with ==
 Return true if the collection is empty.
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_is_empty"></a><h3>is_empty</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>is_empty</b>: <a href="kernel.html#CLASS_Bool">Bool</a> is abstract</p>
<blockquote><pre> Is there no item in the collection ?
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_iterate"></a><h3>iterate</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>iterate</b> !each(E)</p>
<blockquote><pre> Iterate over each element of the collection
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_iterator"></a><h3>iterator</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>iterator</b>: <a href="#CLASS_Iterator">Iterator</a>[E] is abstract</p>
<blockquote><pre> Get a new iterator on the collection.
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_length"></a><h3>length</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>length</b>: <a href="kernel.html#CLASS_Int">Int</a> is abstract</p>
<blockquote><pre> Number of items in the collection.
</pre>
</blockquote>
<hr/>
<a name="PROP_Collection_to_a"></a><h3>to_a</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Collection">Collection</a>::</small><br/>redef fun collection:: <b>to_a</b>: <a href="#CLASS_Array">Array</a>[E]</p>
<blockquote><pre> Build a new array from a collection
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_ComparableSorter"></a><h2>ComparableSorter</h2><small>collection::</small><br/>class <b>ComparableSorter</b>[E: <a href="kernel.html#CLASS_Comparable">Comparable</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_AbstractSorter">AbstractSorter</a>
<dt>All superclasses: <dd><a href="#CLASS_AbstractSorter">AbstractSorter</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> This class uses the operator <=> to sort arrays.
 You can also use the `sort' method of the `Array' class.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of ComparableSorter</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_ComparableSorter_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ComparableSorter</th></tr>
<tr><td width="20%" align="right">redef protected fun <a href="#CLASS_AbstractSorter">AbstractSorter</a>::</td><td><b><a href="#PROP_ComparableSorter_compare">compare</a></b>(E, E): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; Return a <=> b
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_AbstractSorter">AbstractSorter</a></small></td><td><small><a href="#PROP_AbstractSorter_compare">compare</a>, <a href="#PROP_AbstractSorter_sort">sort</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of ComparableSorter</th><tr>
</table>
<a name="PROP_ComparableSorter_init"></a><h3>init</h3><p><small><a href="sorter.html">sorter</a>::<a href="#CLASS_ComparableSorter">ComparableSorter</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote></blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of ComparableSorter</th><tr>
</table>
<a name="PROP_ComparableSorter_compare"></a><h3>compare</h3><p><small><a href="sorter.html">sorter</a>::<a href="#CLASS_ComparableSorter">ComparableSorter</a>::</small><br/>redef protected fun <a href="#CLASS_AbstractSorter">AbstractSorter</a>:: <b>compare</b>(E, E): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> Return a <=> b
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_Container"></a><h2>Container</h2><small>collection::</small><br/>class <b>Container</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Collection">Collection</a>
<dt>All superclasses: <dd><a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_ListNode">ListNode</a>
</dl>
<pre> A collection that contains only one item.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of Container</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Container_init">init</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create a new instance with a given initial value.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Container</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Container_item">item</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; The stored item
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Container_item__eq">item=</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; The stored item
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of Container</th><tr>
</table>
<a name="PROP_Container_init"></a><h3>init</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Container">Container</a>::</small><br/>redef init collection:: <b>init</b>(E)</p>
<blockquote><pre> Create a new instance with a given initial value.
</pre>
</blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Container</th><tr>
</table>
<a name="PROP_Container_item"></a><h3>item</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Container">Container</a>::</small><br/>redef fun collection:: <b>item</b>: E</p>
<blockquote><pre> The stored item
</pre>
</blockquote>
<hr/>
<a name="PROP_Container_item__eq"></a><h3>item=</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Container">Container</a>::</small><br/>redef fun collection:: <b>item=</b>(E)</p>
<blockquote><pre> The stored item
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_ContainerIterator"></a><h2>ContainerIterator</h2><small>collection::</small><br/>class <b>ContainerIterator</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>
<dt>All superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> This iterator is quite stupid since it is used for only one item.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of ContainerIterator</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_ContainerIterator_init">init</a></b>(<a href="#CLASS_Container">Container</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ContainerIterator</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of ContainerIterator</th><tr>
</table>
<a name="PROP_ContainerIterator_init"></a><h3>init</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_ContainerIterator">ContainerIterator</a>::</small><br/>redef init collection:: <b>init</b>(<a href="#CLASS_Container">Container</a>[E])</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_Couple"></a><h2>Couple</h2><small>collection::</small><br/>class <b>Couple</b>[F: nullable ObjectS: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>All superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Two objects in a simple structure.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of Couple</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Couple_init">init</a></b>(F, S)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create a new instance with a first and a second object.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Couple</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Couple_first">first</a></b>: F<br/>&nbsp;&nbsp;&nbsp;&nbsp; The first element of the couple.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Couple_first__eq">first=</a></b>(F)<br/>&nbsp;&nbsp;&nbsp;&nbsp; The first element of the couple.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Couple_second">second</a></b>: S<br/>&nbsp;&nbsp;&nbsp;&nbsp; The second element of the couple.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Couple_second__eq">second=</a></b>(S)<br/>&nbsp;&nbsp;&nbsp;&nbsp; The second element of the couple.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of Couple</th><tr>
</table>
<a name="PROP_Couple_init"></a><h3>init</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Couple">Couple</a>::</small><br/>redef init collection:: <b>init</b>(F, S)</p>
<blockquote><pre> Create a new instance with a first and a second object.
</pre>
</blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Couple</th><tr>
</table>
<a name="PROP_Couple_first"></a><h3>first</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Couple">Couple</a>::</small><br/>redef fun collection:: <b>first</b>: F</p>
<blockquote><pre> The first element of the couple.
</pre>
</blockquote>
<hr/>
<a name="PROP_Couple_first__eq"></a><h3>first=</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Couple">Couple</a>::</small><br/>redef fun collection:: <b>first=</b>(F)</p>
<blockquote><pre> The first element of the couple.
</pre>
</blockquote>
<hr/>
<a name="PROP_Couple_second"></a><h3>second</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Couple">Couple</a>::</small><br/>redef fun collection:: <b>second</b>: S</p>
<blockquote><pre> The second element of the couple.
</pre>
</blockquote>
<hr/>
<a name="PROP_Couple_second__eq"></a><h3>second=</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Couple">Couple</a>::</small><br/>redef fun collection:: <b>second=</b>(S)</p>
<blockquote><pre> The second element of the couple.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_CoupleMap"></a><h2>CoupleMap</h2><small>collection::</small><br/>class <b>CoupleMap</b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Map">Map</a>
<dt>All superclasses: <dd><a href="#CLASS_Map">Map</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_ArrayMap">ArrayMap</a>
</dl>
<pre> Associatives arrays that internally uses couples to represent each (key, value) pairs.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of CoupleMap</th></tr>
<tr><td width="20%" align="right">redef protected fun collection::</td><td><b><a href="#PROP_CoupleMap_couple_at">couple_at</a></b>(K): nullable Couple[K, E] is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Return the couple of the corresponding key
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Map">Map</a></small></td><td><small><a href="#PROP_Map___braeq">[]=</a>, <a href="#PROP_Map_recover_with">recover_with</a>, <a href="#PROP_Map_remove_at">remove_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of CoupleMap</th><tr>
</table>
<a name="PROP_CoupleMap_couple_at"></a><h3>couple_at</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_CoupleMap">CoupleMap</a>::</small><br/>redef protected fun collection:: <b>couple_at</b>(K): nullable Couple[K, E] is abstract</p>
<blockquote><pre> Return the couple of the corresponding key
 Return null if the key is no associated element
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_CoupleMapIterator"></a><h2>CoupleMapIterator</h2><small>collection::</small><br/>class <b>CoupleMapIterator</b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_MapIterator">MapIterator</a>
<dt>All superclasses: <dd><a href="#CLASS_MapIterator">MapIterator</a>, <a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Iterator on CoupleMap

 Actually is is a wrapper around an iterator of the internal array of the map.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of CoupleMapIterator</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_CoupleMapIterator_init">init</a></b>(<a href="#CLASS_Iterator">Iterator</a>[<a href="#CLASS_Couple">Couple</a>[K, E]])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of CoupleMapIterator</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapIterator">MapIterator</a></small></td><td><small><a href="#PROP_MapIterator_key">key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of CoupleMapIterator</th><tr>
</table>
<a name="PROP_CoupleMapIterator_init"></a><h3>init</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_CoupleMapIterator">CoupleMapIterator</a>::</small><br/>redef init collection:: <b>init</b>(<a href="#CLASS_Iterator">Iterator</a>[<a href="#CLASS_Couple">Couple</a>[K, E]])</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_HashMap"></a><h2>HashMap</h2><small>collection::</small><br/>class <b>HashMap</b>[K: <a href="kernel.html#CLASS_Object">Object</a>V: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Map">Map</a>, <a href="#CLASS_HashCollection">HashCollection</a>
<dt>All superclasses: <dd><a href="#CLASS_Map">Map</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_HashCollection">HashCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="#CLASS_ArrayCapable">ArrayCapable</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of HashMap</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_HashMap_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of HashMap</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Map">Map</a></small></td><td><small><a href="#PROP_Map___braeq">[]=</a>, <a href="#PROP_Map_recover_with">recover_with</a>, <a href="#PROP_Map_remove_at">remove_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_ArrayCapable">ArrayCapable</a></small></td><td><small><a href="#PROP_ArrayCapable_calloc_array">calloc_array</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of HashMap</th><tr>
</table>
<a name="PROP_HashMap_init"></a><h3>init</h3><p><small><a href="hash_collection.html">hash_collection</a>::<a href="#CLASS_HashMap">HashMap</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_HashMapIterator"></a><h2>HashMapIterator</h2><small>collection::</small><br/>class <b>HashMapIterator</b>[K: <a href="kernel.html#CLASS_Object">Object</a>V: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_MapIterator">MapIterator</a>
<dt>All superclasses: <dd><a href="#CLASS_MapIterator">MapIterator</a>, <a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of HashMapIterator</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_HashMapIterator_init">init</a></b>(<a href="#CLASS_HashMap">HashMap</a>[K, V])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of HashMapIterator</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapIterator">MapIterator</a></small></td><td><small><a href="#PROP_MapIterator_key">key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of HashMapIterator</th><tr>
</table>
<a name="PROP_HashMapIterator_init"></a><h3>init</h3><p><small><a href="hash_collection.html">hash_collection</a>::<a href="#CLASS_HashMapIterator">HashMapIterator</a>::</small><br/>redef init collection:: <b>init</b>(<a href="#CLASS_HashMap">HashMap</a>[K, V])</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_HashMapNode"></a><h2>HashMapNode</h2><small>collection::</small><br/>class <b>HashMapNode</b>[K: <a href="kernel.html#CLASS_Object">Object</a>V: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_HashNode">HashNode</a>
<dt>All superclasses: <dd><a href="#CLASS_HashNode">HashNode</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of HashMapNode</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_HashMapNode_init">init</a></b>(K, V)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of HashMapNode</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of HashMapNode</th><tr>
</table>
<a name="PROP_HashMapNode_init"></a><h3>init</h3><p><small><a href="hash_collection.html">hash_collection</a>::<a href="#CLASS_HashMapNode">HashMapNode</a>::</small><br/>redef init collection:: <b>init</b>(K, V)</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_HashSet"></a><h2>HashSet</h2><small>collection::</small><br/>class <b>HashSet</b>[E: <a href="kernel.html#CLASS_Object">Object</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Set">Set</a>, <a href="#CLASS_HashCollection">HashCollection</a>
<dt>All superclasses: <dd><a href="#CLASS_Set">Set</a>, <a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_HashCollection">HashCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="#CLASS_ArrayCapable">ArrayCapable</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of HashSet</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_HashSet_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of HashSet</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Set">Set</a></small></td><td><small><a href="#PROP_Set_count">count</a>, <a href="#PROP_Set_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SimpleCollection">SimpleCollection</a></small></td><td><small><a href="#PROP_SimpleCollection_add">add</a>, <a href="#PROP_SimpleCollection_add_all">add_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_ArrayCapable">ArrayCapable</a></small></td><td><small><a href="#PROP_ArrayCapable_calloc_array">calloc_array</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of HashSet</th><tr>
</table>
<a name="PROP_HashSet_init"></a><h3>init</h3><p><small><a href="hash_collection.html">hash_collection</a>::<a href="#CLASS_HashSet">HashSet</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_HashSetIterator"></a><h2>HashSetIterator</h2><small>collection::</small><br/>class <b>HashSetIterator</b>[E: <a href="kernel.html#CLASS_Object">Object</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>
<dt>All superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of HashSetIterator</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_HashSetIterator_init">init</a></b>(<a href="#CLASS_HashSet">HashSet</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of HashSetIterator</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of HashSetIterator</th><tr>
</table>
<a name="PROP_HashSetIterator_init"></a><h3>init</h3><p><small><a href="hash_collection.html">hash_collection</a>::<a href="#CLASS_HashSetIterator">HashSetIterator</a>::</small><br/>redef init collection:: <b>init</b>(<a href="#CLASS_HashSet">HashSet</a>[E])</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_HashSetNode"></a><h2>HashSetNode</h2><small>collection::</small><br/>class <b>HashSetNode</b>[E: <a href="kernel.html#CLASS_Object">Object</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_HashNode">HashNode</a>
<dt>All superclasses: <dd><a href="#CLASS_HashNode">HashNode</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of HashSetNode</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_HashSetNode_init">init</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of HashSetNode</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of HashSetNode</th><tr>
</table>
<a name="PROP_HashSetNode_init"></a><h3>init</h3><p><small><a href="hash_collection.html">hash_collection</a>::<a href="#CLASS_HashSetNode">HashSetNode</a>::</small><br/>redef init collection:: <b>init</b>(E)</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_IndexedIterator"></a><h2>IndexedIterator</h2><small>collection::</small><br/>class <b>IndexedIterator</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_MapIterator">MapIterator</a>
<dt>All superclasses: <dd><a href="#CLASS_MapIterator">MapIterator</a>, <a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_ListIterator">ListIterator</a>, <a href="#CLASS_ArrayIterator">ArrayIterator</a>
</dl>
<pre> Iterators on indexed collections.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of IndexedIterator</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_IndexedIterator_index">index</a></b>: <a href="kernel.html#CLASS_Int">Int</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; The index of the current item.
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_MapIterator">MapIterator</a>::</td><td><b><a href="#PROP_IndexedIterator_key">key</a></b>: <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; A synonym of index.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapIterator">MapIterator</a></small></td><td><small><a href="#PROP_MapIterator_key">key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of IndexedIterator</th><tr>
</table>
<a name="PROP_IndexedIterator_index"></a><h3>index</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_IndexedIterator">IndexedIterator</a>::</small><br/>redef fun collection:: <b>index</b>: <a href="kernel.html#CLASS_Int">Int</a> is abstract</p>
<blockquote><pre> The index of the current item.
</pre>
</blockquote>
<hr/>
<a name="PROP_IndexedIterator_key"></a><h3>key</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_IndexedIterator">IndexedIterator</a>::</small><br/>redef fun <a href="#CLASS_MapIterator">MapIterator</a>:: <b>key</b>: <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> A synonym of index.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_Iterator"></a><h2>Iterator</h2><small>collection::</small><br/>class <b>Iterator</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>All superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_ContainerIterator">ContainerIterator</a>, <a href="#CLASS_MapIterator">MapIterator</a>, <a href="#CLASS_IteratorRange">IteratorRange</a>, <a href="#CLASS_ArraySetIterator">ArraySetIterator</a>, <a href="#CLASS_HashSetIterator">HashSetIterator</a>
</dl>
<pre> Instances of the Iterator class generates a series of elements, one at a time.
 They are mainly used with collections.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Iterator</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Iterator_is_ok">is_ok</a></b>: <a href="kernel.html#CLASS_Bool">Bool</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Is there a current item ?
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Iterator_item">item</a></b>: E is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; The current item.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Iterator_next">next</a></b> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Jump to the next item.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Iterator_to_a">to_a</a></b>: <a href="#CLASS_Array">Array</a>[E]<br/>&nbsp;&nbsp;&nbsp;&nbsp; Interate on `self' and build an array
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Iterator</th><tr>
</table>
<a name="PROP_Iterator_is_ok"></a><h3>is_ok</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Iterator">Iterator</a>::</small><br/>redef fun collection:: <b>is_ok</b>: <a href="kernel.html#CLASS_Bool">Bool</a> is abstract</p>
<blockquote><pre> Is there a current item ?
</pre>
</blockquote>
<hr/>
<a name="PROP_Iterator_item"></a><h3>item</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Iterator">Iterator</a>::</small><br/>redef fun collection:: <b>item</b>: E is abstract</p>
<blockquote><pre> The current item.
 Require `is_ok'.
</pre>
</blockquote>
<hr/>
<a name="PROP_Iterator_next"></a><h3>next</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Iterator">Iterator</a>::</small><br/>redef fun collection:: <b>next</b> is abstract</p>
<blockquote><pre> Jump to the next item.
 Require `is_ok'.
</pre>
</blockquote>
<hr/>
<a name="PROP_Iterator_to_a"></a><h3>to_a</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_Iterator">Iterator</a>::</small><br/>redef fun collection:: <b>to_a</b>: <a href="#CLASS_Array">Array</a>[E]</p>
<blockquote><pre> Interate on `self' and build an array
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_IteratorRange"></a><h2>IteratorRange</h2><small>collection::</small><br/>class <b>IteratorRange</b>[E: <a href="kernel.html#CLASS_Discrete">Discrete</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>
<dt>All superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of IteratorRange</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_IteratorRange_init">init</a></b>(<a href="#CLASS_Range">Range</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of IteratorRange</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of IteratorRange</th><tr>
</table>
<a name="PROP_IteratorRange_init"></a><h3>init</h3><p><small><a href="range.html">range</a>::<a href="#CLASS_IteratorRange">IteratorRange</a>::</small><br/>redef init collection:: <b>init</b>(<a href="#CLASS_Range">Range</a>[E])</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_List"></a><h2>List</h2><small>collection::</small><br/>class <b>List</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Sequence">Sequence</a>
<dt>All superclasses: <dd><a href="#CLASS_Sequence">Sequence</a>, <a href="#CLASS_SequenceRead">SequenceRead</a>, <a href="#CLASS_Map">Map</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Double linked lists.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of List</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_List_from">from</a></b>(<a href="#CLASS_Collection">Collection</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp; Build a list filled with the items of `coll'.
</td></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_List_init">init</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp; Build an empty list.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of List</th></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_MapRead">MapRead</a>::</td><td><b><a href="#PROP_List___bra">[]</a></b>(<a href="kernel.html#CLASS_Int">Int</a>): E<br/>&nbsp;&nbsp;&nbsp;&nbsp; Access
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_List_first">first</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Sequence">Sequence</a>::</td><td><b><a href="#PROP_List_first__eq">first=</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_List_has">has</a></b>(E): <a href="kernel.html#CLASS_Bool">Bool</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_List_is_empty">is_empty</a></b>: <a href="kernel.html#CLASS_Bool">Bool</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_SequenceRead">SequenceRead</a>::</td><td><b><a href="#PROP_List_last">last</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Sequence">Sequence</a>::</td><td><b><a href="#PROP_List_last__eq">last=</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_List_length">length</a></b>: <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; O(n)
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_List_link">link</a></b>(<a href="#CLASS_List">List</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp; Append `l' to `self' but clear `l'.
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Sequence">Sequence</a>::</td><td><b><a href="#PROP_List_pop">pop</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Sequence">Sequence</a>::</td><td><b><a href="#PROP_List_push">push</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Sequence">Sequence</a>::</td><td><b><a href="#PROP_List_shift">shift</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Sequence">Sequence</a>::</td><td><b><a href="#PROP_List_unshift">unshift</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; O(1)
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Sequence">Sequence</a></small></td><td><small><a href="#PROP_Sequence_add">add</a>, <a href="#PROP_Sequence_append">append</a>, <a href="#PROP_Sequence_first__eq">first=</a>, <a href="#PROP_Sequence_last__eq">last=</a>, <a href="#PROP_Sequence_pop">pop</a>, <a href="#PROP_Sequence_push">push</a>, <a href="#PROP_Sequence_shift">shift</a>, <a href="#PROP_Sequence_unshift">unshift</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SequenceRead">SequenceRead</a></small></td><td><small><a href="#PROP_SequenceRead_first">first</a>, <a href="#PROP_SequenceRead_index_of">index_of</a>, <a href="#PROP_SequenceRead_last">last</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Map">Map</a></small></td><td><small><a href="#PROP_Map___braeq">[]=</a>, <a href="#PROP_Map_recover_with">recover_with</a>, <a href="#PROP_Map_remove_at">remove_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SimpleCollection">SimpleCollection</a></small></td><td><small><a href="#PROP_SimpleCollection_add">add</a>, <a href="#PROP_SimpleCollection_add_all">add_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of List</th><tr>
</table>
<a name="PROP_List_from"></a><h3>from</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef init collection:: <b>from</b>(<a href="#CLASS_Collection">Collection</a>[E])</p>
<blockquote><pre> Build a list filled with the items of `coll'.
</pre>
</blockquote>
<hr/>
<a name="PROP_List_init"></a><h3>init</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef init collection:: <b>init</b></p>
<blockquote><pre> Build an empty list.
</pre>
</blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of List</th><tr>
</table>
<a name="PROP_List___bra"></a><h3>[]</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_MapRead">MapRead</a>:: <b>[]</b>(<a href="kernel.html#CLASS_Int">Int</a>): E</p>
<blockquote><pre> Access
</pre>
</blockquote>
<hr/>
<a name="PROP_List_first"></a><h3>first</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>first</b>: E</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_first__eq"></a><h3>first=</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Sequence">Sequence</a>:: <b>first=</b>(E)</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_has"></a><h3>has</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>has</b>(E): <a href="kernel.html#CLASS_Bool">Bool</a></p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_is_empty"></a><h3>is_empty</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>is_empty</b>: <a href="kernel.html#CLASS_Bool">Bool</a></p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_last"></a><h3>last</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_SequenceRead">SequenceRead</a>:: <b>last</b>: E</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_last__eq"></a><h3>last=</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Sequence">Sequence</a>:: <b>last=</b>(E)</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_length"></a><h3>length</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>length</b>: <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> O(n)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_link"></a><h3>link</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun collection:: <b>link</b>(<a href="#CLASS_List">List</a>[E])</p>
<blockquote><pre> Append `l' to `self' but clear `l'.
#
 O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_pop"></a><h3>pop</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Sequence">Sequence</a>:: <b>pop</b>: E</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_push"></a><h3>push</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Sequence">Sequence</a>:: <b>push</b>(E)</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_shift"></a><h3>shift</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Sequence">Sequence</a>:: <b>shift</b>: E</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
<hr/>
<a name="PROP_List_unshift"></a><h3>unshift</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_List">List</a>::</small><br/>redef fun <a href="#CLASS_Sequence">Sequence</a>:: <b>unshift</b>(E)</p>
<blockquote><pre> O(1)
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_ListIterator"></a><h2>ListIterator</h2><small>collection::</small><br/>class <b>ListIterator</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_IndexedIterator">IndexedIterator</a>
<dt>All superclasses: <dd><a href="#CLASS_IndexedIterator">IndexedIterator</a>, <a href="#CLASS_MapIterator">MapIterator</a>, <a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> This is the iterator class of List
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of ListIterator</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_ListIterator_delete">delete</a></b><br/>&nbsp;&nbsp;&nbsp;&nbsp; Remove the current item
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_IndexedIterator">IndexedIterator</a>::</td><td><b><a href="#PROP_ListIterator_index">index</a></b>: <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; The index of the current node
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_ListIterator_insert_before">insert_before</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Insert before the current item
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_ListIterator_item__eq">item=</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_IndexedIterator">IndexedIterator</a></small></td><td><small><a href="#PROP_IndexedIterator_index">index</a>, <a href="#PROP_IndexedIterator_key">key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapIterator">MapIterator</a></small></td><td><small><a href="#PROP_MapIterator_key">key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of ListIterator</th><tr>
</table>
<a name="PROP_ListIterator_delete"></a><h3>delete</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_ListIterator">ListIterator</a>::</small><br/>redef fun collection:: <b>delete</b></p>
<blockquote><pre> Remove the current item
</pre>
</blockquote>
<hr/>
<a name="PROP_ListIterator_index"></a><h3>index</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_ListIterator">ListIterator</a>::</small><br/>redef fun <a href="#CLASS_IndexedIterator">IndexedIterator</a>:: <b>index</b>: <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> The index of the current node
</pre>
</blockquote>
<hr/>
<a name="PROP_ListIterator_insert_before"></a><h3>insert_before</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_ListIterator">ListIterator</a>::</small><br/>redef fun collection:: <b>insert_before</b>(E)</p>
<blockquote><pre> Insert before the current item
</pre>
</blockquote>
<hr/>
<a name="PROP_ListIterator_item__eq"></a><h3>item=</h3><p><small><a href="list.html">list</a>::<a href="#CLASS_ListIterator">ListIterator</a>::</small><br/>redef fun collection:: <b>item=</b>(E)</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_Map"></a><h2>Map</h2><small>collection::</small><br/>class <b>Map</b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_MapRead">MapRead</a>
<dt>All superclasses: <dd><a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_Sequence">Sequence</a>, <a href="#CLASS_CoupleMap">CoupleMap</a>, <a href="#CLASS_HashMap">HashMap</a>
<dt>Refinements in known modules: <dd><a href="string.html">string</a>
</dl>
<pre> Maps are associative collections: `key' -> `item'.

 The main operator over maps is [].

     var map: Map[U, V]
     ...
     map[u1] = v1      # Associate 'v1' to 'u1'
     map[u2] = v2      # Associate 'v2' to 'u2'
     map[u1]            # -> v1
     map[u2]            # -> v2
     map.has_key(u1)    # -> true
     map.has_key(u3)    # -> false
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Map</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Map___braeq">[]=</a></b>(K, E) is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Set the`item' at `key'.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Map_recover_with">recover_with</a></b>(<a href="#CLASS_Map">Map</a>[K, E])<br/>&nbsp;&nbsp;&nbsp;&nbsp; Add each (key,value) of `map' into `self'.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Map_remove_at">remove_at</a></b>(K) is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Remove the item at `key'
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Added Methods in known modules</small></th><tr>
<tr><td width="20%"><small>in <a href="standard.html">standard</a></small></td><td><small><a href="standard.html#PROP_Map_map_join">map_join</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Map</th><tr>
</table>
<a name="PROP_Map___braeq"></a><h3>[]=</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Map">Map</a>::</small><br/>redef fun collection:: <b>[]=</b>(K, E) is abstract</p>
<blockquote><pre> Set the`item' at `key'.
</pre>
</blockquote>
<hr/>
<a name="PROP_Map_recover_with"></a><h3>recover_with</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Map">Map</a>::</small><br/>redef fun collection:: <b>recover_with</b>(<a href="#CLASS_Map">Map</a>[K, E])</p>
<blockquote><pre> Add each (key,value) of `map' into `self'.
 If a same key exists in `map' and `self', then the value in self is discarded.
</pre>
</blockquote>
<hr/>
<a name="PROP_Map_remove_at"></a><h3>remove_at</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Map">Map</a>::</small><br/>redef fun collection:: <b>remove_at</b>(K) is abstract</p>
<blockquote><pre> Remove the item at `key'
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_MapIterator"></a><h2>MapIterator</h2><small>collection::</small><br/>class <b>MapIterator</b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>
<dt>All superclasses: <dd><a href="#CLASS_Iterator">Iterator</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_IndexedIterator">IndexedIterator</a>, <a href="#CLASS_CoupleMapIterator">CoupleMapIterator</a>, <a href="#CLASS_HashMapIterator">HashMapIterator</a>
</dl>
<pre> Iterators for Map.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of MapIterator</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_MapIterator_key">key</a></b>: K is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; The key of the current item.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Iterator">Iterator</a></small></td><td><small><a href="#PROP_Iterator_is_ok">is_ok</a>, <a href="#PROP_Iterator_item">item</a>, <a href="#PROP_Iterator_next">next</a>, <a href="#PROP_Iterator_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of MapIterator</th><tr>
</table>
<a name="PROP_MapIterator_key"></a><h3>key</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_MapIterator">MapIterator</a>::</small><br/>redef fun collection:: <b>key</b>: K is abstract</p>
<blockquote><pre> The key of the current item.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_MapRead"></a><h2>MapRead</h2><small>collection::</small><br/>class <b>MapRead</b>[K: <a href="kernel.html#CLASS_Object">Object</a>E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Collection">Collection</a>
<dt>All superclasses: <dd><a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_Map">Map</a>, <a href="#CLASS_SequenceRead">SequenceRead</a>
</dl>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of MapRead</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_MapRead___bra">[]</a></b>(K): E is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Get the item at `key'.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_MapRead_has_key">has_key</a></b>(K): <a href="kernel.html#CLASS_Bool">Bool</a> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Is there an item at `key'.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of MapRead</th><tr>
</table>
<a name="PROP_MapRead___bra"></a><h3>[]</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_MapRead">MapRead</a>::</small><br/>redef fun collection:: <b>[]</b>(K): E is abstract</p>
<blockquote><pre> Get the item at `key'.
</pre>
</blockquote>
<hr/>
<a name="PROP_MapRead_has_key"></a><h3>has_key</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_MapRead">MapRead</a>::</small><br/>redef fun collection:: <b>has_key</b>(K): <a href="kernel.html#CLASS_Bool">Bool</a> is abstract</p>
<blockquote><pre> Is there an item at `key'.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_NaiveCollection"></a><h2>NaiveCollection</h2><small>collection::</small><br/>class <b>NaiveCollection</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Collection">Collection</a>
<dt>All superclasses: <dd><a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Naive implementation of collections method
 You only have to define iterator!
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of NaiveCollection</th></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
</blockquote><hr/>
<a name="CLASS_NativeArray"></a><h2>NativeArray</h2><small>collection::</small><br/>class <b>NativeArray</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
<dt>All superclasses: <dd><a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Native C array (void ...).
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of NativeArray</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_NativeArray___bra">[]</a></b>(<a href="kernel.html#CLASS_Int">Int</a>): E is intern<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_NativeArray___braeq">[]=</a></b>(<a href="kernel.html#CLASS_Int">Int</a>, E) is intern<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_NativeArray_copy_to">copy_to</a></b>(<a href="#CLASS_NativeArray">NativeArray</a>[E], <a href="kernel.html#CLASS_Int">Int</a>) is intern<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of NativeArray</th><tr>
</table>
<a name="PROP_NativeArray___bra"></a><h3>[]</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_NativeArray">NativeArray</a>::</small><br/>redef fun collection:: <b>[]</b>(<a href="kernel.html#CLASS_Int">Int</a>): E is intern</p>
<blockquote></blockquote>
<hr/>
<a name="PROP_NativeArray___braeq"></a><h3>[]=</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_NativeArray">NativeArray</a>::</small><br/>redef fun collection:: <b>[]=</b>(<a href="kernel.html#CLASS_Int">Int</a>, E) is intern</p>
<blockquote></blockquote>
<hr/>
<a name="PROP_NativeArray_copy_to"></a><h3>copy_to</h3><p><small><a href="array.html">array</a>::<a href="#CLASS_NativeArray">NativeArray</a>::</small><br/>redef fun collection:: <b>copy_to</b>(<a href="#CLASS_NativeArray">NativeArray</a>[E], <a href="kernel.html#CLASS_Int">Int</a>) is intern</p>
<blockquote></blockquote>
</blockquote><hr/>
<a name="CLASS_Range"></a><h2>Range</h2><small>collection::</small><br/>class <b>Range</b>[E: <a href="kernel.html#CLASS_Discrete">Discrete</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Collection">Collection</a>
<dt>All superclasses: <dd><a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
</dl>
<pre> Range of discrete objects. 
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Consructors Summary of Range</th></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Range_init">init</a></b>(E, E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create a range [`from', `to'].
</td></tr>
<tr><td width="20%" align="right">redef init collection::</td><td><b><a href="#PROP_Range_without_last">without_last</a></b>(E, E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Create a range [`from', `to'[.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Range</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Range_after">after</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; Get the element after the last one.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Range_last">last</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; Get the last element.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Consructors Detail of Range</th><tr>
</table>
<a name="PROP_Range_init"></a><h3>init</h3><p><small><a href="range.html">range</a>::<a href="#CLASS_Range">Range</a>::</small><br/>redef init collection:: <b>init</b>(E, E)</p>
<blockquote><pre> Create a range [`from', `to'].
 The syntax [`from'..`to'[ is equivalent.
</pre>
</blockquote>
<hr/>
<a name="PROP_Range_without_last"></a><h3>without_last</h3><p><small><a href="range.html">range</a>::<a href="#CLASS_Range">Range</a>::</small><br/>redef init collection:: <b>without_last</b>(E, E)</p>
<blockquote><pre> Create a range [`from', `to'[.
 The syntax [`from'..`to'[ is equivalent.
</pre>
</blockquote>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Range</th><tr>
</table>
<a name="PROP_Range_after"></a><h3>after</h3><p><small><a href="range.html">range</a>::<a href="#CLASS_Range">Range</a>::</small><br/>redef fun collection:: <b>after</b>: E</p>
<blockquote><pre> Get the element after the last one.
</pre>
</blockquote>
<hr/>
<a name="PROP_Range_last"></a><h3>last</h3><p><small><a href="range.html">range</a>::<a href="#CLASS_Range">Range</a>::</small><br/>redef fun collection:: <b>last</b>: E</p>
<blockquote><pre> Get the last element.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_RemovableCollection"></a><h2>RemovableCollection</h2><small>collection::</small><br/>class <b>RemovableCollection</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_Collection">Collection</a>
<dt>All superclasses: <dd><a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_Map">Map</a>
</dl>
<pre> Items can be removed from this collection
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of RemovableCollection</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_RemovableCollection_clear">clear</a></b> is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Remove all items
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_RemovableCollection_remove">remove</a></b>(E) is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Remove an occucence of `item'
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_RemovableCollection_remove_all">remove_all</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Remove all occurences of `item'
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of RemovableCollection</th><tr>
</table>
<a name="PROP_RemovableCollection_clear"></a><h3>clear</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_RemovableCollection">RemovableCollection</a>::</small><br/>redef fun collection:: <b>clear</b> is abstract</p>
<blockquote><pre> Remove all items
</pre>
</blockquote>
<hr/>
<a name="PROP_RemovableCollection_remove"></a><h3>remove</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_RemovableCollection">RemovableCollection</a>::</small><br/>redef fun collection:: <b>remove</b>(E) is abstract</p>
<blockquote><pre> Remove an occucence of `item'
</pre>
</blockquote>
<hr/>
<a name="PROP_RemovableCollection_remove_all"></a><h3>remove_all</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_RemovableCollection">RemovableCollection</a>::</small><br/>redef fun collection:: <b>remove_all</b>(E)</p>
<blockquote><pre> Remove all occurences of `item'
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_Sequence"></a><h2>Sequence</h2><small>collection::</small><br/>class <b>Sequence</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_SequenceRead">SequenceRead</a>, <a href="#CLASS_Map">Map</a>, <a href="#CLASS_SimpleCollection">SimpleCollection</a>
<dt>All superclasses: <dd><a href="#CLASS_SequenceRead">SequenceRead</a>, <a href="#CLASS_Map">Map</a>, <a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_List">List</a>, <a href="#CLASS_AbstractArray">AbstractArray</a>
</dl>
<pre> Indexed collection are ordoned collections.
 The first item is 0. The last is `length'-1.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Sequence</th></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_SimpleCollection">SimpleCollection</a>::</td><td><b><a href="#PROP_Sequence_add">add</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; A synonym of `push'
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Sequence_append">append</a></b>(<a href="#CLASS_Collection">Collection</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp; Add each item of `coll` after the last.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Sequence_first__eq">first=</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Set the first item.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Sequence_last__eq">last=</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Set the last item.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Sequence_pop">pop</a></b>: E is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Remove the last item.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Sequence_push">push</a></b>(E) is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Add an item after the last.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Sequence_shift">shift</a></b>: E is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Remove the first item.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_Sequence_unshift">unshift</a></b>(E) is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Add an item before the last.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SequenceRead">SequenceRead</a></small></td><td><small><a href="#PROP_SequenceRead_first">first</a>, <a href="#PROP_SequenceRead_index_of">index_of</a>, <a href="#PROP_SequenceRead_last">last</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Map">Map</a></small></td><td><small><a href="#PROP_Map___braeq">[]=</a>, <a href="#PROP_Map_recover_with">recover_with</a>, <a href="#PROP_Map_remove_at">remove_at</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SimpleCollection">SimpleCollection</a></small></td><td><small><a href="#PROP_SimpleCollection_add">add</a>, <a href="#PROP_SimpleCollection_add_all">add_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Sequence</th><tr>
</table>
<a name="PROP_Sequence_add"></a><h3>add</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun <a href="#CLASS_SimpleCollection">SimpleCollection</a>:: <b>add</b>(E)</p>
<blockquote><pre> A synonym of `push'
</pre>
</blockquote>
<hr/>
<a name="PROP_Sequence_append"></a><h3>append</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun collection:: <b>append</b>(<a href="#CLASS_Collection">Collection</a>[E])</p>
<blockquote><pre> Add each item of `coll` after the last.
</pre>
</blockquote>
<hr/>
<a name="PROP_Sequence_first__eq"></a><h3>first=</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun collection:: <b>first=</b>(E)</p>
<blockquote><pre> Set the first item.
 Is equivalent with `self'[0] = `item'.
</pre>
</blockquote>
<hr/>
<a name="PROP_Sequence_last__eq"></a><h3>last=</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun collection:: <b>last=</b>(E)</p>
<blockquote><pre> Set the last item.
 Is equivalent with `self'[length-1] = `item'.
</pre>
</blockquote>
<hr/>
<a name="PROP_Sequence_pop"></a><h3>pop</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun collection:: <b>pop</b>: E is abstract</p>
<blockquote><pre> Remove the last item.
</pre>
</blockquote>
<hr/>
<a name="PROP_Sequence_push"></a><h3>push</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun collection:: <b>push</b>(E) is abstract</p>
<blockquote><pre> Add an item after the last.
</pre>
</blockquote>
<hr/>
<a name="PROP_Sequence_shift"></a><h3>shift</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun collection:: <b>shift</b>: E is abstract</p>
<blockquote><pre> Remove the first item.
 The second item become the first.
</pre>
</blockquote>
<hr/>
<a name="PROP_Sequence_unshift"></a><h3>unshift</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Sequence">Sequence</a>::</small><br/>redef fun collection:: <b>unshift</b>(E) is abstract</p>
<blockquote><pre> Add an item before the last.
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_SequenceRead"></a><h2>SequenceRead</h2><small>collection::</small><br/>class <b>SequenceRead</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_MapRead">MapRead</a>
<dt>All superclasses: <dd><a href="#CLASS_MapRead">MapRead</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_Sequence">Sequence</a>, <a href="#CLASS_AbstractArrayRead">AbstractArrayRead</a>
</dl>
<pre> Indexed collection are ordoned collections.
 The first item is 0. The last is `length'-1.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of SequenceRead</th></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_SequenceRead_first">first</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; Get the first item.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_SequenceRead_index_of">index_of</a></b>(E): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; Return the index of the first occurence of `item'.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_SequenceRead_last">last</a></b>: E<br/>&nbsp;&nbsp;&nbsp;&nbsp; Get the last item.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_MapRead">MapRead</a></small></td><td><small><a href="#PROP_MapRead___bra">[]</a>, <a href="#PROP_MapRead_has_key">has_key</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of SequenceRead</th><tr>
</table>
<a name="PROP_SequenceRead_first"></a><h3>first</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_SequenceRead">SequenceRead</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>first</b>: E</p>
<blockquote><pre> Get the first item.
 Is equivalent with `self'[0].
</pre>
</blockquote>
<hr/>
<a name="PROP_SequenceRead_index_of"></a><h3>index_of</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_SequenceRead">SequenceRead</a>::</small><br/>redef fun collection:: <b>index_of</b>(E): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> Return the index of the first occurence of `item'.
 Return -1 if `item' is not found
</pre>
</blockquote>
<hr/>
<a name="PROP_SequenceRead_last"></a><h3>last</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_SequenceRead">SequenceRead</a>::</small><br/>redef fun collection:: <b>last</b>: E</p>
<blockquote><pre> Get the last item.
 Is equivalent with `self'[`length'-1].
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_Set"></a><h2>Set</h2><small>collection::</small><br/>class <b>Set</b>[E: <a href="kernel.html#CLASS_Object">Object</a>]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_SimpleCollection">SimpleCollection</a>
<dt>All superclasses: <dd><a href="#CLASS_SimpleCollection">SimpleCollection</a>, <a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_ArraySet">ArraySet</a>, <a href="#CLASS_HashSet">HashSet</a>
</dl>
<pre> Abstract sets.

 Set contains contains only one element with the same value (according to =).
    var s : Set[E]
    var a = "Hello"
    var b = "Hello"
    ...
    s.add(a)
    s.has(b) # --> true
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of Set</th></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_Collection">Collection</a>::</td><td><b><a href="#PROP_Set_count">count</a></b>(E): <a href="kernel.html#CLASS_Int">Int</a><br/>&nbsp;&nbsp;&nbsp;&nbsp; Only 0 or 1
</td></tr>
<tr><td width="20%" align="right">redef fun <a href="#CLASS_RemovableCollection">RemovableCollection</a>::</td><td><b><a href="#PROP_Set_remove_all">remove_all</a></b>(E)<br/>&nbsp;&nbsp;&nbsp;&nbsp; Synonym of remove since there is only one item
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_SimpleCollection">SimpleCollection</a></small></td><td><small><a href="#PROP_SimpleCollection_add">add</a>, <a href="#PROP_SimpleCollection_add_all">add_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of Set</th><tr>
</table>
<a name="PROP_Set_count"></a><h3>count</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Set">Set</a>::</small><br/>redef fun <a href="#CLASS_Collection">Collection</a>:: <b>count</b>(E): <a href="kernel.html#CLASS_Int">Int</a></p>
<blockquote><pre> Only 0 or 1
</pre>
</blockquote>
<hr/>
<a name="PROP_Set_remove_all"></a><h3>remove_all</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_Set">Set</a>::</small><br/>redef fun <a href="#CLASS_RemovableCollection">RemovableCollection</a>:: <b>remove_all</b>(E)</p>
<blockquote><pre> Synonym of remove since there is only one item
</pre>
</blockquote>
</blockquote><hr/>
<a name="CLASS_SimpleCollection"></a><h2>SimpleCollection</h2><small>collection::</small><br/>class <b>SimpleCollection</b>[E: nullable Object]
<blockquote>
<dl>
<dt>Direct superclasses: <dd><a href="#CLASS_RemovableCollection">RemovableCollection</a>
<dt>All superclasses: <dd><a href="#CLASS_RemovableCollection">RemovableCollection</a>, <a href="#CLASS_Collection">Collection</a>, <a href="kernel.html#CLASS_Object">Object</a>
<dt>Direct subclasses: <dd><a href="#CLASS_Set">Set</a>, <a href="#CLASS_Sequence">Sequence</a>
</dl>
<pre> Items can be added to these collections.
</pre>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th colspan="2">Methods Summary of SimpleCollection</th></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_SimpleCollection_add">add</a></b>(E) is abstract<br/>&nbsp;&nbsp;&nbsp;&nbsp; Add an item in a collection.
</td></tr>
<tr><td width="20%" align="right">redef fun collection::</td><td><b><a href="#PROP_SimpleCollection_add_all">add_all</a></b>(<a href="#CLASS_Collection">Collection</a>[E])<br/>&nbsp;&nbsp;&nbsp;&nbsp; Add each item of `coll`.
</td></tr>
</table><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Inherited Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="#CLASS_RemovableCollection">RemovableCollection</a></small></td><td><small><a href="#PROP_RemovableCollection_clear">clear</a>, <a href="#PROP_RemovableCollection_remove">remove</a>, <a href="#PROP_RemovableCollection_remove_all">remove_all</a></small></td><tr>
<tr><td width="20%"><small>from <a href="#CLASS_Collection">Collection</a></small></td><td><small><a href="#PROP_Collection_count">count</a>, <a href="#PROP_Collection_first">first</a>, <a href="#PROP_Collection_has">has</a>, <a href="#PROP_Collection_has_only">has_only</a>, <a href="#PROP_Collection_is_empty">is_empty</a>, <a href="#PROP_Collection_iterate">iterate</a>, <a href="#PROP_Collection_iterator">iterator</a>, <a href="#PROP_Collection_length">length</a>, <a href="#PROP_Collection_to_a">to_a</a></small></td><tr>
<tr bgcolor="#EEEEFF"><th colspan="2"><small>Imported Methods</small></th><tr>
<tr><td width="20%"><small>from <a href="hash.html">hash</a></small></td><td><small><a href="hash.html#PROP_Object_hash">hash</a></small></td><tr>
<tr><td width="20%"><small>from <a href="kernel.html">kernel</a></small></td><td><small><a href="kernel.html#PROP_Object___neq">!=</a>, <a href="kernel.html#PROP_Object___eqeq">==</a>, <a href="kernel.html#PROP_Object_exit">exit</a>, <a href="kernel.html#PROP_Object_is_same_type">is_same_type</a>, <a href="kernel.html#PROP_Object_object_id">object_id</a>, <a href="kernel.html#PROP_Object_output">output</a>, <a href="kernel.html#PROP_Object_sys">sys</a></small></td><tr>
</table><br/><br/>
<table border="1" width="100%" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF"><th>Methods Detail of SimpleCollection</th><tr>
</table>
<a name="PROP_SimpleCollection_add"></a><h3>add</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_SimpleCollection">SimpleCollection</a>::</small><br/>redef fun collection:: <b>add</b>(E) is abstract</p>
<blockquote><pre> Add an item in a collection.
 Ensure col.has(item)
</pre>
</blockquote>
<hr/>
<a name="PROP_SimpleCollection_add_all"></a><h3>add_all</h3><p><small><a href="abstract_collection.html">abstract_collection</a>::<a href="#CLASS_SimpleCollection">SimpleCollection</a>::</small><br/>redef fun collection:: <b>add_all</b>(<a href="#CLASS_Collection">Collection</a>[E])</p>
<blockquote><pre> Add each item of `coll`.
</pre>
</blockquote>
</blockquote><hr/>
</body></html>
